&&&&&&&&&&&& IMPDOC.SUB

IMPDOC.SUB
IMP.RNH
3B35B.LAY
3B35C.RNO
3B35D.RNO
$$$$$$$$$$$$
&&&&&&&&&&&& IMP.RNH

.FLAG CAP.LC
.P 0;.AP;.F;.TS 6
 ^THE <IMP COMPILER IS RUN BY THE MONITOR COMMAND
.NAP;.NF.S
	<_.R <IMP
TO WHICH THE COMPILER RESPONDS WITH THE PROMPT
.S
	*
THE COMMAND STRING IT REQUIRES IS
.S
	* _<REL-FILESPEC_> , _<LIST-FILESPEC_> = _<INPUT-FILESPEC_>
OR	* _<REL-FILESPEC_> = _<INPUT-FILESPEC_>
OR	* _<INPUT-FILESPEC_>
.S.F
 ^THE _<FILESPEC_>S REFER TO THE STANDARD <DEC-10
FILE SPECIFICATIONS NAMELY:-
.S;.NF
^DEVICE: FILENAME . EXTENSION [DIRECTORY LIST]
.AP;.F
 ^THE DIRECTORY LIST SPECIFICATION CAN INCLUDE SUB-FILE-DIRECTORIES.
^THE FOLLOWING SWITCHES TO THE COMPILER MAY ALSO BE INCLUDED AFTER ANY
OF THE FILE SPECIFICATIONS:-
.NAP.S.NF
	</CROSS  - INCLUDE A CROSS REFERENCED LISTING
	          (IMPLIES A </LIST)
	</LIST   - INCLUDE A LISTING FILE
	</NOCODE - SYNTAX CHECK ONLY
	</NOLIST - DO NOT INCLUDE A LISTING FILE
.S
^THUS 
	.<R <IMP
	* <FRED/CROSS/NOLIST/NOCODE
.S.F
WILL PRODUCE A LISTING FILE CALLED <FRED.LST CONTAINING ONLY THE CROSS
REFERENCE TABLES AND WILL ONLY DO SYNTAX CHECKING WITHOUT
GENERATING ANY CODE.
.F.AP
 ^THE DEFAULTS APPLIED TO INCOMPLETE FILE SPECIFICATIONS ARE:-
.NAP.NF
      INPUT-FILESPEC - <DSK: FILENAME . <IMP [USER]
      REL-FILESPEC   - <DSK: FILENAME . <REL [USER]
      LIST-FILESPEC  - <DSK: FILENAME . <LST [USER]
.AP;.F
 ^A <.REL FILE IS ALWAYS PRODUCED UNLESS SUPPRESSED BY THE </NOCODE SWITCH AND
A LISTING FILE IS ONLY PRODUCED IF ASKED FOR BY THE </LIST OR </CROSS
SWITCHES OR IF A LISTING FILE SPECIFICATION IS GIVEN.
$$$$$$$$$$$$
&&&&&&&&&&&& 3B35B.LAY

$A JUST=1
$A INVERT=0; INVO=0
$A sectno=0; pageno=0
$A CAP=0; CAPO=0
$A LEFT=6; LINE=66; PAGE=58; MARK=2
$A TAB=5,10,15,20,25,35,42,46,50
$B16 $L0M
.the .imp-77 .language




As implemented by

.peter .s$. .robertson
.department .of .computer .science
.university .of .edinburgh




A .reference .manual

first edition: .december 1977
$N $lm
.introduction
$P1 .imp-77 is an "ALGOL-like" high-level language. Relative to .algol
60, the language adds program structuring, data structuring, event
signalling, and string handling facilities, but removes (or retains
in a modified form) intrinsically inefficient features such as the
.algol 60 %name (substitution) parameter.
$P1 The language, based on Atlas Autocode, was originally
designed
as the implementation language for the Edinburgh
Multi-Access
System - hence its name - but has since been used
successfully for
implementing systems, teaching programming and as
a
general-purpose programming language on many different machines.
$B1 Two of the major design aims were:
$B1 $T1 1. $T2 The language should compile to efficient machine code.
$B1 $T1 2. $T2 The syntax of the language should be verbose rather than
$B0 $T2 obscure.
$P1 The main disadvantage of .imp is that it is not currently in
widespread use.
$P1 Most .imp systems provide comprehensive compile-time and
run-time diagnostics, together with an option to suppress
generation of run-time checks when compiling tested programs.
$P1 Input/output facilities are provided through the external
procedure mechanism and are therefore open-ended and can be
defined as required, though a standard set of procedures is
supported.
$N
$A SECTNO=1; PAGENO=1
$L1M
.program .layout .conventions
$P1 An .imp program is a sequence of %statements constructed using
the .ascii character set extended with an underlined alphabet.
Underlined letters, which are used to form %keywords, are generated
using the shift character percent ($%), which is defined as
underlining all subsequent letters, the underlining being
terminated by any non-alphabetic character.
$B0 Hence the following statements are equivalent:
$B $T4 $C+1 .$%string .(7)$%array .$%name P
$B0 $T4 $C+1 .$%string .(7)$%arrayname P
$B and both represent:
$B0 $T4 $C+1 _s_t_r_i_n_g(7)%array %name P
$P1 In this manual, keywords are in lower case and underlined.
$b2 %Newline
$p1 The .newline (or .line .break) character is .ascii
character 10 .(lf).
$B2 %Spaces
$P1 Except when used to terminate keywords or when between quotes
(see Quotes) spaces are ignored by the compiler and may be used to
improve the legibility of the program.
$B2 %Lower %Case %Letters
$P1 Except when enclosed in quotes (see Quotes) lower case letters
are equivalent to upper case letters.
$B1 %Quotes
$P1 Several language constructions call for one or more characters
to
be enclosed in quotes: between quotes %all characters are
significant and stand for themselves.
$B0 .n.b. Space, newline, and percent characters may appear between
quotes and stand for space, newline, and percent.
$P Two quote characters are used:
$A INDENT=2
$B1 ' $T3 - $T4 symbol quote e.g. .'a'
$B0 " $T3 - $T4 string quote e.g. ."fred"
$A INDENT=0
$B1 If it is required to include the delimiting quote
within the text
it must be
represented by two consecutive quotes; e.g.
$A INDENT=2
$B1 '''' $T5 $C+1 - $T6 the symbol quote
$B0 "a ""big"" dog" $C+1 - $T6 a string of 11 characters
$A INDENT=0
$B1 However, note: '"' and "it's mine"
$V9
$B2 %Identifiers
$P1 An identifier is a sequence of any number of letters and digits
starting with a letter, e.g. .max, .x, .case 1, .case 2, .case .2b
$B1 All letters and digits are significant.
$B1 Except in the case of simple labels (see Control Transfer
Instructions) all identifiers must be %declared before they may be
used (see Declarations).
$B2 %Statements
$P1 A .statement is a sequence of atomic elements (keywords,
constants, identifiers etc.) arranged according to the syntactic
rules of .imp.
$B2 %Termination
$P1 Every statement must be terminated by a newline or a
semicolon
(however, see Comments).
$B2 _N_u_l_l$_%Statements
$P1 There are two types of null statement, both of which are
ignored by the compiler. They may be used to improve the
legibility
of the program.
$A INDENT=1
$B1 1. $T2 Redundant terminators, E.g. blank lines
$B1 2. $T2 Comments
$A INDENT=3
$B1 A comment is any sequence of characters (the
"comment
text") preceded by a comment mark and
ending with a
newline character (note: a semicolon
does not
terminate a comment; it is included as part
of the
comment text).
$B0 The comment marks are either the keyword %comment or
an exclamation mark (!); e.g.
$B1 $I+1 %comment main loop starts here
$B0 $I+1 ! return here on error
$B1 As a semicolon does not terminate a comment it is a
simple matter to 'comment out' sections of code.
$A INDENT=4
$P1 .compute .cases
$B0 ! $C+2 %if .cases < 0 %start
$B0 ! $T5 $C+1 .display .data; $C+2 .newline; $C+2 .tidy .up
$B0 ! $T5 $C+1 %stop
$B0 ! $C+2 %finish
$P0 .handle .cases
$B1 $T3 (Also see note on Continuation)
$v5
$B2 $T0 %Instructions
$A INDENT=0
$P0 An instruction is any imperative statement which may be made
conditional and is either an assignment, a Routine call or a
control transfer.
$B2 %Continuation
$P0 A statement may extend over several physical lines provided
that each line break occurs after a comma, or is preceeded by the
keyword %c. E.g.
$B1 $T2 $C+4 %if X = Y %then P = 1 %c
$B0 $T4 $C+3 %else P = 0
$B1 which is exactly equivalent to:
$B1 $T2 $C+4 %if X = Y %then P = 1 %else P = 0
$B1 $T1 Notes
$B0
$T2 1. $T3 A statement may have an unlimited number of
$B0 $T3 continuations.
$B1 $T2 2. $T3 The line break following %c causes underlining to be
$B0 $T3 terminated.
$B1 $T2 3. $T3 %c is only permitted between complete atoms of the
$A INDENT=3
language; that is, it may not split keywords,
constants, etc.
$B1 $T2 4. $T3 .$%c between quotes stands for the two characters
percent and .c.
$B1 $T2 5. $T3 The effect of a comment mark is
limited to one
physical line (see Null
statements).
$A INDENT=0
$B2 $T0 _L_i_s_t_i_n_g$_%Control
$A INDENT=1
$P1 During the compilation of a program a line-numbered listing
is produced. The statements %list and %endoflist may be used
respectively to enable or disable the listing for selected
parts of a program. The default is for listing to be enabled.
$B2 $T0 %Include
$P A file of statements (terminated by
"%end %of _f_i_l_e") may be compiled into a program by giving the
statement
$B0 $T4 "_i_n_c_l_u_d_e" {file specification}
$B1 where {file specification} is a string constant representing a
(system dependent) file name. E.g.
$B1 $T4 %include ."ecsc17.listvars"
$B1 Refer to the relevant appendix for details of system-dependent
limitations on the use of %include.
$n $L1M
.constants
$B1 $T0 _I_n_t_e_g_e_r$__C_o_n_s_t_a_n_t_s (_F_i_x_e_d$_%Point)
$B1 a) $T2 .decimal constants
$A INDENT=2
A decimal constant is a sequence of decimal digits.
For
example:
$B0 $C+1 7, 43, 2195, 0, 8, 100 000 000
$B1 $T1 b) $T2 .non-decimal constants
$B0 The prefix {decimal constant}"$_" may be used to specify
the base of the following constant.
 The letters .a, .b, ..., Z are
used to represent
the 'digits' 10, 11, ..., 35
$B0 E.g.
$B0 2$_1010 $T4 $C+5 - binary ten
$B0 8$_12 $T4 $C+5 - octal ten
$B0 16$_a $T4 $C+5 - hexadecimal ten
$B1 $T1 c) $T2 .character constants
$B0 The .ascii code value of any character may be
obtained by
enclosing the character in single
quotes. When the
required character is a single
quote it must be
represented by two consecutive
single quotes.
$B0 Examples: .'a', 'a', '+', '0', '"', '''', ' ', '
$B0 '
$B0 Note the last three examples, which represent
respectively the
code values for single quote, space, and
newline.
$B1 The predefined named constant .nl may be used in
place of
the rather cumbersome form of a newline
character
enclosed in quotes.
$B1 $T1 d) $T2 .multi-character constants
$B0 The previous form may be extended to pack together
the
codes for several characters to form a single
integer
constant.
$B1 .'over', 'Max', '1+2', '*@@#'
$B1 The exact nature of the packing and the maximum
number of
characters which may be packed are both
machine
dependent.
$A INDENT=1
$B1 An integer expression with operands which are constants may be
used wherever an integer constant is required (see
Expressions).
$N
$A INDENT=0
$B2 $T0 _R_e_a_l$__C_o_n_s_t_a_n_t_s (_F_l_o_a_t_i_n_g$_%Point)
$P1 A real constant is a sequence of decimal digits optionally
including one decimal point.
$B0 The constant may also be followed by a scaling factor of
the form
"@"{signed integer constant} meaning "times ten to the power
{signed integer constant}". For example, the following real constants
all have
the same value:
$B1 $T2 120.0, 120, 1.2@2, 12@1, 1200@-1
$B1 Note that a decimal integer constant is a special case of a
real
constant.
$v15
$B2 $T0 _S_t_r_i_n_g$_%Constants
$P1 A string constant is a sequence of not more than 255
characters
enclosed in double quote characters - a double
quote being
represented inside a string constant by two
consecutive double
quotes.
$B1 E.g. ."starting .time", "x = y*4+x", "a ""red"" hood"
$B1 $T2 a) $T3 ."a" is a %string constant of one character.
$B0 $T3 .'a' is a character (_i_n_t_e_g_e_r) constant.
$B1 $T2 b) $T3 The %null %string, a string of no characters, is
$A INDENT=3
permitted and is represented by two consecutive
double quotes ("").
$S
$A INDENT=0
$B3 $T5 $C+3 .expressions
$B1 $T1 1 Arithmetic Expressions
$A INDENT=2
$P1 An arithmetic expression is a sequence of arithmetic
operands and operators obeying the usual rules of
algebra. An operand is either a constant, a variable, a
function call, a map call, or a numerical expression
enclosed in parentheses (see Declarations and
Procedures).
$B1 a) Integer Expressions
$A INDENT=3
$P0 All the operands and operators in an integer
expression must yield an integer value.
$B0 The operators available are:
$B1 + $T4 addition
$B0 - $T4 subtraction or unary minus
$B0 * $T4 multiplication
$B0 // $T4 integer division (the remainder of the
$A INDENT=4
division, which is of the same sign as the
dividend, is ignored).
$B0 $T3 \\ $T4 integer exponentiation.
The second operand (the exponent) must be a non-negative integer.
$B2 $T2 b) Real Expressions
$A INDENT=3
$P0 All the operands and operators in a real
expression must yield real (or integer) results.
Where an operator will take either real or integer
operands (E.g. *) and the types of the given
operands differ the integer operand will be
converted to a real value, otherwise the result of
the operation will be of the same type as the
original operands. The pre-defined real function
.float may be used to force the conversion of an
integer expression into a real expression.
$B0 The operators available are:
$B1 + $T4 addition
$B0 - $T4 subtraction or unary minus
$B0 * $T4 multiplication
$B0 / $T4 division
$B0 \ $T4 real exponentiation
$A indent=2
$P1 The modulus (absolute value) of an expression (integer or real)
may be obtained by enclosing that expression between vertical bars.
$b0
E.g. $t4 |X-Y|
$A indent=4
$v14
$B1 $T2 Notes $T4 1. $T5 Unary minus is treated as "0-..."
$A INDENT=4
$B1 2. $T5 Unary plus (+) is not accepted.
$B1 3. $T5 An expression may not contain two adjacent
$A INDENT=5
operators - they must be separated by
parentheses E.g. $C+2 23*(-14)
$B1 $T4 4. $T5 Integer values will be converted to real
where necessary, but real values will
never be converted to integer unless this
is
explicitly specified using the
pre-defined
functions .int or .intpt.
$A INDENT=0
$B1 $T1 2 Bit-Vector Expressions
$A INDENT=2
$P0 All operands must yield bit-vector (integer) values.
The operations are performed on a bit-by-bit basis using
the operators:
$A INDENT=3
$B1 & $T4 .and
$B0 ! $T4 .inclusive .or
$B0 !! $T4 .exclusive .or
$B0 << $T4 .left .shift (logical)
$B0 >> $T4 .right .shift (logical)
$B0 \ $T4 .complement (unary not)
$A INDENT=2
$B1 It is possible to mix integer and bit-vector expressions
but the full implications of this may be machine
dependent.
$B2 $T1 3 String Expressions
$P0 All operands of a string expression must yield values
of type %string. The only operator available is "." for
concatenation (joining together). No sub-expressions in
parentheses are permitted.
$P1 E.g$. $C+2 ."mr .".surname
$B2 $T0 _P_r_e_c_e_d_e_n_c_e$__o_f$_%Operators
$B2 Highest: $T4 1. $T5 \ $ (unary not)
$A INDENT=4
2. $T5 \, \\, <<, >>
$B0 3. $T5 *, /, //, &
$A INDENT=2
Lowest: $T4 4. $T5 +, - (unary and binary), !, !!
$p In general, sub-expressions with operators of
equal precedence are evaluated from left to right.
$B0 The precedence rules may be over-ridden by means of
parentheses.
$B1 Note: $T4 -1\\2 = -1
$A INDENT=4
$B1 (-1)\\2 = 1
$B1 2\\2\\3 = 4\\3 = 64
$S
$A INDENT=0
$B1 $L1M
.declarations
$A INDENT=1
$P1 All identifiers (except simple labels) must be declared at
the start of a block before they are used. The %scope of an
identifier is the rest of the block in which it is declared,
including any blocks subsequently defined therein (see Block
Structure and note 3 on Labels and Jumps).
$B0 In the following discussion the phrase {type} has four
variants:
$A INDENT=3
1. $T4 "_i_n_t_e_g_e_r"
$B0 2. $T4 "_r_e_a_l"
$B0 3. $T4 "_s_t_r_i_n_g" "(" {max} ")"
$B0 4. $T4 "_r_e_c_o_r_d" "(" {format} ")"
$B1 $T2 and $T3 {max} is an %integer constant in the range
$A INDENT=4
1<=max<=255 defining the maximum number of
characters which may be held in the string.
$B0 $T3 {format} defines the structure of the record (see
Records).
$B1 $T1 1. Variables
$B $T2 a) $T3 Simple Variables
$B $T3 {type}{idlist}
$B1 %integer .j,k,count
$B0 %real .pressure
$B0 %string (30) .country, .town
$B0 %record .(carfm) .mini, .rover
$B1 Each variable is allocated an appropriate
(machine dependent) amount of storage to hold a
value of the appropriate type.
$B $T2 b) $T3 Pointer Variables
$B $T3 {type} "_n_a_m_e" {idlist}
$B1 %integer %name P
$B0 %real %name .datum
$B0 %string (15) %name .who,where
$B0 %record .(carfm) %name .car
$B1 Each variable is allocated enough storage to
hold a pointer to (i.e. the address of) a
simple variable of the specified type.
$n $T2 c) $t3 Array Pointer Variables
$B $T3 {type} "_a_r_r_a_y" "_n_a_m_e" {idlist}
$B0 $T2 $C+1 or $t3 {type} "_n_a_m_e" "_a_r_r_a_y" "_n_a_m_e" {idlist}
$B1 %integer %array %name .an
$B0 %real %array %name .values
$B0 %string (20) %array %name .names, .addresses
$B0 %record .(carfm) %array %name .make
$b0 %real %name %array %name .answers
$B1 Each variable is allocated enough storage to
hold a pointer to (i.e. the address of) an one
dimensional %array of the specified type.
$B $t3 ............ "_a_r_r_a_y" "(" {dim} ")" "_n_a_m_e" {idlist}
$b is provided for declaring pointers to multi-dimensional
arrays. E.g.
$B %real %array (4) %name .space .time
$b0 %integer %name %array (2) %name .lists
$B $T1 2$. $C+2 Arrays
$A INDENT=3
$B1 {type} %array {adefn}("," {adefn})*
$b0 $t2 $c+1 or $t3 {type} "_n_a_m_e" "_a_r_r_a_y" {adefn}(","{adefn})*
$B1 {adefn} $T5 $C+2 ::= {idlist} "(" {pair}(","{pair})* ")"
$B0 {pair} $T5 $C+2 ::= {integer exprn} ":" {integer exprn}
$B1 %integer %array .a(1:10),b,c(-4:limit)
$B0 %real %array .q(1:j+k, .1:j-k)
$B0 %string (12) %array .class(-7:16)
$B0 %record .(carfm) %array .table(lower:upper)
$b0 %integer %name %array pointers(1:12)
$B1 The bound pairs, {pair}, are evaluated and the
required amount of storage is allocated to each
identifier.
$A INDENT=4
$B1 $T2 note 1. $T4 In each bound pair the value of the
first
expression (lower bound) must be less than or
equal to the value of the second expression (upper bound).
$B1 $T3 2. $T4 The number of bound pairs (the dimension of the
array) usually may not exceed six, but this is
implementation dependent.
$B2 $T1 3. $T2 Records
$A INDENT=2
$P1 A %record is a named collection of variables, arrays
and records. The components (elements) of a record may
be any of the forms discussed in (1) and (2) above, with
the following limitations:
$B1 a. $T3 Arrays must be one dimensional and have constant
$B0 $T3 bounds.
$B0 b. $T3 A record may not contain a simple record (or a
$A INDENT=3
record array) of its own format. However it may
contain record pointer variables of its own format.
$A INDENT=2
$V10
$B1 There are three ways to specify formats:
$B1 1. $T3 Explicit Definition
$B1 %record "(" {declaration list} ")" ....
$A INDENT=4
$B1 %record (%integer .x,y,z) R
$B0 %record (%real .p, %real %name .q) %name .s,t
$B0 %record (%real %array .a(1:5), %real .v) %array .x(1:4)
$A INDENT=2
$B1 2. $T3 Using a %format identifier
$B1 %record %format {id} "(" {declaration list} ")"
$B0 %record "(" {id} ")" .....
$A INDENT=4
$B1 %record %format F(%integer .x, _r_e_c_o_r_d(F)%name .link)
$B1 %record .(f) .head
$B0 %record .(f) %array .cell(1:15)
$A INDENT=2
$B1 3. $T3 Using a previously declared record as a format
$b0 $t3 definition.
$A INDENT=4
$B1 %record (%integer .one, .two, .three) R
$B0 %record (%like .r) .s,t
$A INDENT=3
$b1 $t2 Note 1. $t4 Within a format each identifier must be unique
but will not clash with any identifiers outwith that format
(see Block Structure for a discussion of local and
global identifiers).
$B1 2. $T4 When space is allocated to a record variable
the elements are laid out in the order in which they
were declared. However see the relevant appendix
for machine dependent alignment considerations.
$N $L1M
.record .element .selection
$A INDENT=2
$P1 Selection of a specific element from a record is
achieved by following the record identifier by:
$B0$T4 "$_"{element id}
$B1 E.g. given the declarations:
$A INDENT=4
$B1 %record %format F(%integer .x, _r_e_c_o_r_d(F) %name .link)
%record .(f) R
$A INDENT=2
$B2 some valid references to variables are:
$A just=0
$B1 R $T5 - a record of format F
$B0 .r$_x $T5 - an integer
$B0 .r$_link $T5 - a pointer to a record of format F
$B0 .r$_link$_x $T5 - an integer
$B0 .r$_link$_link $T5 -  a pointer to a record of format F
.r$_link$_link$_x $T5 - an integer
$A just=1
$A INDENT=1
$A TAB=2
$P5 ----------------------------------
$B0 R | $T2 $C+1 .r$_x $T4 | $T5 $C+2 .r$_link $T6 $C+4 |
$P0 ----------------------------------
$A INDENT=6
$A TAB=5,10,15,20,25,26
|
$B0 |
$B0 $T3 $C+3 ----------------------------------
$B0 $T3 $C+2 | $T4 $C+1 .r$_link$_x $C+4 | $C+3 .r$_link$_link $T9 $C+2 |
$B0 $T3 $C+3 ----------------------------------
$A INDENT=7
$A TAB=5,10,15,20,25,35,41
|
$B0 |
$B0 $T5 $C+7 ----------------------------------
$B0 $T5 $C+6 | .r$_link$_link$_x | .r$_link$_link$_link |
$B0 $T5 $C+7 ----------------------------------
$S
$A indent=0
$B3 $L1M
.own .variables
$A INDENT=2
$A TAB=5,10,15,20,25,35,42
$P1 Each variable declared in a block is allocated storage
when that block is entered, the storage being returned
(released) when the block is left. This means that
variables (and the values in them) are lost between
traverses of the block.
$P1 If, however, the prefix %own is applied to a
declaration the variables are allocated statically and so
retain their values when
the block is not being executed
(see Procedures). The scope of the identifier
is
unchanged.
$P %Own arrays must be one-dimensional and have
constant
bounds.
$B3 $L1M
.initialisation
$P1 %Own variables may be given initial values (effectively
before the program starts execution); if no initial value
is specified the content of an %own variable is undefined.
$A INDENT=4
$B1 %own %integer .a,b=4, .c=-1
$B0 ! the initial value in A is undefined
$B0 %own %real .r=1.234@-5
$B0 %own %string (7) .who="anon"
$A INDENT=2
$B1 In the case of %own %name and %own %array %name variables the
initial value (if present) represents the absolute
address of respectively the initial variable to be
pointed at or the
(possibly hypothetical) 'zeroth
element' of an array.
$A INDENT=4
%own %integer %name .clock==72
$B0 %own %integer %array %name .save .area == 16
$B1 $T2 This is %highly %machine %dependent.
$A INDENT=2
$P1 If an own array is to be initialised, every element in
the array must be given a value. In order to simplify
this $T3 $C+1 each initial value may be followed by a repetition
count in parentheses, and a star (*) may be used to
represent the number of remaining elements in the array.
For convenience a repetition count of zero is permitted
and means that the initialising constant is to be
ignored. For example the following declarations are all
equivalent:
$A INDENT=4
$B1 %own %integer %array .a(2:5) = 7,7,7,7
$B %own %integer %array .a(2:5) = 7(4)
$B $B0 %own %integer %array .a(2:5) = 7(*)
$B $A INDENT=2
$B $P1 The list of constants may extend over several physical
$B lines without the need for a continuation mark if each
$B line ends with a comma; a line break is also allowed
$B after the equals sign.
$B $A INDENT=4
$B $B1 %own %string (3) %array .month(1:12) =
$B0 ."jan", ."feb", ."mar",
$B0 ."apr", ."may", ."jun",
$B0 ."jul", ."aug", ."sep",
$B0 ."oct", ."nov", ."dec"
$A INDENT=2
$B1 Any number of null statements may be placed between the
lines of constants.
$B1 $T3 $C+1 %own %integer %array .value(1:50) =; $T9 $C+3 ! .tag .values
$B0 $T4 1, $T5 2, $C+2 3, $C+2 0(7),
$b0 $t3!$t4 ------type 1------
$B0 $T3 $C+4 11, $C+2 22, 33, $C+2 4(3), 55(4),
$b0 $t3!$t4----------type 2----------
$A INDENT=4
$A TAB=5,10,15,18
111, 222, $C+2 3, -1(5),
$b0 $t3!$t4------types 3&4------
$B0 -2(*); $T9 $C+3 ! .all .the .rest
$B3 $L1M
.constant .identifiers
$A INDENT=2
$A TAB=5,10,15,20
$P1 The prefix %constant may replace %own to indicate that
the
initial value can never change. A %constant %integer
may be
used wherever an integer constant is required.
$A INDENT=4; just=0
$B1 %constant %integer .max = 17
$B0 %constant %real .pi = 3.14159
$B0 %constant %string (7) .version = "vsn:1.6"
%constant %integer %array .val(1:max) = 1,6,9,-1(*)
$A INDENT=2;  just=1
$B1 %Constant pointer variables may be declared but are highly
machine and system dependent.
$A INDENT=4
$B1 %constant %integer %name .status .reg == 160
$b1 %constant %integer %array %name .word == 0
$A INDENT=2
$B1 Note: %constant pointers are effectively simple variables
of
the appropriate type located at the specified
(absolute)
address.
$B3 The keyword %constant may be abbreviated to %const.
$B3 $L1M
.assignment
$P1 There are three forms of assignment:
$B1 $T1 1. $T2 {variable} "=" {expression}
$A INDENT=3
$B1 X = Y
$B0 .a(p) = .a(p)+1
$B0 Y = .bit<<12
$B0 .person = .initials.surname
$A INDENT=2
$B1 The expression is evaluated and the resulting value is
stored in the given variable. The expression may be of
type %integer, %real, or %string, and the variable must be
of the corresponding type; in the case of a real variable
an integer expression will have its result converted to
%real before being assigned.
$B1 Valid types of assignment are:
$B0 {integer variable} "=" {integer expression}
$B0 {real variable} $C+4"=" {real expression}
$B0 {real variable} $C+4"=" {integer expression}
$B0 {string variable} $C+2"=" {string expression}
$B1 $T1 2. $T2 {pointer variable} "==" {variable}
$B1 The pointer variable is dynamically made equivalent to
the given variable; the types of both sides of the
assignment must be identical - this includes the formats
of records.
$B0 The assignment may be thought of as the assignment of the
%address of the variable to the pointer.
$B0 Once equivalenced the pointer variable may be used as an
alternative to the variable.
$A INDENT=3
$B1 %integer %name N
$B0 %integer J
$B0 %integer %array .a(1:6)
$b0 %integer %name %array .pt(2:12)
$B0 J = 1
$B0 N == .a(j); $T6 $C+2 ! N .is .now .equivalent .to .a(1)
$B0 J = 2; $T6 $C+2 ! N .has .not .changed
$B0 N = 0; $T6 $C+2 ! .same .as .a(1) = 0
$b0 .pt(J) == .a(4)
$B1 $T2 .n.b$. Extreme care should be taken if variables declared
in different blocks are to be equivalenced as it is
possible to leave a pointer referencing a variable
which no longer exists (see Block Structure).
$N
$t1 3. $t2 {variable} "<-" {expression}
$b1 This is similar to 1. above except that the value of the
expression will be truncated if necessary (see Data Prescision Specification).
$A indent=3
$b
$T2E.g.$t3_s_t_r_i_n_g(4) S
$b1 S = "12345";$c+1  ! fails CAPACITY EXCEEDED at run-time.
$b1 S <- "12345"; ! will assign "1234" to S.
$b2 $L1M
.record .assignment
$A INDENT=2
$P1 Two extra assignments exist for records.
$B1 1. $T3 {record variable} "=" {record variable}
$A INDENT=3
$B1 The right-hand record is copied bit by bit into the
left-hand record. The formats of the two records
must be the same.
$B1 $T2 2. $T3 {record variable} "=0"
$B1 Each bit of the record is set to zero.
$B3 $L1M
.string .resolution
$A INDENT=1
$P1 The contents of a string variable may be searched for a
sub-string and decomposed accordingly.
$B0 The format of a resolution is:
$B1 {string var}"->"{string var}".("{string exp}")."{string var}
$B1 where either the second string variable, the third, or both
may be omitted (any dangling full stops also being omitted).
$A INDENT=2
$B1 S $T3 $C+4 -> .t.(",").u
$B0 .title(j) -> .("sir").rest
$B0 .who $T3 $C+4 -> .who.(letters."b.sc.")
$B0 S $T3 $C+4 -> .("hello".t)
$A INDENT=1
$P1 The string expression is evaluated and the first variable
is searched from left to right to find that string of
characters. The string to the left of the sub-string so found
is assigned to the second variable and the string to the right
is assigned to the third.
$B0 The resolution is deemed to have failed if the required
sub-string is not found or either of the second or third
string variables has been omitted and would have been assigned
a non-null string.
$V15
$B1 For example, the following resolutions all fail if the string
variable S contains the string ."abcdefg"
$B1 $C+10 S -> .t.("h").u
$B0 $C+10 S -> .("cd").u
$B0 $C+10 S -> .t.("ef")
$B0 $C+10 S -> .("abcdef")
$B1 and the following all succeed:
$B1 $C+10 S -> .t.("cde").u
$B0 $C+10 S -> .("abc").u
$B0 $C+10 S -> .t.("g")
$B0 $C+10 S -> .("abcdefg")
$V15
$P1 A resolution may occur in two contexts:
$B1 $T2 1. $T3 as an instruction, in which case failure of the
$A INDENT=3
resolution causes an event to be signalled (see
Events)
$B1 S -> .a.(wanted).b; $T6 S = .a.b
$B1 $T2 2. $T3 as a simple condition (see Conditions), in which
case failure of the resolution deems the simple
condition false and success deems it true; in the
latter case the
resolution is performed and the
necessary
assignments are made.
$B1 %if .who -> .("sir .").who %then .knight = 1
$S
$B0 $T5 $C+4 .conditions
$A INDENT=1
$B1 Conditional statements are specified using the phrase
{condition}, which is defined as:
$B1 {condition} ::= {simple cond} ("_a_n_d" {simple cond})*,
$B0 $T4 $C+1 {simple cond} ("_o_r" {simple cond})*
$B1 where {simple cond} has seven forms:-
$B1 1. $T2 {expression}{comp}{expression}
$B1 $T2 {comp} ::= "=" $T5 $C+8 - .is .equal .to
$A INDENT=5
$A TAB=5,10,15,20,21
"#", "\=" $C+3 - .is .not .equal .to
$B0 "<" $C+9 - .is .less .than
$B0 "<=" $C+8 - .is .less .than .or .equal .to
$B0 ">" $C+9 - .is .greater .than
$B0 ">=" $C+8 - .is .greater .than .or .equal .to
$A INDENT=2
$A TAB=5,10,15,20,25
The given expressions are evaluated and compared. The
simple condition is true or false depending on the
validity of the relation specified by the comparator.
Both expressions must yield values of the same type.
$B1 $T1 2. $T2 {expression} {comp} {expression} {comp} {expression}
$B1 This form of simple condition may be thought of as a
contraction of the form:
$B0 $T3 ({x1}{comp1}{x2} "_a_n_d" {x2}{comp2}{x3})
$B0 except that the middle expression (x2) is only evaluated
once. Note that the third expression is not evaluated
unless the condition specified by the first two
expressions is true.
$B0 Such a simple condition is frequently used to check for a
range of values, E.g.
$B1 $T5 0 <= .value <= 100
$B1 $T1 3. $T2 {reference to variable} "==" {reference to variable}
$B1 The two variables,
which must be of the same type,
are
compared for equivalence, that is
their %addresses are
compared.
$B0 Note that the address of a pointer variable is the
address of the variable to which it is equivalent.
$B1 $T1 4. $T2 {predicate call} $T6 - see Procedures
$B1 The given predicate is called and the simple condition is
true or false depending on whether the exit from the
predicate was performed using %true or %false respectively.
$B1 $T1 5. $T2 {resolution} $T6 - see String Resolution
$B1 The resolution is attempted. If it fails the simple
condition is deemed false, otherwise the resolution is
performed and the condition is deemed true.
$B0 Note that this form of simple condition has a
side-effect if the simple condition is true!
$B1 $T1 6. $T2 "(" {condition} ")"
$B1 This form of simple condition is provided to enable the
use of both %and and %or in a condition. The connectives
%and and %or may not appear in the same condition unless
separated by levels of parentheses. E.g.
$B1 $T4 .a=0 %or .(b=1 %and .c=2) %or .d=3
$B1 $T1 7. $T2 "_n_o_t" {simple condition}
$B1 The given simple condition is evaluated and its truth is
negated. E.g. the following simple conditions are
exactly
equivalent:
$B1 $T5 $C+6 A # 0
$B0 $T5 $C+4 %not A = 0
$B3 $L1MU
Evaluation of conditions
$A INDENT=1
$P2 The evaluation of a condition proceeds from left to right,
simple condition by simple condition, terminating as soon as
the inevitable result of the condition is known.
$B1 For example, considering the condition:
$B1 $T5 A # 0 %and .b//a # C
$B1 If the variable A has the value zero the condition will be
deemed false without attempting the evaluation of ."b//a # .c".
$n $L1M
.conditional .statements
$P1 The general form of conditional statements is:
$A indent=2
$B1 %if {condition} %start
$P0 ! .statements .to .be .executed .if
$P0 ! {condition} .is .true
$B0 %finish %else %start
$P0 ! .statements .to .be .executed .if
$P0 ! {condition} .is .false
$B0 %finish
$A indent=1
$P1 If _s_t_a_r_t-%finish brackets enclose one instruction only, that
part may be reduced to:
$B1    $T2 %if {condition} %then {instruction} %else %start
$B1 or $T2 %finish %else {instruction}
$B1 $t1 e.g. $T2 %if {condition} %then {instruction} %else %start
$A INDENT=3
$A TAB=5,10,13
! .statements .to .be .executed .if
$B0 ! {condition} .is .false
$A INDENT=2
$A TAB=5,10,15
%finish
$B1 $t1 or $t2 %if {condition} %start$C+16 (*)
$P0 ! .statements .to .be .executed .if
$P0 ! {condition} .is .true
$B0 %finish %else {instruction}
$B1 $T1 or in the simplest case:
$B1 %if {condition} %then {instruction} %else {instruction}
$A INDENT=1
$P1 If nothing is to be done specifically when the condition is
false the %else part may be omitted.
$B1 $T2 %if {condition} %start
$A INDENT=3
$A TAB=5,10,13
! .statements .to .be .executed .if
$B0 ! {condition} .is .true
$B0 $T2 %finish
$B1 $T1 or
$B1 $T2 %if {condition} %then {instruction}
$B3 $T1 _s_t_a_r_t-%finish groups may be nested to any depth.
$n $T5 .alternative .forms
$B1 $T1 1. $T2 A conditional statement of the form:
$B1 $C+2 %if {condition} %then {instruction}
$A INDENT=2
$A TAB=5,10,15
$B1 has the same effect if rewritten in the more natural
form:
$A INDENT=3
$B1 {instruction} %if {condition}
$B1 X = .error %if X > .limit
$B1 $T1 2. $T2 The keyword %if may always be replaced by %unless with the
$A INDENT=2
effect of negating the whole of the condition. For
example, the following two statements are equivalent:
$B1 $T3 $C+4 %if X = 0 %then Y = $C+2 1 %else Y = -1
$B0 $T3 %unless X = 0 %then Y = -1 %else Y = $T9 1
$B2 $T1 3. $T2 The statement "%finish %else _s_t_a_r_t" may be abbreviated to
"_e_l_s_e".
$B1 $T3 %if X = 0 %start
$A INDENT=3
$P0 .flag = 1; $C+2 .count = 0
$B0 %else
$P0 .flag = 2; $C+2 .count = -1
$B0 %finish
$B2 $T1 4. $T2 The %else part of any conditional group may be replaced by
$A INDENT=2
another complete conditional group, treated as though it were
a single instruction (see * above).
$B0 For example:-
$B1 $T3 %if A = 0 %start
$A INDENT=3
$P0 P = 1; $T5 $C+1 Q = 2
$B0 %finish %else %start
$P0 %if A < 0 %start
$A INDENT=4
$A TAB=5,10,15,18
$P0 P = -1; $C+2 Q = 2
$B0 %finish %else %start
$P0 P = 1; $C+2 Q = -2
$B0 %finish
$B0 $T3 %finish
$B1 $T2 may be rewritten:-
$B1 $T3 %if A = 0 %start
$B0 P = 1; $C+2 Q = 2
$B0 $T3 %finish %else %if A < 0 %start
$B0 P = -1; $C+1 Q = 2
$B0 $T3 %finish %else %start
$B0 P = 1; $C+2 Q = -2
$B0 $T3 %finish
$S
$B3 $L1M
.repetition .(loops .or .cycles)
$B2 $T1 a. $T2 Indefinite Repetition
$A INDENT=2
$A TAB=5,10,15,20
$P1 A group of statements may be repeated indefinitely by
enclosing them between the statements "_c_y_c_l_e" and
"_r_e_p_e_a_t".
$B1 $T3 %cycle
$A INDENT=4
$A TAB=5,10,15,18
.get .data
$B0 .process .data
$B0 $T3 %repeat
$A INDENT=2
$A TAB=5,10,15,20
$B1 Subsequently the group of statements between %cycle and
%repeat will be referred to as the %cycle %body.
$B2 $T1 b. $T2 Conditional Repetition
$B1 1. $T3 %while {condition} %cycle
$A INDENT=3
$B1 Before each execution of the cycle body the
specified condition is tested. If the condition is
true the cycle body is executed; otherwise control
is passed to the statement following the matching
%repeat.
$B1 $T2 2. $T3 %for {control} "=" {init} "," {inc} "," {final} %cycle
$B1 where
$A just=0
$B0 {control}::= {integer variable} $c+2- .control .variable
$B0 {init} $C+3 ::= {integer expression} - .initial .value
$B0 {inc} $C+4 ::= {integer expression} - .increment
{final} $C+2 ::= {integer expression} - .final .value
$A just=1
$P1 On each entry to the cycle the address of the
control variable and the values of the three
expressions are evaluated and saved; thus the
cycle
body cannot change them. The control variable
is
assigned the value "{init}-{inc}".
$B0 The value in the control variable is compared with
the value of {final}. If they are equal control is
passed to the statement following the matching
%repeat, otherwise the value {inc} is added to the
control variable and the cycle body is executed.
$B1 On normal exit from the cycle the control variable will
contain the value {final}, however see %exit.
$B1 Note: The  effects of altering the control variable
within the cycle body are undefined.
$N
$A INDENT=2
$B2 3. $T3 The final form of conditional cycle is:
$B1 $C+5 %cycle
$P0 $C+5 ! .cycle .body
$B0 $C+5 %repeat %until {condition}
$B1 $C+5 In this construction the cycle body is always executed
at
least once. The loop may also be qualified by
a %while or %for as defined above.
$b1 $t2 E.g. $t3 %while {condition} %cycle
$b0 $t3 $c+3 ! .cycle .body
$b0 $t3 %repeat %until {condition}
$B2 $T1 _c_y_c_l_e-%repeat groups may be nested to any depth.
$B3 $L1M
.simple .forms .of .loop
$A INDENT=1
$P1 If the cycle body comprises only one instruction the loop
may be rewritten in the form:-
$A INDENT=2
$B1 {instruction} {loop clause}
$B1 $t1 i.e.$t2 {instruction} "_w_h_i_l_e" {condition}
$B0 {instruction} "_f_o_r" {control}"="{init}","{inc}","{final}
{instruction} "_u_n_t_i_l" {condition}
$B2 $T1 For example
$B1 .a(j) = 0 %for J = 1, 1, 20
$B0 .readsymbol(s) %until S = .nl
$B0 .skipsymbol %while .nextsymbol = ' '
$N
$L1M
.cycle .control .instructions
$A INDENT=1
$P1 Two instructions are provided to control the execution of a
cycle from within the cycle body.
$B1 $T2 1. $T3 %exit $T5 - causes the cycle to be terminated and
$A INDENT=5
control to be passed to the statement
following the matching repeat.
In the case of a %for loop the control variable will retain the
value it contained immediately prior to the %exit.
$B1 $T2 2. $T3 %continue $T5 - causes control to be passed to the %repeat
(and any associated %until condition)
of the current loop.
$b4 $L1M
.joining .instructions .using .'and'
$A INDENT=1
$P1 Several simple instructions may be joined together using
%and to form a more complex instruction. The execution of such
an instruction is achieved by executing each of the component
simple instructions in the order given. This construction is
used to simplify small _s_t_a_r_t-%finish or
_c_y_c_l_e-%repeat groups.
$A indent=3
$B1 E.g.$t4 %if X = 0 %start
$b0     $t4 $c+3 P = 1; $C+1 Q = 1
$B0     $t4 %finish
$B1 $T1 may be rewritten:
$B1 $C+3 P = 1 %and Q = 1 %if X = 0
$B1 or %if X = 0 %then P = 1 %and Q = 1
$S
$B $L1M
.block .structure
$A INDENT=1
$P1 An .imp program is constructed using one or more %blocks.
Blocks may be nested one within another. The depth to which
this nesting may be performed is implementation dependent.
$B $L1M
.begin .blocks
$P0 The simplest type of block is enclosed between the
statements "_b_e_g_i_n" and "_e_n_d" and is referred to as a %begin
%block. If the block is the outermost block of a complete
program it must be terminated by the statement
$B0 "%end %of _p_r_o_g_r_a_m".
$B1 For example, a complete program might take the form:
$B1 %begin
$P0 %integer .count, .limit
$P0 ..
$P0 %begin
$A INDENT=3
$A TAB=5,10,11
%real .sum
$B0 ..
$A INDENT=2
$A TAB=5,8,15
%end
$B0 ..
$A INDENT=1
$A TAB=5,10
%end %of %program
$B A %begin block is entered by executing the %begin and is left by
passing through the %end to the following statement. The main uses
of begin blocks are to declare arrays with bounds calculated
at run-time, and to enable the re-use of space taken up by
large arrays which are only needed for part of the program.
$B1 $T2 %begin
$A INDENT=3
$A TAB=5,10,13
%integer .upper
$B0 .upper = ....; $C+3 ! $C+2 .calculate .value .for .upper .bound
$B0 %begin
$p0 %integer %array .cases(1:upper)
$p0 ..
$B0 %end
$A INDENT=2
$A TAB=5,10,15
%end %of %program
$B1 %begin
$P0 ..
$P0 %begin
$A INDENT=4
$A TAB=5,10,15,16
%integer %array .temp(1:10000)
$B0 ..
$A INDENT=3
$A TAB=5,10,13,20
%end
$B0 %begin
$P0 %real %array .work .area(1:11000)
$P0 ..
$B0 %end
$B0 $T2 %end %of %program
$N $L1M
.local .and .global .variables
$A INDENT=1
$A TAB=5,10,15
$P1 An identifier is described as being %local to a block if it
was declared at the head of that block. Any identifiers which
are in scope but which were not declared in the block in
question are referred to as being %global to the block.
$B0 Clearly identifiers may be local to only one block but may be
global to many.
$B1 $T2 %begin; $T5 $C+4 ! .start .of .outer .block
$A INDENT=3
$A TAB=5,10,13
%integer .x; $T5 $C+4 ! X .is .%local .to .this .block
$B0 %begin; $T5 $C+4 ! .start .of .inner .block
$P0 %integer .y; $C+3 ! Y .is .local .to .this .block
$P0 X = 0; $T5 $C+4 ! X .is .%global .to .this .block
$B0 %end; $T5 $C+4 ! .end .of .inner .block
$B0 $T2 %end; $T5 $C+4 ! .end .of .outer .block
$A INDENT=1
$A TAB=5,10,15
$B1 Identifiers may always be redeclared in any block to which
they are %global - the local incarnation taking precedence over
the global one.
$B1 $T2 %begin
$A INDENT=3
$A TAB=5,10,13
%integer X
$B0 %begin
$P0 %integer X
$P0 X = 0; $T5 $C+4 ! .uses .the X .of .the .previous .line
$B0 %end
$B0 $T2 %end
$A INDENT=1
$A TAB=5,10,15
$B1 An attempt to redeclare a local variable will be faulted by
the compiler.
$P1 On entry to a block, space from the stack is allocated to
any local variables, and when the block is left the space is
returned to the stack (but see Own Variables).
$N
$B3 $L1M
.procedures
$P1 A procedure is a block which has an associated identifier;
a complete procedure block may be considered as the
declaration of the procedure identifier.
$B0 Unlike begin blocks, procedures are not entered simply by
reaching their first statement (this results in control being
transferred to the statement following the matching _e_n_d).
Instead procedures are activated when they are %called by
giving the procedure identifier in a context determined by the
type of
procedure.
$B0 The effect of a call is to suspend the current flow of control
and to pass control to the procedure. When the procedure
terminates, the previous flow of control is resumed.
$B1 There are four forms of procedure, the exact form required
being specified by the first statement of the block.
$B1 The phrase {param def}? stands for the optional parameter
definition and will be described later (see Parameters).
$B1 1. $T2 %routine {id}{param def}?
$A INDENT=2
$B1 When a routine is called its statements are executed
until either the %end is reached or the instruction %return
is executed. This causes the routine to terminate and
the previous flow of control to be resumed.
$B
$b0 $c+6 %integer X, Y
$b0 $c+6 %routine CONVERT
$b0 $c+9 %if X < Y %start
$b0 $c+12 X = X+Y
$b0 $c+9 %finish %else %start
$b0 $c+12 X = X-Y
$b0 $c+9 %finish
$b0 $c+6 %end
$b0 $c+6 ...
$b0 $c+6 ...
$b0 $c+6 CONVERT
$b0 $c+6 ...
$b0 $c+6 CONVERT %unless X = 0
$N $T1 2. $T2 {type} %function {id}{param def}?
$A INDENT=2
$B1 A %function is a procedure which calculates a %value of the
specified type (%integer, %real, %string, or %record) and may
be used wherever an %operand of the specified type is
required.
$B0 When a function is called its statements are executed
until an instruction of the form:
$B1 $C+5 %result "=" {expression}
$B1 is executed. This causes the function to terminate,
returning the value of the expression.
$A INDENT=3
$B1 %integer .x,y,z
$B0 %integer %function .sum
$P0 %result = .x+y
$B0 %end
$B0 Z = .sum; $T5 $C+7 ! $T6 .same .effect .as ."z=x+y"
$B2 The keyword %function may be abbreviated to %fn.
$B2 $T1 3. $T2 {type} %map {id}{param def}?
$A INDENT=2
$B1 A %map is a procedure which calculates a %reference to a
variable of the specified type (%integer, %real, %string, or
_r_e_c_o_r_d), and may be used wherever a %variable of the
specified type is required.
$B0 When a map is called its statements are executed until
an
instruction of the form:
$B1 $C+5 %result "==" {variable reference}
$B1 is executed. This causes the map to terminate, returning
a reference to (i.e. the address of) the given variable.
$B1 E.g. %integer .x,y
$B0 $T3 %integer %map .min
$A INDENT=3
$P0 %if X < Y %then %result == X %else %result == Y
$B0 %end
$B1 .min = 0
$B0 ! .the .above .statement .is .exactly .equivalent .to:
$B0 ! %if X < Y %then X = 0 %else Y = 0
$V21
$B1 $T1 4. $T2 %predicate {id}{param def}?
$A INDENT=2
$B1 A %predicate is a procedure which tests the validity of an
hypothesis and then returns, being either %true or %false.
Predicates may be used wherever a simple condition is
required.
$B0 When a predicate is called its statements are executed
until either of the instructions "_t_r_u_e" or "_f_a_l_s_e" is
executed. This causes the predicate to terminate
accordingly.
$B1 Note that a predicate does not return any value.
$B1 E.g. %integer N
$B0 $T3 %predicate .single .digit
$A INDENT=4
$A TAB=5,10,15,18
%true %if 0 <= N <= 9
$B0 %false
$A INDENT=3
$A TAB=5,10,15,20
%end
$B1 N = .n//10 %unless .single .digit
$A INDENT=1
$V10
$B1 %Notes
$B1 a. $T2 A %routine may terminate by reaching %end; all
$A INDENT=2
other types of procedure must not be able to reach their
%end, otherwise the compiler will report a fault.
$A INDENT=1
$B1 b. $T2 Procedures may be nested within any form of block.
$B1 c. $T2 Procedures may be %recursive, that is, they may call
$B0 $T2 themselves.
$N
$B3 $L1M
.parameters
$P1 In the previous discussion about procedures the phrase
{param def}? was used. This stands for an optional parameter list
definition.
$B1 {param def} ::= "(" {dec list} ")"
$B1 where {dec list} is a list of declarations defining the .formal
.parameters. The declarations
may be of any data type except %array - arrays may only be
passed to a procedure as %array %name parameters.
$B1 E.g. %routine SWOP(%integer %name .p, .q)
$A INDENT=2
%integer %function MAX(%integer %array %name .a, %integer .f, .t)
$b0%predicate EQUIV(_r_e_c_o_r_d(FM)%name .left, .right)
$A INDENT=1
$P1 Parameters are identical to any local variables declared
inside the procedure, except that the parameters are
initialised each time the procedure is called.
$B0 When a procedure is called a list of .actual .parameters must be
supplied which must match the formal parameters exactly in
number, order, and type. Parameters are effectively assigned
using "==" for those passed by %name (E.g. %integer %name,
%real
%array %name) and using "=" for those passed by value (E.g.
_s_t_r_i_n_g(10), _i_n_t_e_g_e_r).
$B1 For example assuming the declarations:
$P1 %integer .l, .m, N
$P0 %real R
$P0 %integer %array .v(-7:7)
$P0 %record .(fm) .one, .two
$B1 valid calls on the procedures mentioned in the previous
example are:
$P1 .swop(l, .m)
$P0 .swop(v(l), .v(m))
$P0 N = .max(v, -1, 0)
$P0 M = .max(v, .l, 7)
$P0 N = M %if .equiv(one, .two)
$B1 .n.b. .imp %name type parameters are called by %reference and not
by %substitution (c.f. .algol 60).
$N $L1M
.procedure .parameters
$P1 In addition to being able to pass variables to procedures
it is possible to pass procedures as parameters. This is
achieved by using the procedure heading as the 'declaration'
of the formal parameter.
$B1 E.g. %routine TRY(%routine R(%integer .x))
$A INDENT=3
$A TAB=5,10,13
%integer J
$B0 .r(j) %for J = 1, 1, 10
$B0 $T2 %end
$A INDENT=1
$A TAB=5,10,15
$B
The routine .try may now be called with a single parameter
which must be the name of a routine which has one integer
parameter. In this context the formal parameter names used to
specify the parameters of a procedure parameter are otherwise
ignored.
$B1 Note: If the routine .try is itself to be passed as a parameter
the heading of the receiving routine would be something like:
$B1 $C+5 %routine CHECK(%routine P(%routine Q(%integer .r)))
$B1 and the call would be:
$B1 $C+5 .check(try)
$B3 $L1M
.general .type .parameter
$P1 In several situations it is useful to be able to pass to a
procedure
a
reference to %any type of variable. This is
done
by specifying an untyped %name parameter.
$B1 E.g. %routine WORK(%name .ref)
$B1 Such a parameter is intended for system-dependent interface
procedures and has severely limited uses. In particular it
may only be passed on to another procedure requiring an
untyped %name parameter.
$P1 An example of the use of such a parameter is in the
pre-declared .read routine which will accept an %integer, %real,
or %string parameter.
$B1 E.g. %integer X
$A INDENT=2
%real Y
$B0 %string (15) Z
$B0 .read(x); $T4 .read(y); $C+2 .read(z)
$S
$A INDENT=1
$B3
The following is a complete list of formal parameter
declarators:
$B3 %integer $T5 %real $T7 _s_t_r_i_n_g({max})
$B1 %integer %name $T5 %real %name $T7 _s_t_r_i_n_g({max})%name
$B  %integer %array %name
$T5 %real %array %name $T7 _s_t_r_i_n_g({max})%array %name
$B1 %integer %fn $T5 %real %fn $T7 _s_t_r_i_n_g({max})%fn
$B1 %integer %function $t5 %real %function
$t7 _s_t_r_i_n_g({max})%function
$B1 %integer %map $T5 %real %map $T7 _s_t_r_i_n_g({max})%map
$b1 %integer %name %array %name
$b1 %real %name %array %name
$b1 _s_t_r_i_n_g({max}) %name %array %name
$B3 _r_e_c_o_r_d({fm})
$B1 _r_e_c_o_r_d({fm})%name
$B1 _r_e_c_o_r_d({fm})%array %name
$b1 _r_e_c_o_r_d({fm}) %name %array %name
$B1 _r_e_c_o_r_d({fm})%fn
$b1 _r_e_c_o_r_d({fm})%function
$B1 _r_e_c_o_r_d({fm})%map
$B3 %routine
$B1 %predicate
$B1 %name
$N
$B3 $L1M
.procedure .specification
$P1 In several situations it is necessary to use a procedure
before it is possible (or desirable) to define it. For
example,
where two or more procedures call each other (mutual
recursion) or where a procedure is to be defined externally
(see External Linkage).
$B0 As all procedure identifiers must be declared before being
used a procedure specification statement is introduced.
$B0 This takes the form of the normal procedure heading with the
keyword %spec inserted before the procedure identifier.
$B1 E.g. %routine %spec MAX(%real .size)
$P1 This has no effect other than declaring the identifier to
be a procedure of the specified type which takes the given
parameters. Except in the case of %external procedure
specifications the procedure must be defined later on in the
same block (but not any blocks defined therein).
$B1 For example:
$A indent=3
$B1 %routine %spec B(%integer .x)
$B1 %routine A(%integer .y)
$P0 ..
$P0 .b(y-1)
$P0 ..
$B0 %end
$B1 %routine B(%integer .x)
$P0 ..
$P0 .a(x+3)
$P0 ..
$B0 %end
$A indent=1
$B Note that the %spec statement and the procedure heading
$B0 must correspond, that is,
the type and form of the statements must match, as must
the type, form, order and number of any parameters.
$s
$B3 $L1M
.control .transfer .instructions
$B2
$Lm
_L_A_B_E_L_S$__a_n_d$_%JUMPS
$B1 1. $T2 %Simple %Labels
$A INDENT=2
$P1 Any statement, excluding declarations, may be given
one
or more simple labels, where a simple label is of the
form: {id} ":"
$B1 Each label is written to the left of the statement.
$B1 .next: $T4 $C+4 P = .p+1 %if P < 0
$B0 .error1:error2:faults = .faults+1
$B1 Control may be passed to a labelled statement by
executing a jump instruction: "->" {id}
$A INDENT=3
$B2 -> .next
$B -> .error1 %if .divisor = 0
$B1 $T1 2. $T2 %Switch %Vectors
$A INDENT=2
$P1 A vector of labels may be declared in a similar manner
to an array, using the declarator %switch.
$B1 %switch .sw(4:9)
$B0 %switch .s1, .s2(1:10), .s3(11:20)
$B1 $T1 Note a. $T3 The vector must be one dimensional.
$B1 b. $T3 The bounds must be constants.
$B1 Once declared, switch labels may be used in the same way
as simple labels.
$B1 .sw(4): $T4 $C+3 .check .value(1)
$B0 .sw(6):sw(6): .error .flag = 1
$B0 .last: .sw(9): ! .all .finished
$B1 A star (*) may be used in the definition of a switch
label to locate any elements of the vector which would
otherwise
be undefined.
$N
$B1 %switch .let('a':'z')
$B0 ..
$B0 ..
$B0 .let('a'):let('e'):let('i'):let('o'):let('u'):
$B1 ! .deal .with .vowels
$B0 ..
$B0 ..
$B1 .let(*):! .all .the .rest .i.e$. .consonants
$B1 The specific label to which a jump will be made is
dependent on the value of an integer expression.
$A INDENT=3
$B1 .->sw(n) %if N > 0
$B0 .->sw(100+n)
$B0 .->sw(6)
$V15
$B1 $T1 Note 1. $T3 Not all of the declared switch labels need be
defined (in the previous examples .sw(5): and .sw(8):
are undefined) but an error will occur at run time
if an attempt is made to jump to a non-existent
switch label.
$B1 $T2 2. $T3 Simple labels are the only identifiers which may be
used before they are declared/defined.
$A INDENT=4
$B1 -> .missing %if .here = 0
$B0 ..
$B0 ..
$B0 $T3 .missing:
$B0
$B1 $T2 3. $T3 The scope of both types of label is limited to the
$A INDENT=3
block in which they are defined,
not including any blocks defined therein.
 That is labels
cannot be global to a block and therefore it is not
possible to jump into or out of a block.
$B1 $T2 4. $T3 The identifiers used for labels must not conflict
with other local identifiers.
$b1 $t2 5. $t3 The results of entering a %for loop with a jump
and not through the %for statement are undefined.
$n
$lcm
other control transfer instructions
$b2 $T1 %stop
$A INDENT=2
$P1 Execution of the instruction %stop causes control to be
returned to the program which initiated the execution of
the current program. This is also the effect of reaching
the statement %end %of %program.
$B0 Control is transferred by signalling event zero (see
Events).
$b2 $t1 %monitor
$p1
This instruction causes the run-time diagnostic package to be
invoked to produce diagnostic information.
$b0 If no diagnostic package is available this instruction
will be ignored (in some limited implementations the
production of diagnostics causes 
execution of the program to be terminated).
$A indent=1
$B1 For convenience all other control transfer instructions
are gathered here.
$B1 %return $T5 return from a routine.
$B1 _r_e_s_u_l_t={exp} $T5 return the result of a function
$B1 _r_e_s_u_l_t=={reference} $T5 return the result of a map.
$B1 %true $T5 return from a predicate.
$B1 %false $T5 return from a predicate.
$B1 %exit $T5 jump out of the current %cycle to the
$B0 $T5 statement following the matching %repeat.
$B1 %continue $T5 jump to the top of the current %cycle.
$B1 %signal %event $T5 see Events.
$S
$B1 $T5 $C+1 .external .linkage
$P1 A complete program may be divided into several separately
compiled modules which are linked together before
(or possibly while)
the program
is executed. This linkage is achieved by giving the %external
attribute to relevant indentifiers.
$B1 1. $T2 %external DATA OBJECTS
$A INDENT=2
$P1 An external variable is declared in the same way as an
%own variable with the keyword %own replaced by %external.
$A INDENT=3
$B1 %external %integer .choice=4, .wait = -5
$b %external %real %array .mean(-6:6)
$A INDENT=2
$B1 The identifiers are then available for use
by any program that references them. A
separately compiled module that requires to use any of
these variables must first declare them using an external
specification.
$A INDENT=3
$B1 %external %integer %spec .wait, .choice
$B %external %real %array %spec .mean(-6:6)
$B1 $T2 note 1. $T4 No initialization may be specified in an
$B0 $T4 external specification.
$b1 2. $t4 External arrays must be one-dimensional and
$b0 $t4 have constant bounds.
$B1 3. $T4 Even though all of the characters in the
$A INDENT=4
identifier of an external entity are
significant to the compiler, the system loader
software might impose constraints on the number
of significant characters. Refer to the
relevant appendix for system dependent
restrictions.
$B1 $T1 2. $T2 %external .%procedures
$A INDENT=2
$P1 A procedure may be made available to other modules by
prefixing the procedure heading with the keyword
%external.
$P1 %external %routine TRIAL(_s_t_r_i_n_g(63) .s)
$B1 Such procedures must be compiled in a file comprising
only external procedures (and possibly some non-external
procedures and %own or %external declarations). The whole
module is terminated by the statement %end %of %file.
$N
$B1 For example the following is a complete file of external
procedures:
$A indent=3
$B1 %integer %function SHIFT(%integer .sym)
$P0 %result = .s-32; $T7 ! $C+2 .lower - .upper .case
$B0 %end
$B %external %predicate LETTER(%integer .sym)
$P0 %true %if .'a' <= .sym <= .'z'
$P0 %true %if .'a' <= .shift(sym) <= .'z'
$P0 %false
$B0 %end
$B %external %predicate DIGIT(%integer .sym)
$P0 %true %if '0' <= .sym <= '9'
$P0 %false
$B0 %end
$B %external %predicate .alphanum(%integer .sym)
$P0 %true %if .letter(sym) %or .digit(sym)
$P0 %false
$B0 %end
$B1 %end %of %file
$A indent=2
$B1 Note a. $T4 The function .shift is local to the file - it
$B0 $T4 cannot be called from a different module.
$B1 $T3 b. $T4 The normal scope rules apply within the file,
$B0 $T4 so that .alphanum may call both .letter and
$b0 $t4 .digit.
$B1 $T3 c. $T4 External procedures may %not be nested within
$B0 $T4 any blocks.
$P2 If a module requires to use an externally defined
procedure it must first supply an %external .%procedure
%specification. For example:
$B1 $T3 %external %predicate %spec LETTER(%integer .s)
$B1 This is similar to a procedure specification but only
requires the specified procedure to have been defined by
the time the module is executed.
$b The prefix %external may be replaced by %system or
%dynamic, the exact significance of which may vary from
machine to machine.
$N
$B3 $L1M
.predefined .procedures
$A INDENT=1
$P1 Every separately compiled module, whether a
_b_e_g_i_n-%end %of
%program block or a file of external procedures is
compiled
within a conceptual "outermost block" in which are
declared a
number of standard procedures such as .read and .write.
This
means that these procedures are global to all parts
of a
program and so may be used without having to be declared.
Note that as these procedures are global they may be redefined
within the program.
$B0 Further, %own, %constant or %external identifiers may be declared in
this outermost block and will be global to the whole of the
file.
$A INDENT=2
$B1 %own %integer .calls = 0
$B1 %external %routine .do .something
$P0 .calls = .calls+1; $T6 $C+2 ! .record .times .entered
$P0 ..
$P0 ..
$B0 %end
$B %external %integer %function .entries
$P0 %result = .calls
$B0 %end
$B %end %of %file
$A INDENT=1
$B2 Note that the function .entries is used to make the value in
.calls available to other modules without their being able to
change that value, even by mistake.
$N
$P2 While the actual procedures which are predeclared may vary
from machine to machine, the following are standard and may be
assumed present:
$B1 .%input/output
$A INDENT=2
$B2 %routine READSYMBOL(%integer %name .s)
$B0 %routine .skipsymbol
$B0 %integer %function .nextsymbol
$B0 %routine READ(%name .n)
$B1 %routine PRINTSYMBOL(%integer .n)
$B0 %routine PRINTSTRING(_s_t_r_i_n_g(255) .s)
$B0 %routine WRITE(%integer .n, .places)
$B0 %routine .newline
$B0 %routine NEWLINES(%integer .n)
$B0 %routine .space
$B0 %routine SPACES(%integer .n)
$B1 %routine SELECTINPUT(%integer .stream)
$B0 %routine SELECTOUTPUT(%integer .stream)
$B2 $T1 .%string .%handling
$B2 _s_t_r_i_n_g(1) %function TOSTRING(%integer .symbol)
$B0 _s_t_r_i_n_g(255) %fn SUBSTRING(_s_t_r_i_n_g(255)%name .s, %integer .f,t)
%integer %function CHARNO(_s_t_r_i_n_g(255) .s, %integer .n)
$B0 %integer %function LENGTH(_s_t_r_i_n_g(255) .s)
$B2 $T1 .%event .%handling (see Events)
$B2 %integer %function .event
$B0 %integer %function .sub .event
$B0 %integer %function .event .info
$b2 $t1 .%store .%mapping
$b2 %integer %function ADDR(%name V)
$b0 %integer %map INTEGER(%integer ADDRESS)
$b0 %real %map REAL(%integer ADDRESS)
$b0 _s_t_r_i_n_g(255)%map STRING(%integer ADDRESS)
$A INDENT=1
$P1 Refer to the relevant system library manual for detailed
specifications of these and other standard procedures.
$S
$B0 $T5 $C+6 .events
$P1 During the execution of a program several (synchronous)
events may occur, such as resolution fails, array bound fault
etc. (see Faults). Normally such events will cause the
program to be terminated with an error report and possibly
diagnostic information. However events may be trapped and
used to control the further execution of the program.
$P1 The first non-declarative statements of any block may be of
the form:
$B1 $T3 %on %event {event list} %start
$B0 $T4 ! .on-body .statements
$B0 $T3 %finish
$B1 where {event list} is a list of integer constants representing
the events to be trapped.
$B1 On entry to the block the on body is skipped and execution
continues from the statements following the %finish. If an
event specified in the {event list} is signalled during the
execution of the statements between the %finish of the %on %event
group and the %end of the block, control will be passed to the
on-body ( and may well
pass through the %finish to the following statements).
 If the event is not trapped in the current block a
'return' is forced and the event is signalled in the new block
at the point from which the old block was entered. The
process is repeated until either the event is trapped or the
outermost block of the program is reached, in which case the
event is reported as a fault and the program terminates.
$B1 Three functions are available which give information about the
last event to have been signalled.
$B1 1. $T2 %integer %function .event
$B0 $T4 returns the class of the last event.
$B1 2. $T2 %integer %function .sub .event
$B0 $T4 returns the sub-class of the last event.
$B1 3. $T2 %integer %function .event .info
$A INDENT=4
returns any extra information passed with the
event.
$A INDENT=1
$B1 If no event has occurred each of these functions will return
the value zero.
$N
$B The classes of event and their sub-classes of them are:
$B1 .%event $C+3 .%sub-class $T5 .%meaning .%(+extra .%information)
$P1 0 $T5 $C+2 .%termination
$B0 $T3 $C+2 -1 $T5 $C+2 .abandon .program .without .diagnostics
$B0 $T3 $C+3 0 $T5 $C+2 .normal .termination (%stop)
$B0 $T3 $C+2 >0 $T5 $C+2 .user .generated .error
$P1 1 $T5 $C+2 .%arithmetic .%overflow
$A INDENT=4
$A TAB=5,10,15,18
1 $T5 $C+2 .integer .overflow
$B0 2 $T5 $C+2 .real .overflow
$B1 $T1 $C+3 2 $T5 $C+2 .%excess .%resource
$B0 1 $T5 $C+2 .not .enough .store
$B1 $T1 $C+3 3 $T5 $C+2 .%data .%error
$B0 1 $T5 $C+2 .symbol .in .data .(+symbol)
$B1 $T1 $C+3 4 $T5 $C+2 .%corrupt .%data
$B0 1 $T5 $C+2 .data .transmission .error
$B1 $T1 $C+3 5 $T5 $C+2 .%invalid .%arguments
$B0 1 $T5 $C+2 .illegal .cycle
$B0 2 $T5 $C+2 .illegal .exponent .(+exponent)
$B0 3 $T5 $C+2 .array .inside-out
$B1 $T1 $C+3 6 $T5 $C+2 .%out .%of .%range
$B0 1 $T5 $C+2 .capacity .exceeded
$B0 2 $T5 $C+2 .array .bound .fault .(+index)
$B0 3 $T5 $C+2 .no .switch .label .(+index)
$A INDENT=2
$A TAB=5,8,15,20
$B1 7 $T5 $C+2 .%resolution .%fails
$B0 8 $T5 $C+2 .%unassigned .%variable
$B0 9 $T5 $C+2 .%input .%ended
$A TAB=5,7
10 $T5 $C+2 .%library .%procedure .%error
$B0 11 - 15 $T5 $C+2 .%general .%purpose
$N
$A INDENT=1
$A TAB=5,10
$P1 At any time during the execution of a program an event may
be signalled by executing an instruction of the form:
$B1 %signal %event {n}{qual}?
$B1 where:
$P1 {n} $T3 $C+1 ::= an integer constant in the range 0 <= N <= 15
$P0 {qual} $c+2 ::= "," {sub event}{extra}?
$P0 {extra} $c+1 ::= "," {extra info}
$B1 and {sub event} and {extra info} are integer expressions.
$B1 The instruction causes event {n} to be signalled with
sub-event (default zero) and extra information (default zero).
$A INDENT=2
$B1 %signal %event 15; $T6 $C+3 ! $C+2 event 15,0,0
$B0 %signal %event 14,7 %if X < 0; ! $C+2 event 14,7,0
$B0 %signal %event .13,1,y %if .y#0; ! $C+2 event .13,1,y
$B1 $T1 Note 1. $T3 In both the %on and %signal statements the keyword
$B0 $T3 %event is optional and may be omitted.
$A indent=3
$B1 $T1 $C+5 2. $T3 An event signalled inside an incarnation 
of an on-body will never be
trapped into that incarnation. Instead the search for a
trap will start from the previous block.
$N
$A sectno=0; pageno=0
$L3M
.appendix 1

.compiler .error .messages
$A INDENT=1
$P1 Any errors detected by the compiler will generate messages
of the form:
$B1 $t3 * {message}
$B1 In most cases a marker (|) will be output to indicate the
position in the statement at which the error was detected.
$B1 .access $T4 - $T5 the statement cannot be reached. This is
$A INDENT=5
not treated as an error but may indicate
another fault.
$A INDENT=1
.atom $T4 - $T5 unknown atomic element.
$B0 .bounds $T4 - $T5 invalid bounds for an array or
$A INDENT=5
%switch declaration, or wrong number of
constants for an array initialization.
$B0 $T1 .context $T4 - $T5 formally correct statement given in the
wrong context.
$A INDENT=1
.copy $T4 - $T5 attempt to redefine a local identifier.
$B0 .form $T4 - $T5 incorrectly formed statement.
$B0 .index $T4 - $T5 switch label index out of bounds.
$B0 .match $T4 - $T5 procedure definition does not match a
$B0 $T5 previous %spec.
$B0 .name $T4 - $T5 undeclared identifier
$B0 .order $T4 - $T5 formally correct statement in wrong
$B0 $T5 sequence.
$b0 .size $t4 - $t5 constant out of range.
$B0 .too .complex $T4 - $T5 statement too long or complex to analyse.
$B0 .type $T4 - $T5 variable of wrong type.
$B0 .type .for {op} $T4 - $T5 operator {op} out of context.
$B0 .$%begin .missing - $T5 too many %end statements
$B0 .$%cycle .missing - $T5 a %repeat has been given with no matching
$B0 $T5 %cycle.
$B0 .$%end .missing $T4 - $T5 unterminated blocks remain at 
$b0 $t5 %end %of %program or %end %of %file.
$B0 .$%finish .missing- $T5 outstanding %start at %end or %repeat.
$B0 .$%repeat .missing- $T5 outstanding %cycle at %end or %finish.
$B0 .result .missing - $T5 a function, map, or predicate can reach
$B0 $T5 its %end.
$B0 .$%start .missing - $T5 a %finish has been given with no matching
$B0 $T5 %start.
$B1 "{id}" .missing - $T5 undefined procedure or label.
$N
$LM
.appendix 2
$B2 $T3 $C+4 .%sample .%program .%listing
$P1 1 $%begin
$P0 2 $T2 $C+3 $%begin
$P0 3 $T2 $C+3 $%realname Q
$P0 4 $T2 $C+3 $%integer .value, .x, X
$B0 * $T5 $C+7 ! .copy
$P0 5 $T2 $C+3 $%string(256) S
$B0 * $T4 $C+6 ! .size
$P0 6 $T2 $C+3 $%switch .sa(1:4), .sb(5:4)
$B0 *BOUNDS
$P0 7 $T2 $C+3 $%routinespec .check
$P0 8 $T2 $C+3 $%integerfunctionspec KEY($%integer .x)
$P0 9 $T2 $C+3 $%if X = 4 .$%stary
$B0 * $T5 $C+3 ! .atom
$B0 $C+2 10 $T3 $C+1 .value = .key
$B0 * $T5 $C-1 ! .form
$B0 $c+2 11 $T3 $C+1 .valur = 0
$B0 * $T3 $C+1 ! .name
$B0 $C+2 12 .sa(5):
$B0 * $T3 ! .index
$B0 $C+2 13 $T3 $C+1 $%exit
$B0 *$%CYCLE MISSING
$A INDENT=2
$A TAB=5,7
14 $T3 $C+1 $%stop
$B0 15 $T3 $C+1 X = 0
$B0 $T1 *ACCESS
$B0 16 $C+4 $%finish
$B0 $T1 *$%START MISSING
$B0 17 $C+4 $%on $%event 4 $%start
$B0 $T1 *ORDER
$B0 18 $T3 $C+1 $%integerfunction KEY($%real .x)
$B0 $T1 *MATCH
$B0 19 $T3 $C+1 $%end
$B0 $T1 *RESULT MISSING
$B0 20 $C+4 Q == .value
$B0 $T1 * $T3 $C+3 ! .type
$B0 21 $C+4 X = .q&7
$B0 $T1 *TYPE for "&"
$B0 22 $%endofprogram
$A INDENT=1
$A TAB=5,10
*$%END MISSING
$B0 *$%FINISH MISSING
$B0 *"CHECK" MISSING
$N
$l3m
.appendix 3

.data .precision .specification

$P
On some machines it is possible to offer a range of precisions
for variables of type %integer or %real.
The precision is specified by the use of one of the following
prefixes:$b
$t3 %short $t4 - smaller range than by default
$b $t3 %long $t4 - larger range than by default
$b $t3 %byte $t4 - large enough to hold a character (unsigned)
$b E.g. $t4 %byte %integer
$b $t4 %short %integer
$b $t4 %long %integer
$b $t4 %long %real
$b2
If the machine on which the program is to be run cannot
support the required precision the prefix will be ignored.
$a indent=4
$b2
$t2 E.g. On the IBM 360 (or ICL 4/75)
$b
$A indent=5
$b3 %byte %integer $t7 8-bits unsigned
$b0 %short %integer $t7 16-bits signed
$b0 %integer $t7 32-bits signed
$b1 %real $t7 32-bits
$b0 %long %real $t7 64-bits
$a indent=1
$p1 Note that checks may be applied to ensure that any quantity
assigned to a variable is within the correct range of values.
$b E.g. $t3 %byteinteger B
$b0 $t3 %integer X
$b0 $t3 X=16$_FFFF
$b0 $t3 B = X
$b will fail at run-time, as "16$_FFFF" is a POSITIVE %integer value
but a NEGATIVE %short %integer value.
$bThe assignment operator "<-" may be used to force truncation
if required (see Assignment).
$N
$B3 $L3M
.appendix 4

.imp .keywords
$A INDENT=0
$A TAB=11,22,33,44,55,62
$B1 %and $T1 %array
$B0 %begin $t1 %byte
$B0 %c $T1 %comment $T2 %const $t3 %constant $T4 %continue $T5 %cycle
$b0 %dynamic
$B0 %else $T1 %end $T2 %event $T3 %exit $T4 %external
$B0 %false $T1 %file $T2 %finish $T3 %fn $t4 %for $T5 %format $t6 %fn
$B0 %if $T1 %include $T2 %integer
$B0 %like $T1 %list $t2 %long
$B0 %map $t1 %monitor
$B0 %name $T1 %not
$B0 %on $T1 %of $T2 %or $T3 %own
$B0 %predicate $T1 %program
$B0 %real $T1 %record $T2 %repeat $T3 %result $T4 %return $T5 %routine
$B0 %short $t1 %signal $T2 %spec $T3 %start $T4 %stop $T5 %string
$b0 %switch $t1 %system
$B0 %then $T1 %true
$B0 %unless $T1 %until
$B0 %while
$N
$l0cm
appendix 5

comparison with .emas .imp
$B
$A indent=2
$t1 1. $t2 New Features
$b %for
$B %repeat %until
$B %continue
$b %predicate
$b %include
$b "==" in conditions
$b %integer %array (4) %name
$b %finish %else %if ....
$b %else
$b lower case input
$b %like
$b (*) in owns and switches
$b %constant
$b %function
$b %not
$b %record %function
$b %record %map
$b constant expressions
$N
$t1 2.$t2 Features not implemented
$b1 %print %text
$b %until ..... %cycle
$b %array %format
$b %reals %long
$b %reals %normal
$b implied multiplication
$b3
$t1 3. $t2 Changed  Features
$B 'AA' instead of M'AA'
$b 16$_1A2 instream of X'1A2'
$B procedure parameter specification
$b _r_e_c_o_r_d(F) R instead of %record R(F)
$b SUBSTRING instead of FROMSTRING
$b termination of comments
$B "\" or "\\" instead of "**"
$B %own initialisation
$b type checking for record operations
$B %external ... %spec instead of %extrinsic ...
$b events instead of fault trapping
$b / gives a %real result
$b string resolution
$E

$A capsh=0; undsh=0; und=0; cap=0
$A INVERT=0; MARK=2
$L0

                            INDEX

     1.  PROGRAM LAYOUT                  5. ASSIGNMENT
           keywords                            record assignment
           newline                             string resolution
           spaces                        6. CONDITIONS
           lower case letters                  evaluation of conditions
           quotes                              conditional statements
           identifiers                   7. REPETITION
           statements                          indefinite repetition
           termination                         conditional repetition
           null statements                     simple loops
               & comments                      cycle control instructions
           instructions                        joining instructions
           continuation                  8. BLOCK STRUCTURE
           listing control                     begin blocks
           include                             local and global variables
           constants                           procedures
                                               parameters
     2. EXPRESSIONS                            procedures as parameters
           arithmetic expressions              general type parameter
           bit-vector expressions        9. PROCEDURE SPECIFICATION
           string expressions           10. CONTROL TRANSFER
           precedence of operators             labels and jumps
     3. DECLARATIONS                           switch vectors
           simple variables                    stop
           pointer variables            11. EXTERNAL LINKAGE
           array pointer variables             external data
           arrays                              external procedures
           records                             predefined procedures
           record element selection
     4. OWN VARIABLES                   12. EVENTS
           declaration                         event numbers
           initialisation                      signal
           constant identifiers

$n
$l0

                         INDEX OF LANGUAGE ATOMS

   <nl>    1.2                                     predicate  8.5
   <space> 1.1              and       6.1, 7.3     program    8.1
   !       1.2, 2.2         array     3.2          real       3.1
   !!      2.2              begin     8.1          record     3.1, 3.2
   "       1.1, 1.5         byte      App 3        repeat     7.1
   #       6.1              c         1.3          result=    8.4
   %       1.1              comment   1.2          result==   8.4
   &       2.2              const     4.2          return     8.3
   '       1.1, 1.4, 1.5    constant  4.2          routine    8.3
   (                        continue  7.3          short      App 3
   )                        cycle     7.1          signal     12.3
   *       2.1, 4.1, 10.1   dynamic   11.2         spec       9.2, 11.2
   +       2.1              else      6.3, 6.4     start      6.3, 12.1
   ,                        end       8.1, 8.5     stop       10.3
   -       2.1              event     12.1, 12.3   string     3.1
   ->      5.2, 10.1, 10.2  exit      7.3          switch     10.1
   .       1.2, 2.2, 5.2    external  11.1         system     11.2
   /       2.1              false     8.5          then       6.3
   //      2.1              file      1.2, 11.1    true       8.5
   <0-9>   1.4              finish    6.3, 12.1    unless     6.4
   :       10.1, 3.2        fn        8.4          until      7.1
   ;       1.2              for       7.1, 10.2    while      7.1
   <       6.1              format    3.3
   <-      5.2              function  8.4
   <=      6.1              if        6.3
   <<      2.2              include   1.3
   =       4.1, 5.1, 6.1,
           7.1, 8.6         integer   3.1
   ==      4.1, 5.1, 6.1,
           8.6              like      3.3
   >       6.1              list      1.3
   >=      6.1              long      App 3
   >>      2.2              map       8.4
   @       1.5              monitor   10.3
   <A-Z>   1.1              name      3.1, 3.2, 8.7
   \       2.1, 2.2         not       3.1, 3.2, 8.7
   \=      6.1              on        12.1
   \\      2.1              of        1.2, 8.1, 11.1
   _       1.4, 3.4         or        6.1
   |       2.1              own       4.1, 11.1
$e



$$$$$$$$$$$$
&&&&&&&&&&&& 3B35C.RNO

.FLAG CAP.LC
.TITLE <IMP ON THE ^^DEC\\SYSTEM-10/20: ^USER ^GUIDE
.FIG 20
.NF.CENTRE
^&^^IMP ON THE ^^DEC\\SYSTEM-10/20\&
.S.C
^&^^USERS GUIDE\\\&
.S.C
SECOND EDITION: ^JUNE 1978
.S26
^KEITH ^M. ^FARVIS,
^EDINBURGH ^REGIONAL ^COMPUTING ^CENTRE.
.FLAGS ALL;.FLAG CAP
.number 1.LC
.PAG
.C
<CONTENTS.
.TS 11,15,18,50;.NF;.NAP;.S 2
				^PAGE
^FORWARD				2
^SECTION 1.	^USING THE COMPILER	3
		^USE OF <COMPIL	4
		^COMPILER MESSAGES	4
^SECTION 2.	^EXTERNAL PROCEDURES	5
		^THE SYSTEM LIBRARY	5
		<%INCLUDE FILES	6
^SECTION 3.	^INPUT AND OUTPUT	7
		^STREAM INPUT/OUTPUT	7
		^THE STREAM INPUT/OUTPUT PROCEDURES	7-9
			^SYMBOL I/O	8
			^STRING I/O	8
			^NUMBER I/O	8-9
		^STREAM INPUT/OUTPUT CONVENTIONS	9
		^EXAMPLE USING BASIC I/O PROCEDURES	9
		^STRINGS AS STREAMS	10
		^DIRECT ^ACCESS AND ^SEQUENTIAL ^FILES	11-12
		^FILE DEFINITION EFFICIENCY	13
		^EXAMPLE USING <FILESPEC RECORDS	14
		^INTERNAL HANDLING OF INPUT/OUTPUT	15
^SECTION 4.	^MEMORY ^MANAGEMENT	16-17
^SECTION 5.	^CALLING OTHER LANGUAGES	18-20
	^CALLING <FORTRAN FROM <IMP	18
	<COMMOM BLOCKS	18-19
	^CALLING <IMP FROM <FORTRAN	19
	^CALLING <MACRO FROM <IMP	20
	^CALLING <IMP FROM <MACRO	20
^SECTION 6.	^PROGRAM DEBUGGING	21-25
		<DDT	21
		</CROSS	22
		<ALIST	23-24
		<RECODE	23-25
.S 1;.C
<APPENDICES
.S
^A   ^USEFUL CONSTANTS AND VARIABLES	26
^B   ^DEFINITION OF THE FILE SPECIFICATION RECORD	27
^C   ^DEFINITION OF INTERNAL INPUT/OUTPUT RECORDS	28-30
^D   ^DATA STORAGE		31
    ^CODE CONVENTIONS	32-36
        ^REGISTER ALLOCATION	32
        ^PROCEDURE ENTRY AND EXITS	32-33
        ^PARAMETERS TO PROCEDURES	33-35
        ^PROCEDURE PARAMETERS	35
        ^USE OF MACHINE CODE	36
^E   <ASCII CHARACTER SET	37
^F   ^RELATED LIBRARY PROCEDURES	38-39
^G   ^SYSTEM LIBRARY PROCEDURES	40-43
^H   ^RUNTIME ERROR CODES	44-46
.S
^INDEX				47-48
.F.P 0.AP.PAGE
^&^FORWARD\&
 ^THIS MANUAL DESCRIBES THE OPERATION OF THE PORTABLE <IMP LANGUAGE
COMPILER ON THE ^D^E^CSYSTEM-10, TOGETHER WITH THE SYSTEM DEPENDENT
FEATURES OF THIS IMPLEMENTATION.
 ^IT IS NOT A DESCRIPTION OF THE <IMP LANGUAGE AND IT ASSUMES THE READER
HAS PREVIOUS KNOWLEDGE OF THE  <TOPS-10 OPERATING SYSTEM AS DESCRIBED
IN:-
.NAP.NF.S
   ^D^E^CSYSTEM-10 ^OPERATING ^SYSTEM ^COMMANDS MANUAL.
   (<AA-0916A-TB)
.S
COMPANION MANUALS ARE:-
.S
   ^THE <IMP-77 ^LANGUAGE: ^REFERENCE MANUAL.
   ^PETER ^S. ^ROBERTSON, ^DEPARTMENT OF ^COMPUTER ^SCIENCE,
   ^UNIVERSITY OF ^EDINBURGH.
.S
   <IMP ON THE <DEC-10: ^LIBRARY MANUAL.
   ^KEITH ^M. ^FARVIS, ^EDINBURGH ^REGIONAL ^COMPUTING ^CENTRE,
   ^EDINBURGH.
.S
OTHER MANUALS REFERRED TO IN THIS DOCUMENT ARE:-
.S
   ^D^E^CSYSTEM-10 ^MONITOR ^CALLS ^MANUAL. (<AA-0974C-TB)
   ^D^E^CSYSTEM-10 ^HARDWARE ^REFERENCE ^MANUAL. (<AA-1023A-TB)
.S.F
^IMPLEMENTATIONS OF THE PORTABLE <IMP COMPILER ARE ALSO AVAILABLE FOR:-
.NF.S
   <PDP-11
   <PDP-15
   ^INTERDATA 7/16 AND 7/32
   ^NOVA (IN A RESTRICTED FORM)
   <CIL-70
   ^NORD-10
   <ICL ^SYSTEM 4 (UNDER <EMAS OPERATING SYSTEM)
VERSIONS ARE PLANNED FOR
   ^ARGUS 700
   <VAX 11/780
.AP.F
 ^BECAUSE AN INTERMEDIATE CODE IS USED IN <IMP-77, IT ALLOWS THE
COMPILER'S FIRST PASS, WHICH DOES THE SYNTAX ANALYSIS, TO BE REPLACED BY
ONE FOR ANOTHER LANGUAGE. ^SUCH A PORTABLE VERSION OF ^ALGOL-60 IS
AVAILABLE AND A VERSION OF ^PASCAL IS BEING WRITTEN.
.PAGE
.SUBTITLE ^SECTION 1: ^&^USING THE COMPILER\&
.INDEX COMPILER
.INDEX SWITCHES
.INDEX </LIST
.INDEX </CROSS
.INDEX </NOCODE
.P 0;.AP;.F;.TS 6
.S
 ^THE <IMP COMPILER IS RUN BY THE MONITOR COMMAND
.NAP;.NF.S
	<_.R <IMP
TO WHICH THE COMPILER RESPONDS WITH THE PROMPT
.S
	*
THE COMMAND STRING IT REQUIRES IS
.S
	* _<REL-FILESPEC_> , _<LIST-FILESPEC_> = _<INPUT-FILESPEC_>
OR	* _<REL-FILESPEC_> = _<INPUT-FILESPEC_>
OR	* _<INPUT-FILESPEC_>
.S.F
 ^THE _<FILESPEC_>S REFER TO THE STANDARD <DEC-10
FILE SPECIFICATIONS NAMELY:-
.S;.NF
^DEVICE: FILENAME . EXTENSION [DIRECTORY LIST]
.AP;.F
 ^THE DIRECTORY LIST SPECIFICATION CAN INCLUDE SUB-FILE-DIRECTORIES.
^THE FOLLOWING SWITCHES TO THE COMPILER MAY ALSO BE INCLUDED AFTER ANY
OF THE FILE SPECIFICATIONS:-
.NAP.S.NF
	</CROSS  - INCLUDE A CROSS REFERENCED LISTING
	          (IMPLIES A </LIST)
	</LIST   - INCLUDE A LISTING FILE
	</NOCODE - SYNTAX CHECK ONLY
	</NOLIST - DO NOT INCLUDE A LISTING FILE
.S
^THUS 
	.<R <IMP
	* <FRED/CROSS/NOLIST/NOCODE
.S.F
WILL PRODUCE A LISTING FILE CALLED <FRED.LST CONTAINING ONLY THE CROSS
REFERENCE TABLES AND WILL ONLY DO SYNTAX CHECKING WITHOUT
GENERATING ANY CODE.
.F.AP
 ^THE DEFAULTS APPLIED TO INCOMPLETE FILE SPECIFICATIONS ARE:-
.NAP.NF
      INPUT-FILESPEC - <DSK: FILENAME . <IMP [USER]
      REL-FILESPEC   - <DSK: FILENAME . <REL [USER]
      LIST-FILESPEC  - <DSK: FILENAME . <LST [USER]
.AP;.F
 ^A <.REL FILE IS ALWAYS PRODUCED UNLESS SUPPRESSED BY THE </NOCODE SWITCH AND
A LISTING FILE IS ONLY PRODUCED IF ASKED FOR BY THE </LIST OR </CROSS
SWITCHES OR IF A LISTING FILE SPECIFICATION IS GIVEN.
.PG
.INDEX <COMPIL
.INDEX <COMPILE
.INDEX <LOAD
.INDEX <DEBUG
.INDEX <EXECUTE
.INDEX COMPILATION
.INDEX CODE
.INDEX GLA
.INDEX DIAGS
    ^&^USE OF <COMPIL\&
 ^THE COMPILER IS NORMALLY RUN BY USING THE <COMPIL CLASS OF COMMANDS, NAMELY:-
.NF;.S;.NAP
	<_.COMPILE . . .
	<_.LOAD . . .
	<_.EXECUTE . . .
	<_.DEBUG . . .
.AP;.F
 ^THE EXTENSION .<IMP IS RECOGNISED BY <COMPIL TO IMPLY THE <IMP 
COMPILER AND THE APPROPRIATE COMMAND STRING IS GENERATED AND SENT
TO THE COMPILER. ^FOR A FULL DESCRIPTION OF ^^<COMPIL\\'S FACILITIES INCLUDING
THE PASSING OF SWITCHES TO THE COMPILER SEE THE <DEC-10 <COMMANDS <MANUAL.
.S 2;.AP;.F
    ^&^COMPILER MESSAGES\&
 ^THE COMPILER RUNS IN 3 PASSES, THE FIRST DOING THE SYNTAX ANALYSIS AND
THE SECOND AND THIRD PRODUCING THE CODE.
 ^DURING THE FIRST PASS, SYNTAX ERROR MESSAGES ARE OUTPUT TO THE TELETYPE
AND THE LISTING FILE, IF ONE IS TO BE PRODUCED. ^AT THE END OF THE
FIRST PASS EITHER THE MESSAGE
.NF;.NAP;.S;.TS 6
"^PROGRAM CONTAINS    N FAULTS"
.S;.F;.AP
IS OUTPUT AND THE COMPILATION TERMINATES, OR ELSE
.NF;.NAP;.S
"   N ^STATEMENTS COMPILED"
.S;.F;.AP
IS OUTPUT AND COMPILATION CONTINUES INTO THE SECOND AND THIRD PASSES.
^ON COMPLETION, THE COMPILER OUTPUTS A MESSAGE GIVING THE
SIZES OF THE OBJECT FILE COMPONENTS. E.G.
.NAP;.NF;.S
^CODE 78 + ^GLA 23 + ^DIAGS 0 = 101 ^WORDS
.AP.F.S
WHERE '^CODE' IS THE AMOUNT OF CODE PRODUCED, '^GLA' IS THE GENERAL LINKAGE AREA
AND 'OWN' VARIABLES, '^DIAGS' THE DIAGNOSTIC INFORMATION AND
THEN THEIR SUM.
.PAGE;.AP.F
.SUBTITLE ^SECTION 2: ^&^EXTERNAL PROCEDURES\&
.INDEX LIBRARY
.INDEX SYSTEM LIBRARY
.INDEX IMPLICIT PROCEDURES
.INDEX EXTERNAL PROCEDURES
.INDEX SYSTEM PROCEDURES
.INDEX PROCEDURES
^&^THE ^SYSTEM ^LIBRARY\&
.S
 ^MOST <IMP PROGRAMS REQUIRE TO USE PROCEDURES TO DO INPUT/OUTPUT OR
PERFORM MATHEMATICAL FUNCTIONS. ^A SET OF SUCH PROCEDURES IS COLLECTED
TOGETHER IN THE SYSTEM LIBRARY. ^THIS LIBRARY IS AUTOMATICALLY SEARCHED
WHENEVER AN <IMP PROGRAM IS LOADED IN ORDER TO LINK IN ANY ROUTINES
WHICH THE PROGRAM MAY HAVE CALLED.
^THE LIBRARY CONTAINS THREE CLASSES OF PROCEDURE; IMPLICIT, EXTERNAL
AND SYSTEM PROCEDURES.
.LM 5
 1) ^THE IMPLICIT CLASS ARE THOSE WHICH DO NOT REQUIRE TO BE DECLARED
BEFORE BEING CALLED AND COMPRISE ALL THE COMMONLY USED PROCEDURES LIKE
<READSYMBOL, <WRITE AND <FRAC <PT. ^IT ALSO INCLUDES PRIMITIVE PROCEDURES
SUCH AS <ADDR AND <REM.
 2) ^THE EXTERNAL CLASS DO REQUIRE DECLARATIONS BEFORE BEING USED AND
COMPRISE THE LESS FREQUENTLY USED ROUTINES LIKE <RESET <INPUT AND <PROMPT.
 3) ^THE SYSTEM CLASS ARE SIMILAR TO THE EXTERNAL CLASS BUT COMPRISE PROCEDURES
THAT ARE EITHER VERY SYSTEM DEPENDENT OR REQUIRE SOME DETAILED KNOWLEDGE
OF THE <DEC-10 MONITOR, FOR EXAMPLE <DDT AND <GETTAB.
^IN THE DECLARATION OF SYSTEM ROUTINES, THE WORD %<SYSTEM IS USED WHERE
%<EXTERNAL IS USED IN THE EXTERNAL CLASS.
.NAP.NF.B
E.G.    <%EXTERNALROUTINESPEC <PROMPT(%STRING(255) <STR)
        <%SYSTEMROUTINESPEC <DDT(%NAME <X)
.AP.F.S
WOULD BE THE DECLARATIONS REQUIRED FOR THE ROUTINES <PROMPT AND <DDT.
.LM 0
.PAGE;.AP.F
.INDEX <%INCLUDE FILES
.INDEX EXTERNAL PROCEDURES
.INDEX SYSTEM PROCEDURES
.INDEX <IMP:
.INDEX <FORTRAN
^&<%INCLUDE ^FILES\&
.S
 ^IN THIS IMPLEMENTATION THERE ARE NO RESTRICTIONS ON WHAT STATEMENTS
MAY BE PUT IN %<INCLUDE FILES. ^HOWEVER A COMMON USE FOR THEM IS TO CONTAIN
THE DECLARATIONS OF COMMONLY USED EXTERNAL OR SYSTEM PROCEDURES, OR TO
CONTAIN GLOBAL DATA DECLARATIONS TO BE USED BY A NUMBER OF PROGRAM MODULES.
 ^TO HELP THE USER WHO REQUIRES TO USE A SET OF RELATED PROCEDURES
OF THE EXTERNAL OR SYSTEM TYPE, A NUMBER OF %<INCLUDE FILES HAVE BEEN
ASSEMBLED WHICH CONTAIN THE DECLARATIONS FOR THOSE PROCEDURES. ^THE USER
SIMPLY USES AN %<INCLUDE STATEMENT FOR THAT FILE BEFORE THEY
CALL THE PROCEDURES. ^IT SHOULD BE NOTED THAT PROCEDURES WHICH ARE DECLARED
BUT NOT USED ARE NOT LOADED UNLESS THEY WERE COMPILED IN THE SAME
FILE AS ONE WHICH NEEDS TO BE LOADED.
 ^THERE ARE ALSO A NUMBER OF INCLUDE FILES PROVIDED WHICH REFER TO
PROCEDURES WHICH ARE NOT IN THE SYSTEM LIBRARY BUT WHICH REQUIRE OTHER FILES TO BE
LOADED, BUT ALL THE  %<INCLUDE FILES HAVE THE NECESSARY DOCUMENTATION IN THEM.
 ^FOR A FULL LIST OF THE FACILITIES OFFERED LOOK AT THE INCLUDE FILES
ON THE <IMP: AREA ON DISK.
.S.NF
E.G.     %<INCLUDE "<IMP:DASQ.INC"
.F
WILL INCLUDE THE DECLARATIONS FOR ALL THE PROCEDURES CONCERNED WITH
^DIRECT ^ACCESS AND ^SEQUENTIAL ^FILES.
 ^THE FOLLOWING ARE SOME OF THE AVAILABLE FILES:-
.NAP.NF.S
	<DASQ.INC   - ^DIRECT ^ACCESS AND ^SEQUENTIAL FILES ROUTINES
	<TIME.INC   - ^DATE AND ^TIME PROCEDURES
	<FORTRA.INC - ^CALLING <FORTRAN  ROUTINES AND FUNCTIONS
	<IOLIB.INC  - ^INPUT/^OUTPUT INTERNAL RECORD DEFINITIONS
.PAGE;.AP;.F
.SUBTITLE ^SECTION 3: ^&^INPUT AND OUTPUT\&
.INDEX INPUT/OUTPUT
.INDEX STREAMS
.INDEX SWITCHES
.INDEX FILE SPECIFICATIONS
^&^STREAM INPUT/OUTPUT\&
 ^THE NORMAL MODE OF INPUT/OUTPUT IS VIA CHARACTER OR BINARY STREAMS.
^THERE ARE SIXTEEN STREAMS FOR INPUT AND SIXTEEN INDEPENDENT STREAMS FOR OUTPUT, NUMBERED
0 TO 15, HOWEVER A MAXIMUM OF 15 STREAMS OR <DA/SQ CHANNELS (EXCLUDING
STREAM 0) MAY BE OPEN AT ANY ONE TIME. ^BEFORE ONE CAN DO EITHER INPUT
OR OUTPUT A STREAM HAS TO BE
ASSOCIATED WITH A FILE AND THEN SELECTED TO BE THE CURRENT INPUT OR
OUTPUT STREAM; ALL SUBSEQUENT INPUT OR OUTPUT IS DIRECTED TO OR FROM
THAT STREAM UNTIL ANOTHER ONE IS SELECTED.
 ^WHEN ALL THE DESIRED INPUT OR OUTPUT HAS BEEN DONE, THE STREAM MAY BE
CLOSED, AN ACTION WHICH IS TAKEN AUTOMATICALLY FOR ALL OPEN STREAMS WHEN A PROGRAM
COMPLETES EXECUTION NORMALLY (I.E. WHEN A %<STOP OR %<END %<OF %<PROGRAM
STATEMENT IS EXECUTED).
 ^WHEN A PROGRAM BEGINS EXECUTION BOTH INPUT AND OUTPUT STREAM 0
ARE AUTOMATICALLY ASSOCIATED WITH THE USERS CONSOLE AND SELECTED AS THE
CURRENT STREAMS. ^THE REST OF THE STREAMS ARE ASSOCIATED WITH THE 'NUL:'
DEVICE, I.E. ANY INPUT RESULTS IN AN 'END-OF-FILE' CONDITION (%<SIGNAL %<EVENT 9)
AND ANY OUTPUT IS THROWN AWAY. ^STREAM 0 CANNOT BE REDEFINED AND WHEN
ANY OTHER STREAM IS CLOSED IT DEFAULTS BACK TO BEING ASSOCIATED WITH
THE 'NUL:' DEVICE.
.S
^&^THE STREAM INPUT/OUTPUT PROCEDURES\&
.S
^BELOW ARE THE BASIC PROCEDURES FOR INPUT AND OUTPUT, ALL OF WHICH
ARE IMPLICITLY DEFINED.
.NAP.S.NF
   ^^%ROUTINE DEFINE INPUT (%INTEGER STREAM %STRING(255) FILE)
   %ROUTINE DEFINE OUTPUT(%INTEGER STREAM %STRING(255) FILE)\\
.AP.F
^THESE ROUTINES ASSOCIATE FILES WITH STREAMS. ^THE FIRST PARAMETER IS A STREAM NUMBER
IN THE RANGE 1-15, ^THE SECOND IS A STRING WHICH CONTAINS A
<DEC-10 STYLE FILE SPECIFICATION ALLOWING FOR FULL SUB-FILE-DIRECTORY
AND SWITCH SPECIFICATIONS.
^CHARACTER STREAMS ARE THE DEFAULT, BINARY STREAMS ARE DEFINED USING THE
</MODE:_#10 SWITCH IN THE FILE SPECIFICATION.
(^SEE ^APPENDIX ^B FOR A LIST OF PERMITTED SWITCHES.)
.NAP;.NF.TS 6,15
E.G.	<DEFINE <INPUT(1,"<FRED.BIN[110,110,DATA]/MODE:_#10")
	<DEFINE <OUTPUT(12,"<JOE.LST")
.AP;.F
 ^WHEN A DEVICE NAME IS OMITTED <'DSK' IS ASSUMED AND WHEN A DIRECTORY
IS OMITTED THE USERS OWN AREA IS ASSUMED.
.NAP.S.NF
   ^^%ROUTINE SELECT INPUT (%INTEGER STREAM)
   %ROUTINE SELECT OUTPUT(%INTEGER STREAM)\\
.AP.F
^THESE ARE USED TO SELECT THE CURRENT INPUT AND OUTPUT STREAMS TO BE USED FROM THEN ON.
.NAP.NF.S.TP 4
   ^^%ROUTINE CLOSE INPUT
   %ROUTINE CLOSE OUTPUT\\
.F
^THESE ROUTINES CLOSE THE CURRENTLY SELECTED INPUT OR OUTPUT STREAMS
WHICH BECOME ATTACHED AGAIN TO THE <NUL STREAM.
.S
.INDEX SYMBOL I/O
.INDEX STRING I/O
.INDEX NUMBER I/O
.INDEX STREAMS
^&SYMBOL <I/O\&
.S
^THE FOUR PROCEDURES BELOW OPERATE ON <ASCII OR BINARY SYMBOLS, DEPENDING ON THE
MODE OF THE CURRENTLY SELECTED STREAM.
.NF.S
   ^^%ROUTINE READ SYMBOL(%INTEGER SYM)\\
.F
INPUTS THE NEXT SYMBOL ON THE CURRENT INPUT STREAM.
.NF.S
   ^^%INTEGERFN NEXT SYMBOL\\
.F
RETURNS THE NEXT SYMBOL BUT DOES NOT ADVANCE THE BUFFER POINTER, SO
THAT A SUBSEQUENT CALL OF ANY OF THE INPUT ROUTINES WILL READ IT AGAIN.
.NF.S
   ^^%ROUTINE SKIP SYMBOL\\
.F
THROWS AWAY THE NEXT SYMBOL ON THE CURRENT INPUT STREAM.
.NF.S
   ^^%ROUTINE PRINT SYMBOL(%INTEGER SYM)\\
.F
OUTPUTS THE GIVEN SYMBOL ON THE CURRENT OUTPUT STREAM.
.NF.S
^&^STRING <I/O\&
.S
   ^^%ROUTINE READ ITEM(%STRING(1)%NAME STR)\\
.F
READS THE NEXT SYMBOL FROM THE CURRENT INPUT STREAM AND RETURNS IT AS
A STRING OF LENGTH ONE IN THE GIVEN VARIABLE.
.NF.S
   ^^%STRING(1)%FN NEXT ITEM\\
.F
RETURNS THE NEXT SYMBOL FROM THE CURRENT INPUT STREAM, AS A STRING OF
LENGTH ONE, BUT DOES NOT ADVANCE THE BUFFER POINTER, SO THAT A SUBSEQUENT
CALL OF ANY INPUT ROUTINE WILL READ IT AGAIN.
.NF.S
   ^^%ROUTINE READ STRING(%STRING%NAME STR)\\
.F
READS A SERIES OF <ASCII CHARACTERS ENCLOSED WITHIN DOUBLE QUOTES, INTO
AN <IMP STRING VARIABLE.
.NF.S
   ^^%ROUTINE READ TEXT(%STRING%NAME STR, %INTEGER TERMIN)\\
.F
READS A SERIES OF <ASCII CHARACTERS UP TILL A GIVEN TERMINATOR, INTO
AN <IMP STRING VARIABLE.
.NF.S
   ^^%ROUTINE PRINT STRING(%STRING(255) STR)\\
.F
WRITES OUT THE GIVEN <IMP STRING.
.NF.S
^&^NUMBER <I/O\&
.S
   ^^%ROUTINE READ(%NAME X)\\
.F
READS A NUMBER INTO THE GIVEN VARIABLE, THE TYPE
OF NUMBER READ DEPENDS ON THE TYPE OF VARIABLE GIVEN (%<INTEGER OR %<REAL - OR ALSO %<STRING).
.NF.S
   ^^%ROUTINE WRITE(%INTEGER N,PLACES)\\
.F
OUTPUTS AN INTEGER IN A GIVEN NUMBER OF PRINTING POSITIONS.
.NF.S.TP 3
   ^^%ROUTINE PRINT(%REAL R, %INTEGER B,A)\\
.F
OUTPUTS A REAL NUMBER WITH A GIVEN NUMBER OF PRINTING
POSITIONS BEFORE AND AFTER THE DECIMAL POINT.
.NF.S
   ^^%ROUTINE PRINT FL(%REAL R, %INTEGER A)\\
.F
OUTPUTS A REAL NUMBER IN FLOATING POINT FORMAT WITH THE GIVEN NUMBER OF
DIGITS AFTER THE DECIMAL POINT.
.s 2
.F.S.AP
.INDEX STREAMS
.INDEX STREAM CONVENTIONS
^&^STREAM INPUT/OUTPUT CONVENTIONS\&
 ^IN NORMAL <ASCII MODE THE END OF A LINE IS TERMINATED BY A NEWLINE
CHARACTER, WHICH IS DEFINED AS <ASCII <LF, CARRIAGE
RETURN CHARACTERS BEING IGNORED ON INPUT AND INSERTED ON OUTPUT.
^NULL CHARACTERS ARE ALSO IGNORED. ^IF ONE WISHES TO SEE EVERY
CHARACTER AND NOT HAVE THEM EDITED IN THIS WAY, THE STREAMS SHOULD
BE SET UP WITH THE SWITCHES "</MODE:_#10/BYTE:7" IN THE
FILE SPECIFICATION.
.S
^&^EXAMPLE PROGRAM USING BASIC <I/O PROCEDURES\&
.S
^BELOW IS A SAMPLE PROGRAM USING THE BASIC INPUT/OUTPUT ROUTINES DESCRIBED ABOVE.
.S 2
.LIT
%BEGIN;   !A PROGRAM TO COPY A FILE ONTO THE TERMINAL
          !AND ONTO A LINE-PRINTER

   %CONSTINTEGER IN=1, OUT=1;     !STREAM NUMBERS
   %INTEGER SYM;          !AN INTEGER TO READ CHARACTERS INTO

   %ON %EVENT 9 %START;   !TRAP WHEN END-OF-FILE ENCOUNTERED ON INPUT
      CLOSE INPUT;        !CLOSE THE INPUT FILE
      SELECT OUTPUT(OUT); !SELECT THE LINE-PRINTER
      CLOSE OUTPUT;       !AND CLOSE IT
      %STOP;              !AND FINISH PROGRAM EXECUTION
   %FINISH

   DEFINE INPUT(IN,"MESSAG.TXT"); !OPEN INPUT FILE
   DEFINE OUTPUT(OUT,"LPT:");     !OPEN LINE-PRINTER
   SELECT INPUT(IN);              !SET TO READ FROM FILE

   %CYCLE;                 !MAIN PROGRAM LOOP
      READ SYMBOL(SYM);    !READ A CHARACTER FROM THE FILE
      PRINT SYMBOL(SYM);   !OUTPUT CHARACTER TO TERMINAL
      SELECT OUTPUT(OUT);  !SELECT LINE-PRINTER
      PRINT SYMBOL(SYM);   !AND OUTPUT CHARACTER TO THAT AS WELL
      SELECT OUTPUT(0);    !RE-SELECT TERMINAL
   %REPEAT;                !CONTINUE UNTIL END-OF-FILE EVENT 
%ENDOFPROGRAM
.END LITERAL
.PAGE.AP.F
.INDEX ^STRINGS
.INDEX ^STREAMS
.INDEX ^STRINGS AS STREAMS
^&^STRINGS AS STREAMS\&
 ^IT IS POSSIBLE TO HAVE STRING VARIABLES AS THE SOURCE AND DESTINATION
OF THE ABOVE STREAM INPUT AND OUTPUT. ^IT IS NECESSARY
TO DEFINE STREAMS TO BE ASSOCIATED WITH STRING VARIABLES BY USING
THE TWO EXTERNAL ROUTINES
.NF.NAP.S
<%EXTERNALROUTINE <SDEF <INPUT(%<<INTEGER <N, %<STRINGNAME <STRING)
<%EXTERNALROUTINE <SDEF <OUTPUT(%<<INTEGER <N, %<STRINGNAME <STRING)
.F.AP.S
THE ROUTINES <SELECT <INPUT/OUTPUT, <CLOSE <INPUT/OUTPUT AND <RESET
<INPUT/OUTPUT  OPERATE AS FOR NORMAL INPUT/OUTPUT.
^NOTE THAT AN ^END-OF-FILE CONDITION IS SIGNALLED WHEN THE END OF A STRING
IS REACHED ON INPUT, AND AN OUTPUT STREAM NEEDS
TO BE CLOSED BEFORE THE FINAL STRING LENGTH IS WRITTEN.
.PAGE.AP.F
.INDEX DIRECT ^ACCESS FILES
.INDEX ^SEQUENTIAL ^FILES
.INDEX <DA FILES
.INDEX <SQ FILES
^&^DIRECT ^ACCESS AND ^SEQUENTIAL ^FILES\&
.S
 ^IT IS OFTEN USEFUL TO READ OR WRITE A LARGE SECTION OF DATA
OR RECORDS DIRECTLY TO OR FROM A FILE, WITHOUT HAVING TO TREAT
EACH ITEM INDIVIDUALLY. ^THIS IS ACCOMPLISHED BY ^DIRECT ^ACCESS (<DA) AND
^SEQUENTIAL (<SQ) FILES. ^THE DIFFERENCE BETWEEN THEM IS
THAT WITH ^DIRECT ^ACCESS ONE CAN READ FROM AND WRITE TO ANY DESIRED
BLOCK IN A FILE, WHEREAS WITH ^SEQUENTIAL ^FILES ONE CAN ONLY
READ OR WRITE (BUT NOT BOTH) IN A SEQUENTIAL ORDER AS THE NAME INDICATES.
 ^THE <DA/SQ SYSTEM USES DATA CHANNELS IN THE RANGE 1 TO 15 WHICH WORK
INDEPENDENTLY OF THE NORMAL INPUT/OUTPUT STREAMS DESCRIBED ABOVE.
^HOWEVER ONE CAN ONLY HAVE A COMBINED MAXIMUM OF 15 STREAMS AND
CHANNELS OPEN SIMULTANEOUSLY.
 ^CHANNELS, LIKE STREAMS, MUST BE ASSOCIATED WITH FILES, BEFORE BEING USED, BUT
THERE IS NO CONCEPT OF A CURRENT CHANNEL AND THE CHANNEL NUMBER
MUST BE GIVEN WHENEVER READING, WRITING OR CLOSING A <DA/SQ CHANNEL.
 <DA CHANNELS ALLOW BOTH READS AND WRITES TO THEM, BUT WITH <SQ
FILES, THE FIRST READ OR WRITE SETS THE TYPE OF ACCESS FROM THEN ON AND
THE FILE CAN ONLY BE READ FROM OR WRITTEN TO UNTIL THE FILE IS RE-OPENED.
 ^DATA IS STORED IN THE FILES DIFFERENTLY FOR <DA AND <SQ FILES.
^IN <DA FILES DATA IS WRITTEN STARTING AT THE BEGINNING OF A BLOCK
AND ANY SPACE LEFT AT THE END OF THAT OR SUBSEQENT BLOCKS ON A
<WRITE <DA STATEMENT IS ZERO FILLED.
^IN <SQ FILES, DATA IS READ AND WRITTEN SEQUENTIALLY, WITHOUT
INTERVENING PADDING, AND WITHOUT DATA OR RECORD SEPARATORS.
 ^IF FOR EXAMPLE ONE WERE TO WRITE 3 RECORDS OF LENGTH 150 WORDS
EACH, USING A <DA FILE AND AN <SQ FILE, THE RESULTING FILES (BLOCK SIZE 128)
WOULD LOOK AS FOLLOWS:-
.S.LIT
        ____________________________________________________
DA file | RECORD  1 |       | RECORD 2 |        | RECORD 3 |
        ____________________________________________________

disk    | BLOCK 1 | BLOCK 2 | BLOCK 3 | BLOCK 4 | BLOCK 5 |

        ____________________________________________________
SQ file | RECORD 1 | RECORD 2 | RECORD 3 |
        ____________________________________________________
.END LITERAL
.PAGE
 ^THE ROUTINES WHICH OPERATE ON <DA/SQ FILES ARE DESCRIBED BRIEFLY BELOW
.INDEX ^DIRECT ^ACCESS FILES
.INDEX <DA FILES
.INDEX <SQ FILES
.INDEX FILE SPECIFICATIONS
.NF.S
   ^^%ROUTINE OPEN DA(%INTEGER CHAN, %STRING(255) FILE)
   %ROUTINE OPEN SQ(%INTEGER CHAN, %STRING(255) FILE)\\
.S.F
^THE ROUTINES <OPEN <DA AND <OPEN <SQ ARE USED TO ASSOCIATE FILES TO CHANNEL NUMBERS.
^THE CHANNEL NUMBER MUST BE IN THE RANGE 1-15 AND THE STRING CAN
CONTAIN A FULL ^^DEC\\SYSTEM-10 FILE SPECIFICATION.
.NAP.NF.S
   ^^%ROUTINE READ DA(%INTEGER CHAN, %INTEGERNAME BLOCK,
                    %NAME FIRST, LAST)
   %ROUTINE WRITE DA(%INTEGER CHAN, %INTEGERNAME BLOCK,
                    %NAME FIRST, LAST)
   %ROUTINE READ SQ(%INTEGER CHAN, %NAME FIRST, LAST)
   %ROUTINE WRITE SQ(%INTEGER CHAN, %NAME FIRST, LAST)\\
.AP.F.S
^THE READING AND WRITING ROUTINES HAVE TO SPECIFY THE CHANNEL
NUMBER AND THE <DA ROUTINES MUST GIVE THE BLOCK NUMBER FROM WHICH
READING OR WRITING IS TO TAKE PLACE. ^THE NUMBER OF
THE LAST BLOCK READ FROM OR WRITTEN TO IS RETURNED IN THE SAME VARIABLE.
^THE TWO %<NAME TYPE PARAMETERS DEFINE THE FIRST AND LAST CONSECUTIVE ITEMS TO BE
TRANSFERED AND THESE MAY BE OF ANY TYPE, INCLUDING RECORDS.
 ^THERE EXISTS A LIMITATION, BECAUSE OF THE
FACT THAT DATA IS BEING TRANSFERRED DIRECTLY TO THE
FILE, WITHOUT BUFFERING, THAT THE DATA MUST EXIST IN THE LOW SEGMENT I.E.
EITHER IN %<OWN OR %<EXTERNAL VARIABLES, OR THE DATA STACK MUST BE
DECLARED BY THE USER (SEE ^MEMORY ^MANAGEMENT SECTION).
.NAP.NF.S
   ^^%ROUTINE CLOSE DA(%INTEGER CHAN)
   %ROUTINE CLOSE SQ(%INTEGER CHAN)\\
.AP.F.S
^THESE ROUTINES CLOSE THE FILES ASSOCIATED WITH THE GIVEN CHANNEL NUMBER
AND RELEASE THE CHANNEL FOR RE-USE.
.PAG
.INDEX FILE SPECIFICATIONS
.INDEX <FILESPEC RECORDS
.F.LC.S 2
    ^&^FILE DEFINITION EFFICIENCY\&
 ^WHILST THE ABOVE METHOD OF SPECIFYING FILES USING STRINGS GIVES THE
MOST GENERAL FILE HANDLING FACILITY,
USERS MAY REQUIRE MORE FLEXIBILITY IN MANIPULATION OF THE FILE DEFINITIONS
OR MAY WISH TO SAVE SOME OF THE OVERHEAD NECCESARILY INVOLVED IN HAVING
TO PARSE THE GIVEN STRING INTO ITS COMPONENT PARTS.
 ^TO THIS END THERE IS AN IMPLICIT <%RECORD <%FORMAT CALLED <FILESPEC.
^ALL FILE SPECIFICATION STRINGS ARE INTERNALLY PARSED INTO THESE RECORDS WHICH ARE
DESCRIBED IN ^APPENDIX ^B
TOGETHER WITH A LIST OF THE SWITCHES RECOGNISED BY THE RUNTIME SYSTEM.
^THERE ARE AN EQUIVALENT SET OF ROUTINES FOR DEFINING STREAMS AND CHANNELS
WHICH TAKE THESE RECORDS AS THE SECOND PARAMETER, NAMELY 
<XDEFINE <INPUT, <XDEFINE <OUTPUT, <XOPEN <DA AND <OPEN <SQ.
 ^THERE IS ALSO AN EXTERNAL ROUTINE CALLED <READFS WHICH WILL READ IN A <FILESPEC
FORMAT RECORD DIRECTLY FROM THE CURRENT INPUT STREAM. (^SEE THE EXAMPLE BELOW.)
 ^ALL THESE ROUTINES ARE DESCRIBED IN DETAIL IN THE <IMP <DEC-10 ^LIBRARY ^MANUAL.
.NF.S.NAP
.PAGE
^&^EXAMPLE PROGRAM USING <FILESPEC RECORDS.\&
.INDEX <FILESPEC RECORDS
.UC.S 2
.LIT
%BEGIN;   !A PROGRAM TO COPY A FILE ONTO THE USERS CONSOLE
%EXTERNALROUTINESPEC PROMPT(%STRING(255) S)
%EXTERNALROUTINESPEC READFS(%RECORD(FILESPEC)%NAME FS)

%RECORD(FILESPEC) INPUT FS
%INTEGER SYM
%CONSTINTEGER IN=1;            !INPUT STREAM NUMBER

   %ON %EVENT 9 %START;        !ON END-OF-FILE
      %STOP
   %FINISH

   PROMPT("INPUT FILE:- ");    !PROMPT USER
   READFS(INPUT FS);           !READ THE FILE NAME
   !NOW ADD AN EXTENSION IF ONE IS NOT GIVEN
   INPUT FS_EXT="IMP" %IF INPUT FS_EXT=""
   XDEFINE INPUT(IN,INPUT FS); !OPEN THE FILE
   SELECT INPUT(IN);           !SELECT IT

   !NOW COPY THE FILE UNTIL AN END-OF-FILE TRAP
   %CYCLE
      READSYMBOL(SYM)
      PRINTSYMBOL(SYM)
   %REPEAT

%ENDOFPROGRAM
.END LITERAL.LC
.S 2
.PAG.F.AP
.INDEX INTERNAL I/O RECORDS
.INDEX <SCB
.INDEX STREAMS
.INDEX I/O STREAMS
.INDEX <DA/SQ CHANNELS
^&^INTERNAL HANDLING OF INPUT/OUTPUT\&
 ^ALL STREAMS AND <DA/SQ CHANNELS USE INTERNALLY DEFINED RECORDS
CALLED ^STREAM ^CONTROL ^BLOCKS (^^SCB\\S) WHICH CONTAIN ALL THE NECESSARY
INFORMATION FOR THE RUNTIME SYSTEM FOR THAT STREAM OR CHANNEL.
^NORMALLY THESE ^^SCB\\S ARE COMPLETELY HIDDEN FROM THE USER,
BUT THEY MAY BE USED TO OBTAIN INFORMATION ABOUT FILES, OR TO ALTER
THE WAY THAT I/O IS HANDLED.
 ^STREAMS HAVE TWO RECORD ARRAYS ASSOCIATED WITH THEM, ONE ARRAY FOR
INPUT AND THE OTHER FOR OUTPUT. ^THESE CONTAIN POINTERS
TO THE ^^SCB\\S OR ^^TTSCB\\S (SPECIAL CASE FOR ^TELETYPES) FOR EACH STREAM.
.NAP.NF.S
   ^^%EXTERNALRECORD(SCBNAME)%ARRAY INVEC(-1:15)
   %EXTERNALRECORD(SCBNAME)%ARRAY OUTVEC(-1:15)\\
.F
WHERE THE <SCBNAME RECORD IS DEFINED AS:-
.NF
   ^^%RECORDFORMAT SCBNAME(%RECORD(SCB)%NAME NAME)\\
.F.P
^IN ADDITION THE CURRENTLY SELECTED STREAMS ARE POINTED TO BY
TWO %<RECORD %<NAME VARIABLES, NAMELY:-
.NF
   ^^%RECORD(SCB)%NAME INSCB
   %RECORD(SCB)%NAME OUTSCB\\
.F.P
^THUS BY PROVIDING %<SPEC STATEMENTS FOR THE ABOVE AND BY %^^INCLUDE\\ING
THE FILE <IMP:IOLIB.INC (WHERE THE <SCB IS DEFINED), THE USER HAS COMPLETE
ACCESS TO ALL THE STREAMS.
^IT SHOULD BE NOTED THAT THE USERS ^TELETYPE (E.G. STREAM 0) HAS A SPECIAL
SHORT <SCB ASSOCIATED WITH IT. ^SIMILARLY THE UNASSIGNED STREAM NUMBERS HAVE
SHORT ^^SCB\\S ASSOCIATED WITH THE 'NUL:' DEVICE.
.P
^THE <DA/SQ SYSTEM HAS A SINGLE ARRAY:-
.NF
   ^^%EXTERNALRECORD(SCBNAME)%ARRAY DASQVEC(1:15)\\
.F.AP
WHICH CONTAINS POINTERS TO THE ^^SCB\\S ASSOCIATED WITH EACH CHANNEL,
UNASSIGNED CHANNELS HAVING AN ADDRESS OF ZERO.
 ^THE <SCB RECORD AND IT'S SUB-RECORDS ARE DESCRIBED IN THE
FILE <IMP:IOLIB.INC AND IN ^APPENDIX ^C.
.PAGE.AP.F
.SUBTITLE ^SECTION 4: ^&^MEMORY ^MANAGEMENT\&
.INDEX MEMORY MANAGEMENT
.INDEX HEAP
.INDEX STACK
.INDEX INPUT/OUTPUT STORAGE AREA
.INDEX ^GLA
 ^THE RUNTIME SYSTEM FOR <IMP ON THE ^^DEC\\SYSTEM-10/20 NEEDS BOTH A
STACK AND A BUFFER AREA FOR THE <I/O SUBSYTEM.
.LM 5
 ^THE STACK CONTAINS THE RETURN ADDRESSES, FROM PROCEDURES, THE PREVIOUS
STACK BASE-ADDRESS AND STORAGE FOR ALL THE LOCAL ARRAYS AND VARIABLES
WHICH ARE DYNAMICALLY ALLOCATED UPON ENTRY TO BLOCKS AND PROCEDURES.
^IT IS A DYNAMIC STACK AND GROWS UPWARDS FROM THE TOP
OF THE USERS HIGH SEGMENT.
 ^THE HEAP IS A MANAGED DATA AREA WHICH SUPPLIES VECTORS OF ANY LENGTH
AT ANY CONTEXTUAL LEVEL IN THE USER PROGRAM. ^FOR EXAMPLE THE ^INPUT/^OUTPUT
SYSTEM USES THE HEAP TO GET SPACE FOR IT'S BUFFERS. ^IT IS ALSO
DYNAMIC AND GROWS UPWARD FROM THE TOP OF THE USERS LOW SEGMENT.
.LM
.NAP.NF
.S.LIT
             _________________
            |                 |
            |                 |
            |_ _ _ _ _ _ _ _ _|
            |             ^   |
            |             |   |
            |     STACK   |   |
            |_________________|
            |   HIGH SEGMENT  |
            |       CODE      |
            |_________________|   400000
            |                 |
            |                 |
            |                 |
            |_ _ _ _ _ _ _ _ _|
            |             ^   |
            |      HEAP   |   |
            |             |   |
            |_________________|
            |                 |
            |       GLA       |
            |_ _ _ _ _ _ _ _ _|
            |                 |
            |   LOW SEGMENT   |
            |_________________|    0
.END LITERAL
.PAGE
.INDEX MEMORY MANAGEMENT
.INDEX HEAP
.INDEX ^GLA
.INDEX STACK
.F
 ^NORMALLY THESE DATA AREAS ARE ALLOCATED AND MANAGED WITHOUT THE USER NEEDING
TO KNOW OF THEIR WHEREABOUTS. ^BUT THE USER WHO WANTS CONTROL OVER THEM
MAY ASSIGN FIXED LENGTHS FOR EITHER OR BOTH AREAS
BY DECLARING THE FOLLOWING VARIABLES, TOGETHER WITH THEIR SIZE (AT COMPILE TIME),
IN ANY OF THE PROGRAM MODULES TO BE
LOADED:-
.NF.S
     <%EXTERNALINTEGER <STACK <SIZE = N
     <%EXTERNALINTEGER <HEAP <SIZE  = M
.S.AP.F
 ^THE DATA AREAS THEMSELVES CAN ALSO BE DEFINED AND THEREBY INCLUDED IN THE GENERAL
LINKAGE AREA (<GLA) THUS:-
.S.NF.NAP
     <%EXTERNALINTEGERARRAY <STACK(0:STACKSIZE)
     <%EXTERNALINTEGERARRAY <HEAP(0:HEAPSIZE)
.AP.F.S
^IT SHOULD BE NOTED THAT WHEN ONE OF THE ABOVE DATA AREA DECLARATIONS IS USED,
THE CORRESPONDING SIZE VARIABLE MUST ALSO HAVE BEEN DECLARED, TOGETHER WITH ITS
SIZE GIVEN AT COMPILE TIME.
.PAGE
.SUBTITLE ^SECTION 5: ^&^CALLING OTHER LANGUAGES\&
.AP.LC
.INDEX <FORTRAN
.INDEX CALLING <FORTRAN FROM <IMP
.INDEX INPUT/OUTPUT
.INDEX HEAP
^&^CALLING <FORTRAN FROM <IMP\&
 ^IN ORDER TO CALL <FORTRAN FROM <IMP IT IS NECESSARY TO SIMULATE <FORTRAN<'S
CALLING CONVENTIONS. ^THIS IS DONE BY HAVING A SET OF JACKET PROCEDURES.
^THE FILE <IMP:FORTRA.INC CONTAINS THE SPECIFICATIONS FOR SUCH ROUTINES
AND INTEGER AND REAL FUNCTIONS THE NAMES OF WHICH ARE <CALL0-CALL9,
<ICALL0-ICALL9 AND <RCALL0-RCALL9 RESPECTIVELY. ^THE NUMBER IN THE NAME
REFERS TO THE NUMBER OF %<NAME TYPE PARAMETERS BEING PASSED TO <FORTRAN.
^EACH PROCEDURE ACTUALLY HAS N+1 %<NAME TYPE PARAMETERS,
THE FIRST IS THE NAME OF THE <FORTRAN PROCEDURE BEING CALLED. ^THIS HAS
TO BE DECLARED AS AN EXTERNAL AND FOR EASE OF PROCESSING, IT SHOULD BE
DECLARED AS AN %<EXTERNAL %<INTEGER. ^THE EXAMPLE BELOW SHOWS A
<FORTRAN INTEGER FUNCTION CALLED <MIXUP WITH FOUR PARAMETERS,
BEING CALLED FROM <IMP.
.S 2
.LITERAL
%INCLUDE "IMP:FORTRA.INC"
%BEGIN
   %EXTERNALINTEGERSPEC MIXUP
   %INTEGER A,B,C,D,N

   ........
   N = ICALL4(MIXUP,A,B,C,D)
   . . . .
%ENDOFPROGRAM
.END LITERAL
 ^SHOULD <FORTRAN <I/O BE REQUIRED, THEN THE EXTERNAL ROUTINE <INITFOR
SHOULD BE REQUESTED AND CALLED AT THE START OF EXECUTION. ^THIS WILL
CAUSE THE <FORTRAN LIBRARY TO BE SEARCHED AND WILL INITIALISE THE INPUT/OUTPUT
SYSTEM. ^IF <I/O IS BEING DONE FROM BOTH <IMP AND <FORTRAN THEN THE
<FORTRAN CHANNELS SHOULD BE SET UP FIRST AND THEN THE <IMP ONES.
^THIS IS BECAUSE <IMP SEES IF A CHANNEL IS IN USE BEFORE IT TRIES TO ASSIGN IT.
^IT IS ALSO NECESSARY THAT THE HEAP SPACE WHERE <IMP SETS UP ITS BUFFERS
IS DECLARED IN THE USER'S OWN AREA (SEE THE MEMORY MANAGEMENT SECTION),
OTHERWISE BOTH <FORTRAN AND <IMP WILL COMPETE FOR STORE MANAGEMENT AT THE TOP
OF THE LOW SEGMENT.
.S
.INDEX <FORTRAN <COMMON BLOCKS
^&<COMMON BLOCKS\&
 ^IF <COMMON BLOCKS NEED TO BE ACCESSED FROM <IMP, THIS IS ACCOMPLISHED
BY DECLARING AN EXTERNAL BLOCK OF STORE HAVING THE SAME NAME AS
THE COMMON BLOCK AND HAVING THE SAME FORM. ^THIS CAN BE DONE EITHER BY
MAPPING ONTO AN INTEGER ARRAY OR ELSE BY DEFINING A RECORD HAVING THE
APPROPRIATE FORM.
 ^BELOW IS AN EXAMPLE PROGRAM WHICH ACCESSES THE <FORTRAN
<COMMON BLOCK:-
.S.NF
.NAP
   ^^COMMON/FORIMP/ IA,IB,IC,X,Y,Z\\
.S.F
GIVING IN <IMP:-
.S
.LITERAL
%BEGIN
   %RECORDFORMAT COMMON1(%INTEGER IA,IB, %REAL X,Y)
   %EXTERNALRECORD(COMMMON1)%SPEC FORIMP
    .......
   %IF FORIMP_IA = FORIMP_IB %THEN FORIMP_X = FORIMP_Y
    .....
%ENDOFPROGRAM
.END LITERAL
.S 2
.INDEX CALLING <IMP FROM <FORTRAN
.INDEX INPUT/OUTPUT
.INDEX HEAP
^&^CALLING <IMP FROM <FORTRAN\&
.AP
 ^AN <IMP PROCEDURE MAY BE CALLED FROM <FORTRAN JUST LIKE
AN EXTERNALLY DEFINED <FORTRAN PROCEDURE. ^IF ANY PARAMETERS NEED TO BE PASSED,
THIS MAY BE DONE EITHER THROUGH <COMMON (SEE ABOVE) OR BY THE APPROPRIATE
DECODING OF THE PARAMETERS ON THE <IMP SIDE. ^SINCE <FORTRAN
PASSES THE ADDRESS OF A LIST OF POINTERS TO THE PARAMETERS, THE <IMP PROCEDURE
SEES THE EQUIVALENT OF A %<RECORD %<NAME PARAMETER, WHOSE FORMAT IS A
LIST OF %<NAME TYPE PARAMETERS. ^THE FOLLOWING CODE WOULD
BE REQUIRED TO HANDLE THE CALL OF AN <IMP ROUTINE HAVING TWO INTEGER
NAME PARAMETERS, INVOKED BY THE <FORTRAN STATEMENT
.S
.LITERAL
      CALL IMPRTN(IVAL1,IVAL2)

.END LITERAL
.S
IN <IMP:-
.S
.LITERAL
%RECORDFORMAT IMPRTN PARAMETERS(%INTEGERNAME IVAL1,IVAL2)
%RECORD (IMPRTN PARAMETERS) R

   %EXTERNALROUTINE IMPRTN(%RECORD(IMPRTN PARAMETERS)%NAME R)
      R_IVAL1=R_IVAL1+1
      R_IVAL2=R_IVAL2-1
   %END
%ENDOFFILE
.END LITERAL
 ^IF THE <IMP INPUT/OUTPUT SYSTEM IS REQUIRED THEN A CALL FROM <FORTRAN
OF THE <IMP ROUTINES <INITIO AND <INITHEAP ARE NEEDED BEFORE ANY
<IMP INPUT/OUTPUT IS DONE. ^HOWEVER THE SAME LIMITATION EXISTS, AS FOR
CALLING <FORTRAN FROM <IMP, THAT ANY <FORTRAN <I/O CHANNELS SHOULD
BE SET UP FIRST, BEFORE <IMP <I/O IS ATTEMPTED, AND THAT THE HEAP SHOULD
BE DECLARED IN THE <IMP MODULE (SEE THE MEMORY MANAGEMENT SECTION).
.SUBTTL <IMP/MACRO CROSS CALLING
.PAGE
.INDEX INPUT/OUTPUT
.INDEX HEAP
.INDEX <MACRO
.INDEX CALLING <MACRO FROM <IMP
.INDEX CALLING <IMP FROM <MACRO
.INDEX <SCB
^&^CALLING <MACRO FROM <IMP\&
 ^NO DIFFICULTIES SHOULD BE ENCOUNTERED, SO LONG AS THE <IMP CALLING
CONVENTIONS ARE ADHERED TO AND THE BASE REGISTERS ARE ALWAYS PRESERVED.
^THE FILE <IMP:IMPPRM.MAC CONTAINS THE DEFINITION OF REGISTERS, <IMP STRINGS
AND <SCB RECORDS. (SEE ALSO ^APPENDIX ^D).
.S 2
^&^CALLING <IMP FROM <MACRO\&
 ^SO LONG AS THE STACK (REGISTER 17) IS LARGE ENOUGH FOR THE
<IMP PROCEDURES BEING CALLED, NO DIFFICULTIES SHOULD BE
ENCOUNTERED. <IMP WILL DESTROY THE LEFT HALF OF THE
STACK POINTER AND WILL NOT NECESSARILY PRESERVE ANY OF THE REGISTERS.
^IF THE REGISTERS NEED TO BE PRESERVED THEN THE MACRO PROGRAM MUST
LOOK AFTER IT, ALTHOUGH THERE ARE TWO ROUTINES IN THE <IMP SYSTEM LIBRARY
TO HELP.
 ^THESE ROUTINES ARE CALLED <SAVEACS AND <RESTORE AND WILL SAVE AND
RESTORE REGISTERS 2-17. ^REGISTERS 0 AND 1 ARE LEFT SO THAT RESULTS FROM
MAPS AND FUNCTIONS CAN BE RETURNED.
 ^IF <IMP <I/O IS REQUIRED, THEN THE ROUTINES <INITIO AND <INITHEAP MUST
BE CALLED FIRST, EITHER BY <MACRO OR <IMP AND THE HEAP MUST BE DECLARED
IN THE <IMP MODULE (SEE THE MEMORY MANAGEMENT SECTION).
.PAGE
.SUBTITLE ^SECTION 6: ^&^PROGRAM DEBUGGING\&
.INDEX <DDT
.INDEX DEBUGGING
.NF.NAP
    ^&<DDT\&
.AP.F
 ^THE STANDARD <DEC-10 DEBUGGING SYSTEM <DDT CAN BE USED IN THE NORMAL WAY.
^THE CODE CAN BE FOLLOWED WITH THE HELP OF <ALIST OR <RECODE LISTINGS
(SEE BELOW).
 ^THERE IS ALSO A SYSTEM ROUTINE <DDT WHICH TAKES A
<%NAME TYPE PARAMETER AND, WHEN ENCOUNTERED, WILL
ENTER <DDT WITH ALL THE REGISTERS UNCHANGED AND THE ARGUMENT ADDRESS SAVED IN
<DDARG. ^THE MAIN PROGRAM CAN BE RESUMED BY TYPING:-
.NAP;.NF;.S
      <DDCONT$G
.PAGE
.INDEX DEBUGGING
.INDEX </CROSS
   ^&</CROSS\&
.F.AP
 ^A CROSS REFERENCE LISTING FILE, USING THE COMPILER'S OWN CROSS REFERENCE
LISTER, IS OBTAINED BY INCLUDING THE </CROSS SWITCH IN THE COMPILER
COMMAND STRING. ^THE OUTPUT ALLOWS ONE TO TRACE THE USE OF LOCAL AND GLOBAL
VARIABLES IN PROCEDURES AND AT DIFFERENT CONTEXTUAL LEVELS.
.NF.NAP.PAGE
.INDEX DEBUGGING
.INDEX <ALIST
.INDEX <RECODE
    ^&<ALIST\&
.AP.F
 <ALIST IS A PROGRAM ON THE SYSTEM AREA WHICH TAKES AN <IMP SOURCE
FILE AND THE CORRESPONDING  OBJECT FILE AND PRODUCES A LISTING FILE WHICH CONTAINS,
ALONG WITH THE LINE-NUMBERED SOURCE, THE RELATIVE ADDRESSES
OF THE CODE GENERATED FOR EACH SOURCE LINE.
^AN EXAMPLE OF <ALIST OUTPUT IS SHOWN AT THE END OF THIS SECTION.
.S 2
    ^&<RECODE\&
.AP.F
 ^RECODE IS A PROGRAM RESIDING ON THE SYSTEM AREA WHICH TAKES AN <IMP
SOURCE FILE AND THE CORRESPONDING OBJECT FILE AND PRODUCES A LISTING FILE
WHICH CONTAINS ALONG WITH THE LINE-NUMBERED SOURCE, THE CODE WHICH THE
COMPILER HAS GENERATED FOR EVERY LINE.
^AN EXAMPLE OF <RECODE OUTPUT IS SHOWN OVERLEAF.
.NAP;.S;.TS 6, 15;.NF
    ^&^THE COMMAND FORMAT FOR BOTH <ALIST AND <RECODE\&
.AP.F.S
^BOTH PROGRAMS PROMPT WITH 
.NAP.NF
	*
TO WHICH THE RESPONSE IS
.NAP.NF.S
	* _<LIST-FILESPEC_> = _<SOURCE-FILESPEC_> , _<REL-FILESPEC_>
OR	* _<LIST-FILESPEC_> = _<SOURCE-FILESPEC_>
OR	* _<SOURCE-FILESPEC_>
.S
WHERE THE MISSING ARGUMENTS ARE REPLACED BY THE FOLLOWING
.S
	LIST-FILESPEC   - <DSK: FILENAME <.LST [USER]
	REL-FILESPEC    - <DSK: FILENAME <.REL [USER]
	SOURCE-FILESPEC - <DSK: FILENAME <.IMP [USER]
.AP;.F
 ^IN ADDITION TO THIS <RECODE REQUIRES A RANGE OF LINES FOR WHICH RECODING
IS REQUIRED. ^THE PROMPTS FOR THIS ARE:-
.NAP;.NF;.S
	^FROM: N
	^TO:   M
.AP;.F
THIS MAY BE REPEATED A NUMBER OF TIMES. ^A RESPONSE OF ZERO CLOSES THE
OUTPUT AND RETURNS TO MONITOR LEVEL.
.PAGE
.INDEX DEBUGGING
.INDEX <ALIST EXAMPLE
.NF.NAP.C
^&^AN EXAMPLE OF <ALIST OUTPUT\&
.S.LIT
    1 400016 %BEGIN;   !A PROGRAM TO OUTPUT A FILE ONTO THE TERMINAL
    2        
    3           %CONSTINTEGER IN=1;     !STREAM NUMBER
    4           %INTEGER SYM;          !AN INTEGER TO READ CHARACTERS INTO
    5        
    6 400022    %ON %EVENT 9 %START;   !TRAP WHEN END-OF-FILE ENCOUNTERED ON INPUT
    7 400023       CLOSE INPUT;        !CLOSE THE INPUT FILE
    8 400024       %STOP;              !AND FINISH PROGRAM EXECUTION
    9           %FINISH
   10        
   11 400027    DEFINE INPUT(IN,"FILE.TXT"); !OPEN INPUT FILE
   12 400032    SELECT INPUT(IN);              !SET TO READ FROM FILE
   13        
   14           %CYCLE;                 !MAIN PROGRAM LOOP
   15 400034       READ SYMBOL(SYM);    !READ A CHARACTER FROM THE FILE
   16 400036       PRINT SYMBOL(SYM);   !OUTPUT CHARACTER TO TERMINAL
   17 400040    %REPEAT;                !CONTINUE UNTIL END-OF-FILE EVENT 
   18 400004 %ENDOFPROGRAM

.END LITERAL
.PAGE
.INDEX DEBUGGING
.INDEX <RECODE
.NF.NAP.C
^&^AN EXAMPLE OF <RECODE OUTPUT\&
.S.LIT
   1 %BEGIN;   !A PROGRAM TO OUTPUT A FILE ONTO THE TERMINAL
      400016  202717 000001  MOVEM  13,      1(17)
      400017  200700 000017  MOVE   13,     17
      400020  271740 000003  ADDI   17,      3
      400021  417017 000006  SETMM   0,      6(17)
   2 
   3    %CONSTINTEGER IN=1;     !STREAM NUMBER
   4    %INTEGER SYM;          !AN INTEGER TO READ CHARACTERS INTO
   5 
   6    %ON %EVENT 9 %START;   !TRAP WHEN END-OF-FILE ENCOUNTERED ON INPUT
      400022  254000 400027  JRST    0, 400027
      400014  400041 400027  SETZ    1, 400027(1)
      400015  001000 400023  USER    0, 400023
   7       CLOSE INPUT;        !CLOSE THE INPUT FILE
      400023  260740 000000  PUSHJ  17,      0
   8       %STOP;              !AND FINISH PROGRAM EXECUTION
      400024  403200 000005  SETZB  14,     15
      400025  400300 000000  SETZ   16,      0
      400026  265140 000000  JSP     3,      0
   9    %FINISH
  10 
  11    DEFINE INPUT(IN,"FILE.TXT"); !OPEN INPUT FILE
      400027  201040 000001  MOVEI   1,      1
      400030  551300 000001  HRRZI  16,      1
      400031  260740 400107  PUSHJ  17, 400107
  12    SELECT INPUT(IN);              !SET TO READ FROM FILE
      400032  551300 000001  HRRZI  16,      1
      400033  260740 400136  PUSHJ  17, 400136
  13 
  14    %CYCLE;                 !MAIN PROGRAM LOOP
  15       READ SYMBOL(SYM);    !READ A CHARACTER FROM THE FILE
      400034  201316 000002  MOVEI  16,      2(16)
      400035  260740 000000  PUSHJ  17,      0
  16       PRINT SYMBOL(SYM);   !OUTPUT CHARACTER TO TERMINAL
      400036  200316 000002  MOVE   16,      2(16)
      400037  260740 000000  PUSHJ  17,      0
  17    %REPEAT;                !CONTINUE UNTIL END-OF-FILE EVENT 
      400040  254000 400034  JRST    0, 400034
  18 %ENDOFPROGRAM
      400004  000000 400013
      400013  000000 400163
      400005  000000 000000
      400163  000000 400165
      400041  000000 000000
      400165  000000 400167
      400164  000000 000000
      400167  000000 400171
      400166  000000 000000
      400171  000000 400173
      400170  000000 000000
      400173  000000 000000
      400172  000000 000000
.END LITERAL
.SUBTITLE                              ^&^APPENDIX ^A\&
.PAGE;.NAP;.NF
.INDEX CHARACTER CONSTANTS
.INDEX CONSTANTS
.INDEX MONITOR LOCATIONS
.TS 6
^&^USEFUL CONSTANTS AND VARIABLES.\&
.S
^CHARACTERS:-
	<NL  -  NEWLINE CHARACTER
	<SP  -  SPACE CHARACTER
	<TAB -  TAB CHARACTER
	<FF  -  FORM-FEED CHARACTER
	<ESC -  ESCAPE CHARACTER

MONITOR LOCATIONS:-
	<AC(0:8__17)         - REGISTERS
	<VERSION            - <DEC-10 FORMAT ^VERSION NUMBER
	<JOBDAT(8__40:8__140) - ^JOB ^DATA AREA
.SUBTITLE                              ^&<APPENDIX ^B\&
.PAGE.NAP.NF
.INDEX <FILESPEC RECORDS
.INDEX FILE SPECIFICATIONS
.INDEX FILE SWITCHES
.INDEX SWITCHES
.FLAG CAP
^&^DEFINITION OF THE FILE SPECIFICATION RECORD\&
.S 1
<%RECORDFORMAT <FILESPEC( %^C
   <%STRING(6) <DEV,      - ^DEVICE NAME
   <%STRING(6) <FILE,     - ^FILE NAME
   <%STRING(3) <EXT,      - ^FILE EXTENSION
   <%INTEGER <PPN,        - ^PROJECT-PROGRAMMER PAIR
   <%STRING(6)%ARRAY <SFDS(1:MAX <SFDS),
                        - ^LIST OF SUB-FILE DIRECTORIES
   <%INTEGER <PROT,       - 3 OCTAL DIGIT PROTECTION CODE
   <%STRING(20) <SWITCHES)- ^STRING OF SWITCHES
.S 1
^SWITCHES RECOGNISED BY THE <DEC-10 SYSTEM LIBRARY ARE:-
.F
.LM19.TS 19.S.I-15
   </ALLOCATE: N	^ALLOCATE 'N' CONTIGUOUS BLOCKS WHEN CREATING A FILE
.I-15
   </BLOCKSIZE:#N	^SET BLOCKSIZE FOR A DEVICE
.I-15
   </BUFFERS: #N	^USE 'N' BUFFERS IN THE BUFFER RING
.I-15
   </BYTE: ####N	^SET THE BYTE SIZE FOR READING/WRITING
.I-15
   </DENSITY: #N	^SET DENSITY FOR MAGNETIC TAPE
( 200, 556, 800 OR 1600 BPI )
.I-15
   </ESTIMATE: N	^SET ASIDE 'N' BLOCKS WHEN CREATING A FILE
.I-15
   </EXTEND: ##N	^USE AN EXTENDED ^LOOKUP/^ENTER BLOCK
WHERE 'N' IS OMMITTED 35 OCTAL IS ASSUMED
.I-15
   </FUNCTION: N	^THE APPROPRIATE <FILOP FUNCTION IS USED
.I-15
   </MODE: ####N	^SET THE MODE TO BE THIS (THE STATUS WORD)
.I-15
   </PARITY: ##N	^SET PARITY FOR MAGNETIC TAPES: 0 = EVEN, 1 = ODD
.I-15
   </TRMOP	^USE <TRMOP <UUO FOR TERMINAL <I/O
.I-15
   </VERSION: #N	^VERSION NUMBER INTERPRETED IN <DEC <.JBVER FORMAT
(SEE ^^DEC\\SYSTEM 10 ^MONITOR ^CALLS ^MANUAL)
.LM 0.F
^SWITCHES CAN BE ABREVIATED TO THE SHORTEST UNIQUE STRING.
^NUMBERS CAN BE SPECIFIED AS OCTAL IF PRECEDED BY A HASH SIGN.
.NF.S
E.G.    </BL:_#203   - SET THE BLOCKSIZE TO OCTAL 203
.SUBTITLE                              ^^^&APPENDIX C\\\&
.PAGE
.INDEX <SCB RECORD DEFINITION
.INDEX INPUT/OUTPUT INTERNAL RECORDS
.NAP.NF
^&^DEFINITION OF THE INTERNAL INPUT/OUTPUT RECORDS\&
.S
^&^DEFINITION OF STREAM CONTROL BLOCKS\&
.F.S
^THE STREAM CONTROL BLOCKS FOR ALL THE STREAMS ARE POINTED
TO BY THE FOLLOWING ARRAYS:-
.NF.S
^^%EXTERNALRECORD(SCBNAME)%ARRAY INVEC(0:15)
%EXTERNALRECORD(SCBNAME)%ARRAY OUTVEC(0:15)\\
.F.S
WHERE THE RECORD <SCBNAME IS DEFINED:-
.NF
^^%RECORDFORMAT SCBNAME(%RECORD(SCB)%NAME NAME)\\
.S
AND THE CURRENT ^^SCB\\S ARE POINTED TO BY
.NF.S
^^%EXTERNALRECORD(SCB)%NAME INSCB
%EXTERNALRECORD(SCB)%NAME OUTSCB\\
.S.F
^AND FOR <DA/SQ CHANNELS THEY ARE POINTED TO BY THE ARRAY:-
.NF.S
^^%EXTERNALRECORD(SCBNAME)%ARRAY DASQVEC(1:15)\\
.S.F
WHERE THE FORMAT OF THE <SCB IS AS FOLLOWS:-
.NF.S
<%RECORD <%FORMAT <SCB(   <%C
    <%INTEGER <DEVTYP    - ^DEVICE TYPE, WHERE
                         (-3=STRING, -2=TMPCOR, -1=NUL:
                         AND >=0 IS DEFINED IN '<DEVTYP' <UUO)
                         IS DEFINED IN '<DEVTYP' <UUO)
    <%INTEGER <CHNTYP    - ^STREAM OR CHANNEL TYPE. ^WHERE
                         (0=STREAM, 1=<DA FILE, 2=<SQ FILE)
    <%INTEGER <NXTCHR    - ^THE NEXT CHARACTER FOR INPUT
    <%INTEGERNAME <OPER  - ^ADDRESS OF READ OR WRITE ROUTINE
    <%INTEGER <FLAGS     - ^FLAGS (BIT0=ZERO AS NEXT SYMBOL)
    <%INTEGER <RESERVED  - ^RESERVED
    <%STRING(3) <TMPNAME - ^NAME OF A TMPCOR FILE.
    <%INTEGER <UDX       - ^UNIVERSAL ^DEVICE ^INDEX
    <%INTEGER <FILOPFN   - ^FIRST WORD OF A FILOP TYPE RECORD
                         PHYSICAL CHANNEL NUMBER IN LH
                         AND FILOP FUNCTION CODE IN RH
    <%INTEGER <STATUS    - ^FIRST WORD OF AN OPEN BLOCK
                         IS STATUS WORD, INCLUDING <I/O MODE
    <%INTEGER <DEVNAM    - ^SIXBIT DEVICE NAME
    <%INTEGER <BUFHEDS   - ^ADDRESSES OF BUFFER RING HEADERS
                         OUTPUT<(LH) AND INPUT<(RH)
    <%INTEGER <BUFNUM    - ^NUMBER OF BUFFERS IN RING
                         OUTPUT<(LH) AND INPUT<(RH)
    <%RECORD(LOOKUPBLOCK)%NAME <LKENT
                       - ^ADDRESS OF LOOKUP-ENTER BLOCK
    <%INTEGER <PATHARG   - ^PATH BLOCK POINTER
                         LENGTH<(LH) AND ADDRESS<(RH)
    <%RECORD(RINGHEADER) <RINGHEAD
                       - ^BUFFER RING HEADER
    <%INTEGER <IBUFOP    - <IN <CHAN,0
    <%INTEGER <OBUFOP    - <OUT <CHAN,0
    <%INTEGER <USETI     - <USETI <CHAN,0
    <%INTEGER <USETO     - <USETO <CHAN,0
    <%INTEGER <STATZ     - <STATZ <CHAN,740000
    <%INTEGER <BLOCKSIZE - ^SIZE OF THE DEVICE BLOCKS
    <%RECORD(PATHBLOCK) <PATHBLK )
                       - ^PATH BLOCK
.S
^AND FOR TELETYPES
.S
<%RECORD <%FORMAT <TTSCB(   <%C
    <%INTEGER <DEVTYP    - !
    <%INTEGER <CHNTYP    - !
    <%INTEGER <NXTCHR    - !    SAME AS IN <SCB
    <%INTEGERNAME <OPER  - !
    <%INTEGER <FLAGS     - ^FLAG WORD
    <%INTEGER <ARGPTR    - ^POINTER TO <TRMOP ARG BLOCK
    <%INTEGER <FUNCT     - ^FIRST WORD OF ARG BLOCK -
                         (FUNCTION CODE)
    <%INTEGER <UDX       - ^UNIVERSAL ^DEVICE ^INDEX
    <%INTEGER <OUTARG)   - ^NEXT CHAR FOR OUTPUT
.S
^AND FOR STRINGS
.S
<%RECORD <%FORMAT <STRSCB(   <%C
    <%INTEGER <DEVTYP    - !
    <%INTEGER <CHNTYP    - !
    <%INTEGER <NXTCHR    - !    SAME AS IN <SCB
    <%INTEGERNAME <OPER  - !
    <%INTEGER <LENGTH    - ^STRING LENGTH
    <%INTEGER <LENPTR    - ^POINTER TO LENGTH BYTE
    <%INTEGER <POINTER)  - ^POINTER TO CURRENT BYTE
.S
^WHERE THE OTHER RECORDS ARE DEFINED AS FOLLOWS.
.S 2
<%RECORDFORMAT <OPENBLOCK(  <%C
   <%INTEGER <STATUS,    - ^STATUS INCLUDING <I/O MODE
   <%INTEGER <DEVNAM,    - ^SIXBIT DEVICE NAME
   <%INTEGER <BUFHEDS)   - ^ADDRESSES OF BUFFERS
                         OUTPUT<(LH) AND INPUT<(RH)
.S
^THIS RECORD CAN BE MAPPED ONTO THE <SCB AT <SCB__STATUS
.S2
<%RECORDFORMAT <LOOKUPBLOCK( <%C
   <%INTEGER <CNT,       - ^LENGTH OF FOLLOWING BLOCK
                         (DEFAULT=4)
   <%INTEGER <PPN)       - ^PROJECT-PROGRAMMER NUMBER
   <%INTEGER <NAM,       - ^SIXBIT FILE NAME
   <%INTEGER <EXT,       - ^SIXBIT EXTENSION<(LH)
   <%INTEGER <PRV,       - ^DATE-TIME AND PROTECTION
.F
^THE FOLLOWING RECORD ITEMS ARE ONLY USED WHEN THE ^^/EXTEND:\\N SWITCH IS
GIVEN. ^THEY ARE NAMED ACCORDING TO THE <DEC-10 EXTENDED LOOKUP-BLOCK
CONVENTIONS (SEE <DEC-10 <MONITOR <CALLS <MANUAL).
.NF
   <%INTEGER <SIZ, <VER, <SPL, <EST, <ALC, <POS, <TF1, <NCA, <MTA,
   <DEV, <STS, <ELB, <EUN, <QTF, <QTO, <USD, <AUT, <PCA, <UFD, <FLR,
   <XRA, <TIM)
.S2
<%RECORDFORMAT <RINGHEADER( <%C
   <%INTEGER <BUFADR,    - ^ADDRESS OF CURRENT BUFFER
   <%INTEGER <BYTPTR,    - ^POINTER TO CURRENT BYTE
   <%INTEGER <BYTCNT,    - ^BYTE COUNT
   <%INTEGER <MPXUDX)    - ^UNIVERSAL DEVICE INDEX FOR <MPX
.S2
<%RECORDFORMAT <PATHBLOCK( <%C
   <%INTEGER <FUNCT,     - ^REQUIRED FUNCTION
   <%INTEGER <SWITCHES,  - ^SCAN SWITCHES
   <%INTEGER <PPN,       - ^PROJECT-PROGRAMMER NUMBER
   <%INTEGERARRAY <SFDS(1:MAXSFDS)) - ^SIXBIT <SFD NAMES
.S 2
<%RECORDFORMAT <FILOPBLOCK( <%C
   <%INTEGER <FUNCT,     - ^PHYSICAL CHANNEL NUMBER<(LH)
                         AND FUNCTION CODE<(RH)
   <%INTEGER <STATUS,    - ^STATUS WORD, INCLUDING <I/O MODE
   <%INTEGER <DEVNAM,    - ^SIXBIT DEVICE NAME
   <%INTEGER <BUFHEDS,   - ^ADDRESSES OF BUFFER RING HEADERS
                         OUTPUT<(LH) AND INPUT<(RH)
   <%INTEGER <BUFNUM,    - ^NUMBER OF BUFFERS IN EACH
                         OUTPUT<(LH) AND INPUT<(RH)
   <%RECORD(LOOKUPBLOCK)%NAME <LKENT,
                       - ^LOOKUP-ENTER BLOCK ADDRESS
   <%INTEGER <PATHARG)   - ^PATH BLOCK POINTER
                         LENGTH<(LH) AND ADDRESS<(RH)
.S
^THIS RECORD CAN BE MAPPED ONTO THE <SCB AT <SCB__FILOPFN
.INDEX INPUT/OUTPUT INTERNAL RECORDS
.SUBTITLE                              ^^^&APPENDIX D\\\&
.PAGE
.INDEX DATA STORAGE
.INDEX <%BYTE STORAGE
.INDEX <%SHORT %<INTEGER STORAGE
.INDEX <%INTEGER STORAGE
.INDEX <%REAL STORAGE
.INDEX <%LONG %<REAL STORAGE
.INDEX %<STRING STORAGE
.INDEX <%RECORD STORAGE
^&^DATA STORAGE\&
.F.NAP.S
%<BYTE %<INTEGER VARIABLES OCCUPY 9-BIT BYTES AND ARE PACKED LEFT TO RIGHT 4 TO A WORD
.S
%<STRING VARIABLES COMPRISE 7-BIT BYTES AND ARE PACKED LEFT TO RIGHT 5 TO A WORD, WITH
THE FIRST TWO BYTES BEING ALIGNED ON A WORD BOUNDARY AND CONTAINING THE STRING LENGTH. (MAXIMUM 255)
.S
%<SHORT %<INTEGER VARIABLES OCCUPY 18 BITS OR HALF A ^^DEC\\SYSTEM-10/20 WORD
.S
%<INTEGER AND %<REAL VARIABLES OCCUPY 36 BITS OR
ONE ^^DEC\\SYSTEM-10/20 WORD, GIVING A RANGE OF VALUES OF
-34,359,738,367  TO +34,359,738,367 FOR INTEGERS AND
1.4@-39 TO 1.7@38 TO AN SIGNIFICANCE OF APPROXIMATELY EIGHT AND
ONE-HALF DECIMAL DIGITS FOR REALS.
.S
%<LONG %<REAL VARIABLES OCCUPY 72 BITS OR TWO ^^DEC\\SYSTEM-10/20 WORDS
AND EXTEND THE PRECISION OF REAL REPRESENTATION TO ABOUT SEVENTEEN DECIMAL DIGITS.
.S
%<RECORD VARIABLES OCCUPY AS MUCH SPACE AS THEIR COMPONENT
ITEMS, ALLOWING FOR NECCESSARY WORD ALLIGNMENT OF %<BYTE AND <%SHORT
%<INTEGER VARIABLES. ^THERE IS NO RECORD HEADER WORD.
.S
%<NAME VARIABLES OCCUPY A SINGLE ^^DEC\\SYSTEM-10/20 WORD. ^THEY
ARE POINTERS TO DIFFERENT TYPES OF OBJECTS. ^THE RIGHT HALF OF THE WORD
CONTAINS THE ADDRESS OF THE OBJECT. ^THE LEFT HALF CONTAINS THE TYPE OF OBJECT AND
ITS LENGTH AS A NUMBER OF ^^DEC\\SYSTEM-10/20 WORDS (RELEVANT
FOR RECORDS AND STRINGS)
.NF.S
BITS 0-8 CONTAIN THE LENGTH OF THE OBJECT (MAXIMUM=255)
.S
BITS 9-12 CONTAIN THE OBJECT TYPE, WHERE:-
   1 = %<INTEGER
   2 = %<SHORT %<INTEGER
   3 = %<BYTE %<INTEGER
   4 = %<STRING
   5 = %<RECORD
   6 = %<REAL
   7 = %<LONG %<REAL
.F
.PAG
^&^CODE CONVENTIONS\&
.INDEX CODE CONVENTIONS
.INDEX REGISTER ALLOCATION
.S 2
^&^REGISTER ALLOCATION\&
.TS 6.NF.S 1
	17	- PROCEDURE AND DATA STACK POINTER
	16	- FIRST PARAMETER
	15	- SECOND PARAMETER
	14	- THIRD PARAMETER
	13	-!
	12	-!
	11	-! - BASE REGISTERS
	10	-!
	#7	-!
	#6	- GENERAL PURPOSE
	#5	- GENERAL PURPOSE
	#4	- GENERAL PURPOSE
	#3	- GENERAL PURPOSE
	#2	- GENERAL PURPOSE
	#1	- <%RESULT REGISTER FROM <%^^MAP\\S
	#0	- <%RESULT REGISTER FROM %^^FUNCTION\\S
.S
.AP;.F
 ^REGISTERS 0-6 AND 14-16 CAN BE REGARDED AS FREE FOR USE IN MACHINE
CODE INSTRUCTIONS AND PROCEDURES.
.S 2
.INDEX PROCEDURE ENTRY AND EXIT
^&^PROCEDURE ENTRY AND EXIT\&
 ^THE NORMAL ENTRY AND EXIT SEQUENCE IS SHOWN BELOW, FOR A ROUTINE
WITH NO PARAMETERS. ^THE ROUTINE WOULD BE CALLED BY THE INSTRUCTION
.NF
    ^^PUSHJ   P,\\ROUTINE
.S
ENTRY SEQUENCE:-
.NAP.UC
    MOVEM  BASE1,1(P)  ;STORE PREVIOUS BASE REGISTER VALUE
    MOVE   BASE1,P     ;AND LOAD THE NEW BASE ADDRESS
    ADDI       P,'N'   ;MOVE POINTER OVER LOCAL STORAGE
    SETMM      0,6(P)  ;DO A TEST WRITE TO TOP OF STACK
                       ;THIS WILL TRAP TO CORE MANAGEMENT
                     ;SYSTEM IF BEYOND TOP OF CURRENT CORE
.S.LC
THEN THE ROUTINE BODY, FOLLOWED BY THE EXIT SEQUENCE:-
.UC.S
    MOVE      P,BASE1  ;GET CURRENT STACK BASE
    MOVE  BASE1,1(P)   ;RESTORE PREVIOUS STACK BASE
    POPJ      P,       ;RETURN
.AP.F.LC.S
^WHENEVER POSSIBLE THIS SEQUENCE WILL BE OPTIMISED,
FOR INSTANCE WHEN THERE ARE NO LOCAL VARIABLES AND SIMPLE OR NO
PARAMETERS. ^OVERLEAF IS THE <IMPLICIT ROUTINE <NEWLINE, TOGETHER
WITH CODE PRODUCED FOR IT.
.PAGE
.LITERAL
%EXTERNALROUTINE NEWLINE
   PRINTSYMBOL(NL)
%END

gives the following code:-

   HRRZI  ARG1,12      ;LOAD ARGUMENT WITH NEWLINE SYMBOL
   JRST   PRINTSYMBOL  ;AND JUMP TO ROUTINE, WHICH WILL DO
                       ; THE 'POPJ' RETURN
.END LITERAL
.S
.INDEX PARAMETERS TO PROCEDURES
^&^PARAMETERS TO PROCEDURES\&
.AP;.F
 ^ON ENTRY TO A PROCEDURE, ANY PARAMETERS HAVE BEEN STORED ON THE STACK
AT THE LOCATIONS 2(^P) UPWARDS. ^AS WE HAVE SEEN THE PREVIOUS STACK BASE ADDRESS IS
STORED AT 1(^P) AND THE RETURN ADDRESS AT 0(^P).
 ^HOWEVER THE FIRST THREE PARAMETERS, IF THEY HAVE ONE WORD
VALUES (E.G. INTEGERS, REALS AND ALL
NAME TYPE PARAMETERS), ARE PASSED IN THE THREE REGISTERS SHOWN ABOVE,
AND ARE STORED, IF NECESSARY, BY THE PROCEDURE ITSELF. ^SIMILARLY IF
THE FINAL PARAMETER IS A STRING VALUE, THE ADDRESS OF THE STRING IS
PASSED IN REGISTER 1.
 ^THE BASE REGISTERS AND STACK POINTER MUST BE PRESERVED ON RETURN FROM
THE PROCEDURE. ^THE ACTUAL BASE REGISTER USED BY THE PROCEDURE
DEPENDS ON IT'S CONTEXTUAL LEVEL, THERE BEING FIVE POSSIBLE
LEVELS.
^OVERLEAF IS AN EXAMPLE OF THE CODE PRODUCED FOR A COMPLICATED PROCEDURE CALL.
.PAGE
.LITERAL
%BEGIN
%RECORDFORMAT INTS(%INTEGER I1,I2)
%RECORD(INTS) R1
%INTEGER VAR

   %ROUTINE TEST(%INTEGER N,M %RECORD(INTS) R %STRING(255) S)
      %INTEGER A1,A2,A3
      A1=N
   %END

   TEST(1,VAR,R1,"TESTING")
%ENDOFPROGRAM

.END LITERAL
PRODUCES THE CODE:-
.LITERAL

%BEGIN
          MOVEM  BASE1,1(P)       ;SAVE OLD STACK BASE
          MOVE   BASE1,P          ;GET NEW BASE
          ADDI       P,5          ;MOVE STACK POINTER PAST LOCALS
          SETMM      0,6(P)       ;CHECK FOR TOP OF CORE
%RECORDFORMAT INTS(%INTEGER I1,I2)
%RECORD(INTS) R1
%INTEGER VAR

   %ROUTINE TEST(%INTEGER N,M %RECORD(INTS) R %STRING(255) S)
          MOVEM  BASE2,1(P)       ;SAVE OLD STACK BASE
          MOVE   BASE2,P          ;GET NEW BASE ADDRESS
          ADDI       P,111        ;MOVE PAST LOCAL STORAGE
          SETMM      0,6(P)       ;CHECK FOR TOP OF CORE
          MOVEM   ARG1,2(BASE2)   ;SAVE FIRST ARGUMENT - "N"
          MOVEM   ARG2,3(BASE2)   ;SAVE SECOND ARGUMENT - "M"
          MOVEI     P1,6(BASE2)   ;GET ADDRESS FOR WHICH STRING
          JSP        J,.$MOVE     ;AND MOVE IT FROM REGISTER 1
       %INTEGER A1,A2,A3
       A1=N
          MOVEM   ARG1,106(BASE2) ;MOVE "N" TO FIRST FREE LOCATION
                                  ;ON STACK, "A1" (AFTER THE STRING)
    %END
          MOVE       P,BASE2      ;GET OLD STACK BASE
          MOVE   BASE2,1(P)       ;RESTORE PREVIOUS VALUE
          POPJ       P,0          ;RETURN
    TEST(1,VAR,R1,"TESTING")
          HRRZI     T2,5(P)       ;DESTINATION ADDRESS FOR "R1"
          HRLZI     T1,3(BASE1)   ;AND WHERE IT IS AT PRESENT
          HRR       T1,T2         ;SET UP "BLT" POINTER
          BLT       T1,1(T2)      ;AND DO THE BLOCK TRANSFER
          MOVEI      1,T1         ;GET THE ADDRESS OF "S"
          MOVE    ARG2,2(BASE1)   ;GET THE VALUE OF "VAR"
          HRRZI   ARG1,1          ;GET THE VALUE "1"
          PUSHJ      P,TEST       ;AND CALL THE ROUTINE
%ENDOFPROGRAM
          MOVE       P,BASE1      ;GET THE BASE ADDRESS
          MOVE   BASE1,1(P)       ;RESTORE THE PREVIOUS VALUE
          POPJ       P,0          ;RETURN TO RUNTIME SYSTEM
.END LITERAL
.TEST PAGE 6.S 2
THE STACK AT THE TIME OF THE RETURN FROM THE ROUTINE <TEST LOOKS AS FOLLOWS:-
.LITERAL

BASE2-> | return address |  0 (relative addresses)
        | old stack base |  1
        |    N           |  2
        |    M           |  3
        |  R_I1          |  4
        |  R_I2          |  5
        |  string        |  6
        |    S           |  .
        |    .           |  .
        |    .           |  .
        |    A1          | 106
        |    A2          | 107
        |    A3          | 110
    P-> |                | 111
.END LITERAL
.S 2
.INDEX PROCEDURE PARAMETERS
^&^PROCEDURE PARAMETERS\&
.S
 ^THIS PARAMETER TYPE IS PASSED AS THE ADDRESS OF AN ARGUMENT BLOCK ON THE STACK
WHICH CONTAINS THE ADDRESS OF THE PROCEDURE AND THE FUTURE CONTEXT FOR THAT
PROCEDURE (I.E. THE STACK BASE REGISTERS). ^WHEN THE PROCEDURE IS CALLED,
THE CURRENT CONTEXT IS EXCHANGED FOR THE CONTEXT IN THE ARGUMENT BLOCK
BEFORE THE PROCEDURE IS ENTERED. ^UPON RETURN, THE CONTEXTS ARE EXCHANGED
BACK BEFORE CONTROL IS RETURNED.
 ^THE ARGUMENT BLOCK WHICH IS SET UP LOOKS LIKE THIS:-
.LITERAL

 | procedure entry address  | 0 (relative addresses)
 | return address to caller | 1
 |  base1                   | 2
 |  base2                   | 3
 |  base3                   | 4
 |  base4                   | 5
 |  base5                   | 6

.END LITERAL
.PAGE
.INDEX MACHINE CODE BLOCKS
^&^USE OF MACHINE CODE\&
.S
 ^BLOCKS OF MACHINE CODE CAN BE PLANTED IN-LINE IN A PROGRAM BY
PRECEDING THE OCTAL INSTRUCTIONS WITH AN ASTERISK. ^SPACES ARE NOT SIGNIFICANT
AND CAN BE USED TO SEPARATE FIELDS.
.NF.NAP.S
E.G.
.S
THE FOLLOWING CODE PERFORMS THE IMP FUNCTION
   ANSWER = REM(NUMBER,10)*12
.S
   AC(1)=NUMBER
   *8__231040 000012;   !IDIVI 1,_^<D10   REMAINDER IN AC(2)
   *8__221100 000014;   !IMULI 2,_^<D12
   ANSWER=AC(2)
.SUBTITLE                              ^^^&APPENDIX E\\\&
.PAGE
.INDEX <ASCII CHARACTER SET
.TS 8,15,23,29,38,43,52
.FLAG CAP.LC.NAP.NF
^&<ASCII CHARACTER SET\&
.S
^^OCT DEC CHAR  OCT DEC  CHAR  OCT DEC CHAR  OCT DEC  CHAR\\
.S
 0  0	<NUL	40 32	<SPACE	100 64	@	140  96	grave
 1  1	<SOH	41 33	!	101 65	^A	141  97	a
 2  2	<STX	42 34	"	102 66	^B	142  98	b
 3  3	<ETX	43 35	_#	103 67	^C	143  99	c
 4  4	<EOT	44 36	$	104 68	^D	144 100	d
 5  5	<ENQ	45 37	%	105 69	^E	145 101	e
 6  6	<ACK	46 38	_&	106 70	^F	146 102	f
 7  7	<BEL	47 39	'	107 71	^G	147 103	g
.S
10  8	<BS	50 40	(	110 72	^H	150 104	h
11  9	<HT	51 41	)	111 73	^I	151 105	i
12 10	<LF	52 42	*	112 74	^J	152 106	j
13 11	<VT	53 43	+	113 75	^K	153 107	k
14 12	<FF	54 44	,	114 76	^L	154 108	l
15 13	<CR	55 45	-	115 77	^M	155 109	m
16 14	<SO	56 46	.	116 78	^N	156 110	n
17 15	<SI	57 47	/	117 79	^O	157 111	o
.S
20 16	<DLE	60 48	0	120 80	^P	160 112	p
21 17	<DC1	61 49	1	121 81	^Q	161 113	q
22 18	<DC2	62 50	2	122 82	^R	162 114	r
23 19	<DC3	63 51	3	123 83	^S	163 115	s
24 20	<DC4	64 52	4	124 84	^T	164 116	t
25 21	<NAK	65 53	5	125 85	^U	165 117	u
26 22	<SYN	66 54	6	126 86	^V	166 118	v
27 23	<ETB	67 55	7	127 87	^W	167 119	w
.S
30 24	<CAN	70 56	8	130 88	^X	170 120	x
31 25	<EM	71 57	9	131 89	^Y	171 121	y
32 26	<SUB	72 58	:	132 90	^Z	172 122	z
33 27	<ESC	73 59	;	133 91	[	173 123	{
34 28	<FS	74 60	_<	134 92	_\	174 124	|
35 29	<GS	75 61	=	135 93	]	175 125	}
36 30	<RS	76 62	>	136 94	_^	176 126	~
37 31	<US	77 63	?	137 95	__	177 127	<DEL
.SUBTITLE                               ^^^&APPENDIX F\\\&
.PAGE
.INDEX LIBRARY PROCEDURES
.INDEX SYSTEM LIBRARY
.INDEX I/O PROCEDURES
.INDEX STREAMS
.INDEX FILE SYSTEM
.INDEX <DA FILES
.INDEX ^DIRECT ^ACCESS FILES
.INDEX ^SEQUENTIAL ^FILES
.NAP.UC.NF.TS 10,40
^&^RELATED LIBRARY PROCEDURES\&
.S
INPUT/OUTPUT PROCEDURES
.S
	INPUT	OUTPUT
	INPUT PENDING	NEWLINE
	NEXT ITEM	NEWLINES
	NEXT SYMBOL	NEWPAGE
	READ	PRINT
	READ HEX	PRINT FL
	READ ITEM	PRINT STRING
	READ OCTAL	PRINT SYMBOL
	READ STRING	PROMPT
	READ SYMBOL	REPORT
	READ TEXT	SPACE
	SKIP SYMBOL	SPACES
		WRITE
		WRITE HEX
		WRITE OCTAL
STREAM DEFINITION ROUTINES
.S
	CHECKPOINT
	CLOSE INPUT	CLOSE OUTPUT
	DEFINE INPUT	DEFINE OUTPUT
	INDEV	OUTDEV
	INSTATUS	OUTSTATUS
	INSTREAM	OUTSTREAM
	RESET INPUT	RESET OUTPUT
	SDEF INPUT	SDEF OUTPUT
	SELECT INPUT	SELECT OUTPUT
	USET INPUT	USET OUTPUT
	XDEFINE INPUT	XDEFINE OUTPUT
.S
FILE SYSTEM UTITLITIES
.S
	COPY	XCOPY
	CUSP FILES
	DEFAULT
	DELETE	XDELETE
	ECHO	NOECHO
	FSTOSTR	STRTOFS
	ISFILE	XISFILE
	JOBFILE
	READ FS	WRITE FS
	READ PPN	WRITE PPN
	RENAME	XRENAME
	SET STREAMS
.S
DIRECT ACCESS/SEQUENTIAL FILE ROUTINES
.S
	CLOSE DA	CLOSE SQ
	OPEN DA	OPEN SQ
	READ DA	READ SQ
	WRITE DA	WRITE SQ
	XOPEN DA	XOPEN SQ
.S
.INDEX TYPE CONVERSION
.INDEX ARITHMETIC
.INDEX JOB RELATED INFORMATION
TYPE CONVERSION PROCEDURES
.S
	INTTOSTR	STRTOINT
	HEXTOSTR	STRTOHEX
	OCTTOSTR	STRTOOCT
	BINTOSTR
	SIXTOSTR	STRTOSIX
	FSTOSTR	STRTOFS
.S
MAPS
.S
	BYTEINTEGER
	INTEGER
	REAL
	RECORD
	SHORTINTEGER
	STRING
.S
STRING PROCEDURES
.S
	CHARNO
	SUBSTRING
	LENGTH
	MATCH
	NEXT ITEM
	READ ITEM
	TO STRING
.S
ARITHMETIC
.S
	FLOAT
	FRAC PT
	IMOD
	INT
	INT PT
	MOD
	PI
	REM
	SHIFTC
.S
JOB RELATED INFORMATION
.S
	CPUTIME
	DAY
	DATE
	DATETIME
	JOBNUM
	PPN
	TIME
.FLAGS CAP
.SUBTITLE                              ^^^&APPENDIX G\\\&
.PAGE
.INDEX SYSTEM LIBRARY PROCEDURES
.LC.NAP.NOFILL;.TS 13,33
^&SYSTEM LIBRARY PROCEDURES\&
.S
NAME	CLASS TYPE	PARAMETERS
.S
<ACCPER	EXT %INTEGERFN	%INTEGER UDT
<ADDR	    %INTEGERFN	%NAME X
<ASCTOSTR	EXT %STRING(255)%FN	%NAME ADR
<BINTOSTR	EXT %STRING(36)%FN	%INTEGER NUM
<BLT	SYS %ROUTINE	%NAME FROM,TO %INTEGER LEN
<BYTEINTEGER	    %BYTEINTEGERMAP	%INTEGER ADR
<CALL(0-9)	EXT %ROUTINE	%NAME RTN, ...
<CALLI1	EXT %ROUTINE	%INTEGER N %INTEGERNAME AC
<CALLI2	EXT %PREDICATE	%INTEGER N %INTEGERNAME AC
<CALLI3	EXT %PREDICATE	%INTEGER N %INTEGERNAME AC
<CHARNO	    %BYTEINTEGERFN	%STRINGNAME S %INTEGER N
<CHECKPOINT	EXT %ROUTINE
<CLOSE	SYS %ROUTINE	%INTEGER CHAN
<CLOSE <DA	EXT %ROUTINE	%INTEGER CHAN
<CLOSE <INPUT	    %ROUTINE
<CLOSE <OUTPUT	    %ROUTINE
<CLOSE <SQ	EXT %ROUTINE	%INTEGER CHAN
<COPY	EXT %ROUTINE	%STRING(255) ORIG,NEW
<CPUTIME	EXT %INTEGERFN
<CUSP <FILES	EXT %ROUTINE	%RECORD(FILESPEC)%NAME R,S,
	    	T,U %INTEGER CHAN,
	    	%INTEGERNAME FOUND
<DATE	EXT %STRING(9)%FN
<DATETIME	EXT %STRING(18)%FN
<DATETOSTR	EXT %STRING(9)%FN	%INTEGER DATE
<DAY	EXT %STRING(9)%FN
<DAYTOSTR	EXT %STRING(9)%FN	%INTEGER UDT
<DDT	SYS %ROUTINE	%NAME X
<DECODE	EXT %ROUTINE	%INTEGER INST,ADR
<DEFAULT	EXT %ROUTINE	%RECORD(FILESPEC)%NAME F,F1
<DEFINE <INPUT	    %ROUTINE	%INTEGER N %STRING(255) S
^^DEFINE OUTPUT\\    %ROUTINE	%INTEGER N %STRING(255) S
<DELETE	EXT %ROUTINE	%STRING(255) SPEC
<ECHO	EXT %ROUTINE
<ENDOFPERIOD	EXT %INTEGERFN	%INTEGER PERIOD
<ESC	    %CONSTINTEGER
<EVENT	    %INTERGERFN
<EVENT <INFO	    %INTEGERFN
<FF	    %CONSTINTEGER
<FILOP	SYS %PREDICATE	%RECORD(SCB)%NAME R,
	    	%INTEGERNAME ERR
<FINIT	SYS %ROUTINE
<FLOAT	    %REALFN	%INTEGER N
<FRAC <PT	    %LONGREALFN	%LONGREAL A
<FREEVEC	SYS %ROUTINE	%INTEGER ADR,LEN
<FROMDATE	EXT %ROUTINE	%INTEGER DATE,
	    	%INTEGERNAME D,M,Y
<FROMTIME	EXT %ROUTINE	%INTEGER TIME,
	    	%INTEGERNAME H,M,S
<FROMUDT	EXT %ROUTINE	%INTEGER UDT,
	    	%INTEGERNAME DATE,TIME
<FSTOSTR	EXT %STRING(255)%FN	%RECORD(FILESPEC)%NAME FS
<GET <CHANNEL	SYS %INTEGERFN
<GETDATE	EXT %INTEGERFN
<GETNOW	EXT %INTEGERFN
<GETPAGES	SYS %ROUTINE	%INTEGER FIRST,LAST
<GETSEG	EXT %ROUTINE	%STRING(6) DEV,FILE,
	    	%STRING(3) EXT %INTEGER PPN
<GETSTS	SYS %INTEGERFN	%INTEGER CHAN
<GETTAB	SYS %PREDICATE	%INTEGER TABLE,INDEX,
	    	%INTEGERNAME RESULT
<GETTIME	EXT %INTEGERFN
<GETVEC	SYS %INTEGERFN	%INTEGER SIZE
<HEXTOSTR	EXT %STRING(9)%FN	%INTEGER N
<ICALL(0-9)	EXT %INTEGERFN	%NAME FN, ...
<IMOD	    %INTEGERFN	%INTEGER N
<INDEV	EXT %INTEGERFN
<INITFOR	SYS %ROUTINE
<INITHEAP	SYS %ROUTINE
<INITIO	SYS %ROUTINE
<INITSTACK	SYS %ROUTINE
<INPUT	SYS %ROUTINE
^^INPUT PENDING\\    %PREDICATE
<INSTATUS	EXT %INTEGERFN
<INSTREAM	    %INTEGERFN
<INT	    %INTEGERFN	%LONGREAL A
<INTEGER	    %INTEGERMAP	%INTEGER ADR
<INT <PT	    %INTEGERFN	%LONGREAL A
<INTTOSTR	EXT %STRING(12)%FN	%INTEGER N
<IOUUO	SYS %PREDICATE	%INTEGER FN,CHAN,
	    	%NAME ADR
<IOWD	SYS %INTEGERFN	%INTEGER LEN,
	    	%INTEGERNAME ADR
<ISFILE	EXT %PREDICATE	%STRING(255) SPEC
<JOBFILE	EXT %STRING(6)%FN	%STRING(3) S
<JOBNUM	EXT %INTEGERFN
<JSYS(0-4)	EXT %ROUTINE	%INTEGER N %INTEGERNAME ...
<LENGTH	    %BYTEINTEGERFN	%STRINGNAME S
<MATCH	EXT %INTEGERFN	%STRINGNAME SRC,
	    	%STRING(255) TARGET
<MOD	    %LONGREALFN	%LONGREAL A
<NEWLINE	    %ROUTINE
<NEWLINES	    %ROUTINE	%INTEGER N
<NEWPAGE	    %ROUTINE
<NEXT <ITEM	    %STRING(1)%FN
<NEXT <SYMBOL	    %INTEGERFN
<NL	    %INTEGERFN
<NOECHO	EXT %ROUTINE
<OCTTOSTR	EXT %STRING(12)%FN	%INTEGER N
<OPEN <DA	EXT %ROUTINE	%INTEGER CHAN,
	    	%STRING(255) SPEC
<OPEN <SQ	EXT %ROUTINE	%INTEGER CHAN,
	    	%STRING(255) SPEC
<OUTDEV	EXT %INTEGERFN
<OUTPUT	SYS %ROUTINE
<OUTSTATUS	EXT %INTEGERFN
<OUTSTREAM	    %INTEGERFN
<PI	    %CONSTLONGREAL
<PPN	EXT %INTEGERFN
<PRINT	    %ROUTINE	%LONGREAL A %INTEGER N,M
<PRINT <FL	    %ROUTINE	%LONGREAL A %INTEGER N
<PRINT <STRING	    %ROUTINE	%STRING(255) S
<PRINT <SYMBOL	    %ROUTINE	%INTEGER N
<PROMPT	EXT %ROUTINE	%STRING(255) S
<RAD50	EXT %INTEGERFN	%STRING(6) S
<RCALL(0-9)	EXT %REALFN	%NAME FN, ...
<READ	    %ROUTINE	%NAME A
<READ <DA	EXT %ROUTINE	%INTEGER CHAN,
	    	%INTEGERNAME BLOCK,
	    	%NAME START,END
<READ <FS	EXT %ROUTINE	%RECORD(FILESPEC)%NAME FS
<READ <HEX	EXT %ROUTINE	%INTEGERNAME N
<READ <ITEM	    %ROUTINE	%STRINGNAME S
<READ <OCTAL	EXT %ROUTINE	%INTEGERNAME N
<READ <PPN	EXT %ROUTINE	%INTEGERNAME PPN
<READ <SQ	EXT %ROUTINE	%INTEGER CHAN,
	    	%NAME START,END
<READ <STRING	    %ROUTINE	%STRINGNAME S
<READ <SYMBOL	    %ROUTINE	%NAME N
<READ <TEXT	    %ROUTINE	%STRINGNAME S,
	    	%INTEGER DELIM
<REAL	    %REALMAP	%INTEGER ADR
<RECORD	    %RECORDMAP	%INTEGER ADR
<RELEASE	SYS %ROUTINE	%INTEGER CHAN
<REM	    %INTEGERFN	%INTEGER N,M
<RENAME	EXT %ROUTINE	%STRING(255) ORIG,NEW
<REPORT	EXT %ROUTINE	%STRING(255) S
<RESET <INPUT	EXT %ROUTINE
<RESET <OUTPUT	EXT %ROUTINE
<RESTORE	EXT %ROUTINE
<RUN	EXT %ROUTINE	%STRING(6) DEV,FILE,
	    	%STRING(3) EXT,
	    	%INTEGER PPN,OFFSET
<SAVE <ACS	EXT %ROUTINE
<SDEF <INPUT	EXT %ROUTINE	%INTEGER N %STRINGNAME S
<SDEF <OUTPUT	EXT %ROUTINE	%INTEGER N %STRINGNAME S
<SELECT <INPUT	    %ROUTINE	%INTEGER N
<SELECT <OUTPUT    %ROUTINE	%INTEGER N
<SET <STREAMS	EXT %ROUTINE
<SETSTS	SYS %ROUTINE	%INTEGER CHAN,BITS
<SHIFTC	EXT %INTEGERFN	%INTEGER NUM,TIMES
<SHORTINTEGER	    %SHORTINTEGERMAP	%INTEGER ADR
<SKIP <SYMBOL	    %ROUTINE
<SLEEP	EXT %ROUTINE	%INTEGER N
<SP	    %CONSTINTEGER
<SPACE	    %ROUTINE
<SPACES	    %ROUTINE	%INTEGER N
^^STARTOFPERIOD\\EXT %INTEGERFN	%INTEGER PERIOD
<STRING	    %STRINGMAP	%INTEGER ADR
<STRTOASC	EXT %ROUTINE	%STRINGNAME S,
	    	%NAME ADR
<STRTOFS	EXT %RECORD(FILESPEC)%FN	%STRING(255) SPEC
<STRTOHEX	EXT %INTEGERFN	%STRINGNAME S
<STRTOINT	EXT %INTEGERFN	%STRINGNAME S
<STRTOOCT	EXT %INTEGERFN	%STRINGNAME S
<STRTOSIX	EXT %INTEGERFN	%STRING(6) S
<SUBEVENT	    %INTEGERFN
<SUB <STRING	    %STRING(255)%FN	%STRINGNAME S %INTEGER N,M
<SWITCH <ARG	EXT %PREDICATE	%STRING(255)%NAME S,
	    	%STRING(11) TARGET,
	    	%NAME ARG
<TAB	    %CONSTINTEGER
<TAPOP	SYS %PREDICATE	%INTEGER FUNCT,CHAN,NARGS,
	    	%INTEGERARRAYNAME ARGS,
	    	%INTEGERNAME RESULT
<TIME	EXT %STRING(8)%FN
<TIMETOSTR	EXT %STRING(8)%FN	%INTEGER TIME
<TMPCOR	SYS %ROUTINE	%INTEGER N,IOWD,FILE
<TODATE	EXT %INTEGERFN	%INTEGER D,M,Y
<TOSTRING	    %STRING(1)%FN	%INTEGER N
<TOTIME	EXT %INTEGERFN	%INTEGER H,M,S
<TOUDT	EXT %INTEGERFN	%INTEGER DATE,TIME
<UDTTOSTR	EXT %STRING(18)%FN	%INTEGER UDT
<USET <INPUT	EXT %ROUTINE	%INTEGER BLOCK
<USET <OUTPUT	EXT %ROUTINE	%INTEGER BLOCK
<WRITE	    %ROUTINE	%INTEGER N,M
<WRITE <DA	EXT %ROUTINE	%INTEGER CHAN,
	    	%INTEGERNAME BLOCK,
	    	%NAME START,END
<WRITE <FS	EXT %ROUTINE	%RECORD(FILESPEC)%NAME FS
<WRITE <HEX	EXT %ROUTINE	%INTEGER N,M
<WRITE <OCTAL	EXT %ROUTINE	%INTEGER N,M
<WRITE <PPN	EXT %ROUTINE	%INTEGER PPN
<WRITE <SQ	EXT %ROUTINE	%INTEGER CHAN,
	    	%NAME START,END
<XCOPY	EXT %ROUTINE	%RECORD(FILESPEC)%NAME F,F1
^^XDEFINE INPUT\\    %ROUTINE	    %INTEGER N,
		%RECORD(FILESPEC)%NAME FS
^^XDEFINE OUTPUT\\   %ROUTINE	    %INTEGER N,
		%RECORD(FILESPEC)%NAME FS
<XDELETE	EXT %ROUTINE	%RECORD(FILESPEC)%NAME FS
<XISFILE	EXT %PREDICATE	%RECORD(FILESPEC)%NAME FS
<XOPEN <DA	EXT %ROUTINE	%INTEGER CHAN,
	    	%RECORD(FILESPEC)%NAME FS
<XOPEN <SQ	EXT %ROUTINE	%INTEGER CHAN,
	    	RECORD(FILESPEC)%NAME FS
<XRENAME	EXT %ROUTINE	%RECORD(FILESPEC)%NAME F,F1
<ZERO	SYS %ROUTINE	%NAME FROM,TO

.SUBTITLE                              ^^^&APPENDIX H\\\&
.PAGE
.INDEX ERROR CODES
.INDEX %<EVENTS
.INDEX %<SIGNAL %<EVENT
.NAP;.TS 2,54
^&^RUNTIME ERROR CODES\&
.F.S 1
<IMP ALLOWS THE USER TO TRAP ON ANY GIVEN CONDITION BY THE %<SIGNAL
%<EVENT MECHANISM, DESRIBED IN THE <IMP77 ^LANGUAGE ^REFERENCE ^MANUAL.
^THE RUNTIME SYSTEM USES THIS FEATURE TO SIGNAL THAT ERRORS HAVE TAKEN PLACE
IN THE RUNTIME SYSTEM OR SYSTEM LIBRARY WHICH IT CANNOT SENSIBLY
RECOVER FROM. ^BELOW IS THE FULL LIST OF THESE %<EVENTS, WHOSE FORMAT IS AS FOLLOWS:-
.S
^THE MAIN EVENTS TOGETHER WITH THE TYPE OF EVENT THEY SIGNAL, ARE
GIVEN AT THE HEAD OF EACH SECTION. ^FOLLOWING THEM IN NUMERIC ORDER
ARE THE SUB-EVENTS WHICH HAVE ASSOCIATED WITH THEM
A MESSAGE HELD IN THE GLOBAL STRING <ERRMSG AND ALSO AN
INTEGER CONTAINING EXTRA INFORMATION, THE MEANING OF WHICH IS GIVEN IN
THE RIGHT-HAND COLUMN.
.S
E.G. AN END-OF-FILE CONDITION ON INPUT STREAM 4, IF NOT
TRAPPED BY THE USER, WOULD RESULT IN THE FOLLOWING MESSAGE
BEING OUTPUT ON THE USERS CONSOLE:-
.S.NF
<EOF ON STREAM
%<SIGNAL 9,0,4
.S 2
^EVENT  0, . . ^TERMINATION
.S
	-1 ^ABORT
	#0 NORMAL STOP
	>0
.S
^EVENT  1, . . ^ARITHMETIC OVERFLOW
.S
	#1 ^INTEGER TOO LARGE
	   ^INTEGER TOO LARGE FOR SHORT OR BYTE INTEGER	N
.S
^EVENT  2, .. ^EXCESS RESOURCE
.S
	#1 ^CANNOT GET STORE	FAULT
	   ^STACK SPACE FULL	FAULT
	#2 ^PROCEDURE STACK FULL
	#3
	#4 ^CANNOT GET STORE FOR HEAP	SIZE
	   ^HEAP SPACE FULL	REQD.
	#5 ^ALL <I/O CHANNELS IN USE
	   ^NO FREE CHANNELS FOR ^^COPY\\ING 'FILESPEC'
	#6 ^ARRAY SPACE EXHAUSTED
.S
^EVENT  3, ..  ^DATA ERROR
.S
	#1 ^NUMBER NOT FOUND	SYMBOL
	   ^INTEGER NOT FOUND	SYMBOL
	   ^OCTAL INTEGER NOT FOUND	SYMBOL
	   ^HEX INTEGER NOT FOUND	SYMBOL
	#2 ^NO OPENING STRING QUOTE	SYMBOL
.S
^EVENT  4, .. ^CORRUPT DATA
.S
	#1 ^INPUT ERROR STATUS _#NNNNNN	STR/CH
	   ^OUTPUT ERROR STATUS _#NNNNNN	STR/CH
	   (^SEE ^^DEC\\SYSTEM-10 ^MONITOR ^CALLS ^MANUAL
	    FOR MEANING OF THE STATUS BITS)
.S
^EVENT  5, .. ^INVALID ARGUMENTS
.S
	#1
	#2
	#3
	#4
	#5
	#6 ^ILLEGAL %NAME TYPE PARAMETER	TYPE
	#7 ^ILLEGAL STRING INDEX	INDEX
	#8 ^STRING PARAMETERS INSIDE OUT
	#9 ^INCORRECT ARGUMENT FOR SWITCH /....	ARG
	10 ^UNKNOWN SWITCH /'SWITCH'
.S
^EVENT  6, ..  ^OUT OF RANGE
.S
	#1 ^CONCATENATED STRING TOO LONG
	   ^STRING CAPACITY EXCEEDED
.S
^EVENT  7, ..  ^RESOLUTION FAILS
.S
	#0 ^RESOLUTION FAILS
.S
^EVENT  8, ..  ^UNASSIGNED VARIABLE
.S
^EVENT  9, ..  ^INPUT ENDED
.S
	#0 <EOF ON STREAM	STREAM
	   <EOF ON <DA OR <SQ CHANNEL	CHAN
.S 
	#1 ^NO INPUT ON STREAM	STREAM
	   (USED FOR NON-BLOCKING INPUT)
.S
^EVENT 10, ..  ^LIBRARY PROCEDURE ERROR
.S
	#1 ^DEFINING ILLEGAL STREAM/CHANNEL NUMBER	STR/CH
	#2 ^STREAM/CHANNEL ALREADY DEFINED	STR/CH
	#3 ^UNKNOWN DEVICE 'DEV'
	#4 ^LOOKUP ERROR FOR 'FILESPEC'	ERR*
	#5 ^ENTER ERROR FOR 'FILESPEC'	ERR*
	#6 ^CANNOT OPEN DEVICE 'DEV'
	   ^CANNOT OPEN DEVICE FOR 'FILESPEC'
	#7
	#8
	#9 ^BAD FILE SPECIFICATION 'FILESPEC'
	10 ^SELECTING ILLEGAL INPUT STREAM	STREAM
	11 ^SELECTING ILLEGAL OUTPUT STREAM	STREAM
	12 ^CANNOT <RESET INPUT STREAM	STREAM
	13 ^CANNOT <RESET OUTPUT STREAM	STREAM
	14 ^CHECKPOINT FAILURE	ERR*
	15 ^TAPOP FAILURE	T ERR
	   ('T ERR' IS A <TAPOP ERROR CODE - SEE ^MONITOR
	    ^CALLS ^MANUAL UNDER MAGNETIC TAPES)
	16 ^CANNOT <RENAME/DELETE 'FILESPEC'	ERR*
	17
	18
	19
	20 ^NOT A <DA OR <SQ TYPE DEVICE - 'DEV'
	21 ^CANNOT <OPEN <DA/SQ CHANNEL 'FILESPEC' ^ERROR:ERR*	CHAN
	22 ^^OPEN\\ING ALREADY OPEN <DA/SQ CHANNEL FOR 'FILESPEC' CHAN
	23 ^READ/WRITE TO ILLEGAL <DA/<SQ CHANNEL	CHAN
	   ^READ/WRITE TO <DA/<SQ CHANNEL BEFORE ^^OPEN\\ING IT	CHAN
	24 ^ACCESSING <DA CHANNEL BY <SQ ROUTINE OR VICE VERSA	CHAN
	25 ^STORAGE AREA FOR <DA/SQ ROUTINE INSIDE OUT	CHAN
	26 ^ILLEGAL BLOCK NUMBER FOR <DA READ/WRITE ROUTINE	BLOCK
	27 ^INPUTTING FROM AN <SQ CHANNEL SET FOR OUTPUT	CHAN
	   ^OUTPUTTING TO AN <SQ CHANNEL SET FOR INPUT	CHAN
	28 ^CLOSING ILLEGAL <DA/SQ CHANNEL	CHAN
	   ^CLOSING <DA/<SQ CHANNEL BEFORE ^^OPEN\\ING IT	CHAN
	   ^CLOSING <DA/SQ CHANNEL WITH THE WRONG ROUTINE	CHAN
.S 2
*
.F
THE EXTRA INFORMATION LABELED 'ERR' REFERS TO AN ERROR CODE
GIVEN IN ^APPENDIX ^E OF THE ^MONITOR ^CALLS ^MANUAL. ^HOWEVER THE
MOST COMMON VALUES ARE:-
.NF
0 - FILE NOT FOUND
1 - INCORRECT PROJECT-PROGRAMMER NUMBER
2 - PROTECTION FAILURE
.SUBTITLE                             ^^^^&INDEX\\\&
.PAGE
.DO INDEX
$$$$$$$$$$$$
&&&&&&&&&&&& 3B35D.RNO

.ps 60,64
.t3B35D
3B35D#####################################################Page#1
##########################################################Nov 78
.st                                                           Nov 78
.nap
.s10
.c;THE IMP LIBRARY MANUAL
.s4
.FLAG CAP
.FLAG CAP;.LC
.F.S
 ^THIS DOCUMENT DESCRIBES FULLY THE <IMP ^SYSTEM ^LIBRARY FACILITIES.
^IT IS PART OF A SET OF TWO DOCUMENTS WHICH DESCRIBE THE <IMP ^LANGUAGE ON
THE ^^DEC\\SYSTEM-10/20 COMPUTERS.
^THE OTHER DOCUMENT IS:-
.NAP.NF.S
^^3B35C####IMP ON THE DEC\\SYSTEM-10/20
.S
 ^THE ^LANGUAGE DEFINITION CONTAINED ALSO SEPARATELY IN:-
.S
^^3B35B####THE IMP-77 LANGUAGE REFERENCE MANUAL.
.S 2
^OTHER MANUALS REFERRED TO IN THIS DOCUMENT ARE:-
.S
   ^D^E^CSYSTEM-10 ^OPERATING ^SYSTEM ^COMMANDS ^MANUAL.
   ^D^E^CSYSTEM-10 ^MONITOR ^CALLS ^MANUAL. 
   ^D^E^CSYSTEM-10 ^HARDWARE ^REFERENCE ^MANUAL. 
.nf
.s2
			^^CONTENTS\\				   page	
.s2
1##^^LIBRARY ENTRIES\\  .. .. .. ..  .. .. .. .. .. .. .. .. .. 2
.s
2##^^DATE-TIME FORMATS\\ .. .. .. .. .. .. .. .. .. .. .. .. .. 107
.s
3##^^DEFINITION OF THE FILE SPECIFICATION RECORD\\  .. .. .. .. 108
.s
4##^^SYSTEM LIBRARY PROCEDURES SUMMARY\\   .. .. .. .. .. .. .. 109
.s
^^INDEX OF LIBRARY PROCEDURES\\   .. .. .. .. .. .. .. .. .. .. 113
.page
.f
.LM 8;.TS 8 16


.S 4;.TEST PAGE 20;.NAP;.F
.i-8
1. ^^LIBRARY ENTRIES\\
.S2
.c
^^ACCPER\\
.INDEX ^^ACCPER\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION RETURNS THE VALUE OF THE ACCOUNTING
PERIOD INTO WHICH THE GIVEN TIME FALLS.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^ACCPER\\(%<INTEGER UDT)
.P
<USE:	PERIOD=^^ACCPER\\(UDT)
.LM 16;.F;.S 1

.I-8
UDT	IS AN INTEGER EXPRESSION BEING THE DATE-TIME IN QUESTION, GIVEN
IN THE <DEC UNIVERSAL DATE-TIME FORMAT.
.LM 8;.S 1
THE ACCOUNTING PERIOD OF THE GIVEN DATE IS RETURNED AS A FOUR
DIGIT INTEGER OF THE FORM <YYMM, VIA %<RESULT.
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, TO DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TO TIME, TIMETOSTR,
DATETIME, GET NOW, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20.;.NAP;.F;.C
^^ADDR\\
.INDEX ^^ADDR\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE ABSOLUTE ADDRESS OF
A %<NAME VARIABLE.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^ADDR\\(X)
.LM 16;.F;.S 1

.I-8
X	IS THE NAME OF A VARIABLE WHOSE ADDRESS IS REQUIRED.
.LM 8;.S 1
^THE ABSOLUTE ADDRESS OF X IS RETURNED VIA %<RESULT
.UC.F.P
<ASSOCIATED <PROCEDURES: BYTE INTEGER, SHORT INTEGER, INTEGER,
REAL, STRING, RECORD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^ASCTOSTR\\
.INDEX ^^ASCTOSTR\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION CONVERTS AN <ASCIZ STRING
TO AN <IMP STRING.
.NF;.P
<SPEC:	%<EXTERNALSTRING(255)%FN ^^ASCTOSTR\\(%<<NAME ADR)
.P
<USE:	S=^^ASCTOSTR\\(ADR)
.LM 16;.F;.S 1

.I-8
ADR	IS THE NAME OF A VARIABLE CONTAINING THE START OF THE <ASCIZ STRING
.LM 8;.S 1
AN <ASCIZ TYPE STRING (7-BIT BYTES, TERMINATED BY A ZERO BYTE) IS
CONVERTED TO AN <IMP TYPE STRING AND RETURNED VIA %<RESULT.
.F.P.UC
<ASSOCIATED <PROCEDURES: STRTOASC
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^BINTOSTR\\
.INDEX ^^BINTOSTR\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION GIVES THE VALUE OF THE GIVEN NUMBER AS A STRING OF BINARY
DIGITS.
.NF;.P
<SPEC:	%<EXTERNALSTRING(36)%FN ^^BINTOSTR\\(%<INTEGER NUM)
.P
<USE:	S=^^BINTOSTR\\(NUM)
.LM 16;.F;.S 1

.I-8
NUM	IS AN INTEGER EXPRESSION WHICH IS TO BE CONVERTED TO BINARY.
.LM 8;.S 1
THE GIVEN INTEGER NUMBER IS RETURNED AS A STRING OF 36 BINARY
DIGITS WITH LEADING ZEROS.
.UC.F.P
<ASSOCIATED <PROCEDURES: OCTTOSTR, HEXTOSTR, INTTOSTR
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^BLT\\
.INDEX ^^BLT\\
.P-8
<DEFINITION: ^THIS ROUTINE COPIES DATA FROM ONE AREA OF STORE TO ANOTHER
EN BLOC.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^BLT\\(%<<NAME FROM,TO, %<INTEGER LEN)
.P
<CALL:	^^BLT\\(FROM,TO,LEN)
.LM 16;.F;.S 1

.I-8
FROM	IS THE NAME OF THE VARIABLE FROM WHICH DATA IS TO START BEING COPIED.
.I-8
TO	IS THE NAME OF THE VARIABLE TO WHICH DATA IS TO START BEING COPIED.
.I-8
LEN	IS AN INTEGER EXPRESSION BEING THE AMOUNT OF DATA TO BE COPIED.
.LM 8;.S 1
A BLOCK OF DATA OF LENGTH LEN, STARTING AT 'FROM',
IS COPIED TO ANOTHER AREA OF STORE STARTING AT 'TO'.
.UC.F.P
<ASSOCIATED <PROCEDURES: ZERO
.F.LC.P
<ERROR <CONDITIONS: FATAL ILLEGAL MEMORY REFERENCES MAY OCCUR IF ATTEMPTS ARE MADE
TO WRITE TO ADDRESSES OUTWITH THE CURRENT ADDRESSING SPACE.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^BYTE INTEGER\\
.INDEX ^^BYTE INTEGER\\
.P-8
<DEFINITION: ^THIS MAP ENABLES THE USER TO ACCESS DIRECTLY A PARTICULAR
BYTE WHOSE ADDRESS IS SPECIFIED.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^BYTE INTEGER\\(ADR)
.LM 16;.F;.S 1

.I-8
ADR	IS AN INTEGER EXPRESSION GIVING THE ADDRESS OF THE
REQUIRED LOCATION.
.LM 8;.S 1
^THIS MAP ALLOWS THE USER TO READ OR WRITE DIRECTLY TO A LOCATION
IN STORE BY SPECIFYING THE ABSOLUTE ADDRESS IN 'ADR'.
.UC.F.P
<ASSOCIATED <PROCEDURES: SHORT INTEGER, INTEGER, REAL,
STRING, RECORD
.F.LC.P
<ERROR <CONDITIONS: ^IF THE VALUE OF 'ADR' LIES OUTSIDE THE CURRENT ADDRESSING SPACE THE
FOLLOWING FATAL ERROR WILL OCCUR:-
.NF.S
?<IMP: ^ILL ^MEM ^REF AT USER PC  'ADDR'



.S 4;.TEST PAGE 20;.NAP;.F;.C
^^CALL (0-9)\\
.INDEX ^^CALL (0-9)\\
.P-8
<DEFINITION: ^THESE ROUTINES CALL THE <FORTRAN ROUTINE NAMED AS THE FIRST PARAMETER
WITH THE NECESSARY ARGUMENTS GIVEN AS THE SUCCEEDING PARAMETERS.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^CALL (0-9)\\(%<<NAME RTN, %<<NAME ARG1, .. %<<NAME ARG9)
.P
<CALL:	^^CALL (0-9)\\(RTN,ARG1, .. ARG9)
.LM 16;.F;.S 1

.I-8
RTN	IS THE NAME OF A EXTERNAL <FORTRAN ROUTINE.
^FOR EASE OF HANDLING, IT IS REQUIRED THAT THE SPEC GIVEN
IN THE <IMP PROGRAM IS THAT OF %<EXTERNALINTEGERSPEC.
.I-8
ARG1	IS THE NAME OF THE FIRST ARGUMENT IF ONE IS NEEDED
.I-8
AND SO ON UP TO
.I-8
ARG9	IS THE NAME OF THE NINTH ARGUMENT IF ONE IS NEEDED
.LM 8;.S 1
THESE ARE A SET OF <IMP ROUTINES CALLED <CALL0, <CALL1, ETC.
UP TO <CALL9. ^THE NUMBER REFERS TO THE NUMBER OF ARGUMENTS
WHICH THE <FORTRAN ROUTINE REQUIRES. ^SEE THE FOLLOWING EXAMPLE:-
.NF.UC.S.LIT
%BEGIN
%EXTERNALINTEGERSPEC FNOARG
      !A FORTRAN ROUTINE WITH NO ARGUMENTS
%EXTERNALINTEGERSPEC F3ARGS
      !A FORTRAN ROUTINE WITH THREE ARGUMENTS

%EXTERNALROUTINESPEC CALL0(%NAME RT)
%EXTERNALROUTINESPEC CALL3(%NAME RT, %NAME A,B,C)

%INTEGER ARG1,ARG2,ARG3

ARG1=1; ARG2=2; ARG3=3
CALL0(FNOARG);                 !CALL FORTRAN
CALL3(F3ARGS,ARG1,ARG2,ARG3);  !CALL FORTRAN

%ENDOFPROGRAM
.END LITERAL
.LC.F.S
^THE %<INCLUDE FILE "<IMP:FORTRA.INC" CONTAINS ALL THE SPECS FOR THE <CALL ROUTINES.
.UC.F.P
<ASSOCIATED <PROCEDURES: ICALL (0-9), RCALL (0-9)
.LC.P
<ERROR <CONDITIONS: ^DEPENDING ON THE <FORTRAN ROUTINE CALLED.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^CALLI1\\
.INDEX ^^CALLI1\\
.P-8
<DEFINITION: ^THIS ROUTINE PERFORMS THE ^^DEC\\SYSTEM-10 <CALLI ^MONITOR ^CALL FOR THE SIMPLE
CASE WHERE THE <CALLI HAS ONLY ONE RETURN ADDRESS.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^CALLI1\\(%<INTEGER NUM, %<INTEGER<NAME AC)
.P
<CALL:	^^CALLI1\\(NUM,AC)
.LM 16;.F;.S 1

.I-8
NUM	IS AN INTEGER EXPRESSION BEING THE <CALLI NUMBER.
.I-8
AC	IS THE NAME OF AN INTEGER VARIABLE CONTAINING ANY REQUIRED ARGUMENT
FOR THE ^MONITOR ^CALL AND IN WHICH ANY RESULT WILL BE RETURNED.
.LM 8;.S 1
^THE GIVEN <CALLI ^MONITOR ^CALL IS PERFORMED WITH THE LOCATION
REQUIRED FOR EITHER THE ARGUMENT, RESULT OR BOTH.
^THE FORM OF ARGUMENT AND RESULT VARIES FROM
ONE <CALLI TO ANOTHER, AND THE USER MUST READ THE ^^DEC\\SYSTEM-10
<MONITOR <CALLS ^MANUAL, FOR THE APPROPRIATE VALUES. ^IT SHOULD BE NOTED
THAT THIS ROUTINE SHOULD ONLY BE USED FOR
THOSE <CALLIS WHICH HAVE ONLY ONE <RETURN ADDRESS.
.S.NF
E.G.   <PJOB  (<CALLI 30)
.UC.F.P
<ASSOCIATED <PROCEDURES: CALLI2, CALLI3
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^CALLI2\\
.INDEX ^^CALLI2\\
.P-8
<DEFINITION: ^THIS PREDICATE PERFORMS THE ^^DEC\\SYSTEM-10 <CALLI ^MONITOR ^CALL FOR THE USUAL
CASE WHERE THE <CALLI HAS AN NORMAL SKIP RETURN AND A NON-SKIP ERROR RETURN.
.NF;.P
<SPEC:	%<EXTERNALPREDICATE ^^CALLI2\\(%<INTEGER NUM, %<INTEGER<NAME AC)
.P
<USE:	%<IF ^^CALLI2\\(NUM,AC) %<THEN ...
.LM 16;.F;.S 1

.I-8
NUM	IS AN INTEGER EXPRESSION BEING THE <CALLI NUMBER.
.I-8
AC	IS THE NAME OF AN INTEGER VARIABLE CONTAINING ANY REQUIRED ARGUMENT
FOR THE ^MONITOR ^CALL AND IN WHICH ANY RESULT WILL BE RETURNED.
.LM 8;.S 1
^THE GIVEN <CALLI ^MONITOR ^CALL IS PERFORMED WITH THE LOCATION
REQUIRED FOR EITHER THE ARGUMENT, RESULT OR BOTH.
^THE PREDICATE RETURNS A VALUE %<TRUE WHEN THE NORMAL SKIP RETURN
IS TAKEN FROM THE ^MONITOR ^CALL AND A VALUE %<FALSE OTHERWISE.
^THE FORM OF ARGUMENT AND RESULT VARIES FROM ONE <CALLI TO ANOTHER,
AND THE USER MUST READ THE ^^DEC\\SYSTEM-10
<MONITOR <CALLS ^MANUAL, FOR THE APPROPRIATE VALUES.
 ^IT SHOULD BE NOTED THAT THIS PREDICATE SHOULD ONLY BE USED FOR
THOSE <CALLIS WHICH HAVE THE NORMAL SKIP RETURN.
.UC.F.P
<ASSOCIATED <PROCEDURES: CALLI1, CALLI3
.F.LC.P
<ERROR <CONDITIONS: ^WHEN THE VALUE %<FALSE IS RETURNED, AN ERROR CODE
MAY BE RETURNED IN THE INTEGER 'AC'.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^CALLI3\\
.INDEX ^^CALLI3\\
.P-8
<DEFINITION: ^THIS PREDICATE PERFORMS THE ^^DEC\\SYSTEM-10 <CALLI ^MONITOR ^CALL FOR THE
CASE WHERE THE <CALLI HAS AN NORMAL NON-SKIP RETURN AND A SKIP ERROR RETURN.
.NF;.P
<SPEC:	%<EXTERNALPREDICATE ^^CALLI3\\(%<INTEGER NUM, %<INTEGER<NAME AC)
.P
<USE:	%<IF ^^CALLI3\\(NUM,AC) %<THEN ...
.LM 16;.F;.S 1

.I-8
NUM	IS AN INTEGER EXPRESSION BEING THE <CALLI NUMBER.
.I-8
AC	IS THE NAME OF AN INTEGER VARIABLE CONTAINING ANY REQUIRED ARGUMENT
FOR THE ^MONITOR ^CALL AND IN WHICH ANY RESULT WILL BE RETURNED.
.LM 8;.S 1
^THE GIVEN <CALLI ^MONITOR ^CALL IS PERFORMED WITH THE LOCATION
REQUIRED FOR EITHER THE ARGUMENT, RESULT OR BOTH.
^THE PREDICATE RETURNS A VALUE %<TRUE WHEN THE NORMAL SKIP RETURN
IS TAKEN FROM THE ^MONITOR ^CALL AND A VALUE %<FALSE OTHERWISE.
^THE FORM OF ARGUMENT AND RESULT VARIES FROM ONE <CALLI TO ANOTHER,
AND THE USER MUST READ THE ^^DEC\\SYSTEM-10
<MONITOR <CALLS ^MANUAL, FOR THE APPROPRIATE VALUES.
 ^IT SHOULD BE NOTED THAT THIS PREDICATE SHOULD ONLY BE USED FOR
THOSE <CALLIS WHICH HAVE THE NORMAL SKIP RETURN.
.UC.F.P
<ASSOCIATED <PROCEDURES: CALLI1, CALLI2
.F.LC.P
<ERROR <CONDITIONS: ^WHEN THE VALUE %<FALSE IS RETURNED, AN ERROR CODE
MAY BE RETURNED IN THE INTEGER 'AC'.

.S 4;.TEST PAGE 20.;.NAP;.F;.C
^^CHARNO\\
.INDEX ^^CHARNO\\
.P-8
<DEFINITION: ^THIS BYTEINTEGER FUNCTION GIVES THE VALUE OF THE
SPECIFIED SEVEN-BIT BYTE OF A GIVEN STRING.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	CH=^^CHARNO\\(S,N)
.LM 16;.F;.S 1

.I-8
S	IS THE NAME (OF TYPE %<STRING) OF THE GIVEN STRING.
.I-8
N	IS AN INTEGER EXPRESSION INDICATING WHICH CHARACTER OF THE
STRING IS TO BE RETURNED.
.LM 8;.S 1
^THE VALUE OF THE N'TH CHARACTER OF STRING S IS RETURNED AS A
SEVEN-BIT BYTE VIA %<RESULT.
.S
^IF N=0 THE STRING LENGTH IS RETURNED AS THE RESULT.
.B
^IF N_<0 OR N_>^^LENGTH\\(S) THEN ZERO IS RETURNED AS THE RESULT.
.UC.F.P
ASSOCIATED <PROCEDURES: LENGTH, SUB STRING, TO STRING
.F.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20.;.NAP;.F;.C
^^CHECKPOINT\\
.INDEX ^^CHECKPOINT\\
.P-8
<DEFINITION: ^THIS ROUTINE MAKES A PERMANENT COPY ON THE EXTERNAL MEDIUM
OF ALL THE OUTPUT DONE SO FAR ON THE CURRENTLY SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^CHECKPOINT\\
.P
<CALL:	^^CHECKPOINT\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^THE CURRENT OUTPUT STREAM IS CLOSED THEN REOPENED AND ALL POINTERS
RESET BACK TO THEIR PREVIOUS VALUES, SO THAT, TO THE USER THE STREAM IS
UNAFFECTED.
.S
^FOR NON-DISK DEVICES, NO ACTION IS TAKEN.
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)DEFINE OUTPUT, CLOSE OUTPUT, RESET OUTPUT
.LC.P
<ERROR <CONDITIONS: ^FOR A HARDWARE TRANSMISSION ERROR THE FOLLOWING EVENT OCCURS:-
.NF.S
%<SIGNAL 10, 14, N, "^CHECKPOINT FAILURE"
.S.F
^WHERE N IS AN ERROR CODE AS LISTED IN APPENDIX ^E OF THE ^^DEC\\SYSTEM-10
<MONITOR <CALLS ^MANUAL.

.S 4;.TEST PAGE 20.;.NAP;.F;.C
^^CLOSE\\
.INDEX ^^CLOSE\\
.P-8
<DEFINITION: ^THIS ROUTINE CLOSES THE GIVEN PHYSICAL CHANNEL NUMBER.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^CLOSE\\(%<INTEGER CHAN)
.P
<CALL:	^^CLOSE\\(CHAN)
.LM 16;.F;.S 1

.I-8
CHAN	IS AN INTEGER EXPRESSION GIVING THE PHYSICAL CHANNEL NUMBER OF
A CURRENTLY OPEN DEVICE.
.LM 8;.S 1
^THE DEVICE ASSOCIATED WITH THE GIVEN PHYSICAL CHANNEL NUMBER IS CLOSED
BUT NOT RELEASED.
 ^THE PHYSICAL CHANNEL NUMBER FOR A STREAM OR <DA/SQ CHANNEL IS FOUND
IN THE <SCB (^STREAM ^CONTROL ^BLOCK) FOR THAT STREAM OR CHANNEL.
(^SEE %<INCLUDE FILE <"IMP:IOLIB.INC" FOR A DESCRIPTION OF THE <SCB)
.UC.F.P
<ASSOCIATED <PROCEDURES: RELEASE, IOUUO, FILOP, TAPOP
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20.;.NAP;.F;.C
^^CLOSE DA\\
.INDEX ^^CLOSE DA\\
.P-8
<DEFINITION: ^THIS ROUTINE CLOSES THE DIRECT ACCESS FILE ON THE CHANNEL
SPECIFIED.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^CLOSE DA\\(%<INTEGER N)
.P
<CALL:	^^CLOSE DA\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION LYING IN THE RANGE 1 TO 15 WHICH
SPECIFIES THE CHANNEL NUMBER ASSOCIATED WITH A CURRENTLY OPEN DEVICE OR
FILE.
.LM 8;.S 1
^THE FILE OR DEVICE ASSOCIATED WITH THE GIVEN CHANNEL NUMBER IS CLOSED
AND CANNOT BE USED AGAIN WITHOUT RE-OPENING.
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)OPEN DA, READ DA, WRITE DA
.LC.P
<ERROR <CONDITIONS: ^UNLESS 1 _<= N _<= 15 THEN THE FOLLOWING EVENT OCCURS:-
.NF.S
%<SIGNAL  10, 28, N, "^CLOSING ILLEGAL <DA/SQ CHANNEL"
.F.S
^OR IF THE CHANNEL HAS NOT BEEN OPENED PREVIOUSLY:-
.NF.S
%<SIGNAL 10, 28, N "^CLOSING <DA/SQ CHANNEL BEFORE ^^OPEN\\ING IT"
.F.S
^IF THE CHANNEL IS NOT OF THE APPROPRIATE TYPE (I.E. AN <SQ CHANNEL)
THE FOLLOWING EVENT IS SIGNALED.
.NF.S
%<SIGNAL 10, 29, N, "^CLOSING <DA/SQ CHANNEL WITH THE WRONG ROUTINE"


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^CLOSE INPUT\\
.INDEX ^^CLOSE INPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE CLOSES THE CURRENTLY SELECTED INPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^CLOSE INPUT\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^THE CURRENTLY SELECTED INPUT STREAM IS CLOSED AND RESET TO BE A NULL
STREAM.
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)DEFINE INPUT, SDEF INPUT, SELECT INPUT
.LC.P
<ERROR <CONDITIONS: ^NONE


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^CLOSE OUTPUT\\
.INDEX ^^CLOSE OUTPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE CLOSES THE CURRENTLY SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^CLOSE OUTPUT\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^THE CURRENTLY SELECTED OUTPUT STREAM IS CLOSED AND RESET TO BE A NULL
STREAM.
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)DEFINE OUTPUT, SDEF OUTPUT, SELECT OUTPUT
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20.;.NAP;.F;.C
^^CLOSE SQ\\
.INDEX ^^CLOSE SQ\\
.P-8
<DEFINITION: ^THIS ROUTINE CLOSES THE SEQUENTIAL FILE ON THE CHANNEL
SPECIFIED.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^CLOSE SQ\\(%<INTEGER N)
.P
<CALL:	^^CLOSE SQ\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION LYING IN THE RANGE 1 TO 15 WHICH
SPECIFIES THE CHANNEL NUMBER ASSOCIATED WITH A CURRENTLY OPEN DEVICE OR FILE.
.LM 8;.S 1
^THE FILE OR DEVICE ASSOCIATED WITH THE GIVEN CHANNEL NUMBER IS CLOSED
AND CANNOT BE USED AGAIN WITHOUT RE-OPENING.
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)OPEN SQ, READ SQ, WRITE SQ
.LC.P
<ERROR <CONDITIONS: ^UNLESS 1 _<= N _<= 15 THEN THE FOLLOWING EVENT OCCURS:-
.NF.S
%<SIGNAL  10, 28, N, "^CLOSING ILLEGAL <DA/SQ CHANNEL"
.F.S
^OR IF THE CHANNEL HAS NOT BEEN OPENED PREVIOUSLY:-
.NF.S
%<SIGNAL 10, 28, N "^CLOSING <DA/SQ CHANNEL BEFORE ^^OPEN\\ING IT"
.F.S
^IF THE CHANNEL IS NOT OF THE APPROPRIATE TYPE (I.E. AN <DA CHANNEL)
THE FOLLOWING EVENT IS SIGNALED.
.NF.S
%<SIGNAL 10, 29, N, "^CLOSING <DA/SQ CHANNEL WITH THE WRONG ROUTINE"


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^COPY\\
.INDEX ^^COPY\\
.P-8
<DEFINITION: ^THIS ROUTINE COPIES ONE FILE INTO ANOTHER.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^COPY\\(%<STRING(255) ORIG, NEW)
.P
<CALL:	^^COPY\\(ORIG, NEW)
.LM 16;.F;.S 1

.I-8
ORIG	IS A STRING CONTAINING THE ORIGINAL FILE SPECIFICATION
.I-8
NEW	IS A STRING CONTAINING THE FILE SPECIFICATION FOR THE COPIED FILE.
.LM 8;.S 1
THE FILE SPECIFIED IN 'ORIG' IS COPIED TO ANOTHER FILE WHOSE
NAME IS SPECIFIED IN 'NEW'.
.UC.F.P
<ASSOCIATED <PROCEDURES: XCOPY, (X)RENAME, (X)DELETE, (X)ISFILE
.LC.P
<ERROR <CONDITIONS: SEE <OPEN <DA AND ALSO, WHEN THE <I/O CHANNEL CAPACITY IS FULL:-
.S
%<SIGNAL 2, 5, 0, "^NO FREE CHANNELS FOR ^^COPY\\ING 'FILESPEC'"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^CPUTIME\\
.INDEX ^^CPUTIME\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE NUMBER OF MILLISECONDS
OF PROCESSOR TIME THAT THE CURRENT JOB HAS USED SINCE IT LOGGED IN.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^CPUTIME\\
.P
<USE:	CPU=^^CPUTIME\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^THE AMOUNT OF <CPU TIME IN MILLISECONDS, SINCE THE CURRENT
JOB LOGGED IN, IS RETURNED VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: JOBNUM, PPN, TIME
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^CUSP FILES\\
.INDEX ^^CUSP FILES\\
.P-8
<DEFINITION: ^THIS ROUTINE WILL READ A <CUSP STYLE COMMAND STRING FROM
THE CURRENT INPUT STREAM AND RETURN THE DECODED FILE-SPECIFICATIONS
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^CUSP FILES\\(%<RECORD(FILESPEC)%<NAME OUT,AUX,IN,RUN, %<INTEGER N, %<INTEGER<NAME FOUND)
.P
<CALL:	^^CUSP FILES\\(OUT,AUX,IN,RUN,N,FOUND)
.LM 16;.F;.S 1

.I-8
OUT	IS THE NAME OF A RECORD CONTAINING AN OUTPUT FILE SPECIFICATION
IF ONE IS GIVEN
.I-8
AUX	IS THE NAME OF A RECORD CONTAINING AN AUXILLIARY OUTPUT FILE
SPECIFICATION IF ONE IS GIVEN
.I-8
IN	IS THE NAME OF A RECORD CONTAINING AN INPUT FILE
SPECIFICATION IF ONE IS GIVEN
.I-8
RUN	IS THE NAME OF A RECORD CONTAINING A FILE
SPECIFICATION FOR A FILE TO BE <RUN USING THE <RUN COMMAND, IF ONE IS GIVEN
.I-8
N	IS AN INTEGER EXPRESSION USED FOR AN INDIRECT COMMAND FILE STREAM, IF ONE IS NEEDED
.I-8
FOUND	IS THE NAME OF AN INTEGER VARIABLE INDICATING WHETHER OR NOT A COMMAND STRING WAS FOUND
.B
FOUND = -1 INDICATES THAT A <RUN FILE SPECIFICATION WAS PRESENT.
.B
FOUND _> 0  INDICATES THAT SOME FILE SPECIFICATIONS WERE FOUND.
.LM 8;.S 1
^IF THE COMMAND INPUT STREAM IS THE USERS CONSOLE, A PROMPT '*' IS
OUTPUT.
.S
^THE FOLLOWING FORMS OF COMMAND LINE ARE PARSED:-
.NF.S
<OUTFILE, <AUXFILE = <INFILE (,<INFILE1 . . . )
<OUTFILE = <INFILE (,<INFILE1 . . . )
<INFILE (,<INFILE1 . . . )
@<CMDFILE
<CMDFILE@
<RUNFILE!
.F.S
^THEY ARE PARSED INTO THE CORRESPONDING (<FILESPEC) RECORDS, THE USER
BEING RESPONSIBLE FOR SUBSEQUENT APPLICATION OF ANY NECESSARY DEFAULTS.
^THE COMMAND STREAM PARAMETER 'N' IS USED WHEN AN INDIRECT COMMAND FILE IS GIVEN ON THE
INPUT STREAM.  ^ALL ERROR REPORTS ARE OUTPUT ON THE USERS CONSOLE
AND IF THE CURRENT INPUT STREAM IS THE USERS CONSOLE, A PROMPT
IS OUTPUT TO INDICATE THAT ANOTHER COMMAND LINE IS REQUIRED.
^THE EXISTENCE OF FURTHER INPUT FILE
SPECIFICATIONS WHICH CAN BE READ USING THE <EXTERNAL ROUTINE
<READFS, IS TESTED THUS:-
.NF.S
E.G.
<%IF <NEXTSYMBOL = ',' %<THEN <SKIPSYMBOL <%AND <READFS(<FSRECORD)
.F.S
^SEE THE DESCRIPTION OF <READFS ROUTINE.
.UC.F.P
<ASSOCIATED <PROCEDURES: SET STREAMS, READ FS, DEFAULT, WRITE FS
.LC.P
<ERROR <CONDITIONS: ^SYNTAX ERRORS ARE REPORTED AS FOLLOWS AND THE REST OF THE LINE IS TYPED
OUT AND IGNORED.
.NF.S
^COMMAND ERROR: "REST OF LINE"
.F.S
^IF THE  INPUT COMMAND STREAM IS THE USERS CONSOLE, THE USER IS REPROMPTED,
OTHERWISE THE FOLLOWING ERROR IS CAUSED:-
.S.NF
%<SIGNAL 10, 9, 0, "^BAD FILE SPECIFICATION 'FILESPEC'"


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^DATE\\
.INDEX ^^DATE\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION RETURNS TODAYS DATE AS A NINE CHARACTER STRING.
.NF;.P
<SPEC:	%<EXTERNALSTRING(9)%FN ^^DATE\\
.P
<USE:	S=^^DATE\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
TODAYS DATE IS RETURNED AS A NINE CHARACTER STRING OF THE FORM
<DD-MON-YY VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: GET DATE, FROM DATE, TO DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TO TIME, TIMETOSTR,
DATETIME, GET NOW, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^DATE TIME\\
.INDEX ^^DATE TIME\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION RETURNS THE CURRENT DATE AND TIME AN EIGHTEEN CHARACTER
STRING VIA %<RESULT.
.NF;.P
<SPEC:	%<EXTERNALSTRING(18)%FN ^^DATE TIME\\
.P
<USE:	S=^^DATE TIME\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
THE CURRENT DATE AND TIME ARE RETURNED AS AN EIGHTEEN CHARACTER
STRING OF THE FORM <HH:MM:SS#<DD-MON-YY VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, TO DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TO TIME, TIMETOSTR,
GET NOW, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^DATETOSTR\\
.INDEX ^^DATETOSTR\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION RETURNS
THE GIVEN DATE AS A NINE CHARACTER STRING.
.NF;.P
<SPEC:	%<EXTERNALSTRING(9)%FN ^^DATETOSTR\\(%<INTEGER DATE)
.P
<USE:	S=^^DATETOSTR\\(DATE)
.LM 16;.F;.S 1

.I-8
DATE	IS AN INTEGER EXPRESSION BEING A DATE IN <DEC INTERNAL FORMAT
.LM 8;.S 1
THE GIVEN DATE IS RETURNED AS A NINE CHARACTER STRING OF THE
FORM <DD-MON-YY VIA %<RESULT.
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, TO DATE,
TIME, GET TIME, FROM TIME, TO TIME, TIMETOSTR,
DATETIME, GET NOW, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^DAY\\
.INDEX ^^DAY\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION GIVES THE VALUE OF THE DAY
OF THE WEEK AS A STRING OF UP TO NINE CHARACTERS.
.NF;.P
<SPEC:	%<EXTERNALSTRING(9)%FN ^^DAY\\
.P
<USE:	S=^^DAY\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
THE UN-ABREVIATED DAY OF THE WEEK IS RETURNED WITH NO FILLING CHARACTERS
VIA %<RESULT.
.F.P.UC
<ASSOCIATED <PROCEDURES: DAYTOSTR
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;&NAP;.F;.C
^^DAYTOSTR\\
.INDEX ^^DAYTOSTR\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION GIVES THE VALUE OF THE DAY OF THE WEEK
AS A STRING OF UP TO NINE CHARACTERS, FOR THE GIVEN DATE.
.NF;.P
<SPEC:	%<EXTERNALSTRING(9)%FN ^^DAYTOSTR\\(%<INTEGER UDT)
.P
<USE:	S=^^DAYTOSTR\\(UDT)
.LM 16;.F;.S 1

.I-8
UDT	IS AN INTEGER EXPRESSION BEING A DATE IN UNIVERSAL DATE-TIME FORMAT
.LM 8;.S 1
THE DAY OF THE WEEK WHICH CORRESPONDS TO THE GIVEN DATE IS RETURNED
AS AN UN-ABREVIATED, NON-FILLED STRING OF UP TO 9 CHARACTERS, VIA %<RESULT
.F.P.UC
<ASSOCIATED <PROCEDURES: DAY, UDTTOSTR, TOUDT
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^DDT\\
.INDEX ^^DDT\\
.P-8
<DEFINITION: ^THIS ROUTINE WILL ENTER <DDT FROM A RUNNING PROGRAM, WHEN <DDT IS LOADED.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^DDT\\(%<<NAME X)
.P
<CALL:	^^DDT\\(X)
.LM 16;.F;.S 1

.I-8
X	IS THE NAME OF A VARIABLE WHICH CAN BE USED FOR IDENTIFICATION OF THE
PARTICULAR CALL OF THE ROUTINE.
.LM 8;.S 1
^IF <DDT IS LOADED THE CALL OF THIS ROUTINE CAUSES <DDT TO BE ENTERED.
^THUS IT ACTS AS A BREAKPOINT FROM A MAIN PROGRAM. ^THE REGISTERS ARE LEFT UNALTERED
AND THE ADDRESS OF THE VARIABLE POINTED TO BY THE <%NAME
PARAMETERS IS KEPT IN THE INTEGER <DDARG.
.B
^THE PROGRAM CAN BE CONTINUED FROM <DDT BY TYPEING:-
.NF.S
<DDCONT$G
.S.F
WHICH EFFECTIVELY RETURNS FROM THE <DDT ROUTINE.
.P
<ERROR <CONDITIONS: ^WHEN <DDT IS NOT LOADED THE FOLLOWING MESSAGE IS OUTPUT:-
.NF.S
<DDT NOT LOADED - CONTINUING
.F.S
AND THE PROGRAM CONTINUES EXECUTION.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^DECODE\\
.INDEX ^^DECODE\\
.P-8
<DEFINITION: ^THIS ROUTINE OUTPUTS A GIVEN ADDRESS AND MACHINE INSTRUCTION.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^DECODE\\(%<INTEGER INSTR, ADR)
.P
<CALL:	^^DECODE\\(INSTR,ADR)
.LM 16;.F;.S 1

.I-8
INSTR	IS AN INTEGER EXPRESSION BEING A MACHINE INSTRUCTION
.I-8
ADR	IS AN INTEGER EXPRESSION WHICH IS AN ABSOLUTE ADDRESS
.LM 8;.S 1
THE GIVEN ADDRESS IS OUTPUT TO THE CURRENTLY SELECTED OUTPUT STREAM
FOLLOWED BY THE INSTRUCTION ARGUMENT WHICH IS ALSO DECODED INTO ITS VARIOUS
FIELDS AND OPCODE MNEMONICS. ^THE LAYOUT IS SHOWN BELOW AND ALL NUMBERS ARE IN OCTAL.
.NF.S
<DECODE(INTEGER(8__400010),ADDR(8__400010))
.F.S
PRODUCES THE FIRST INSTRUCTION OF A PROGRAM'S HIGH SEGMENT, THUS:-
.NF.S
400010   254000 400224   <JRST    0, 400224
.F.P
<ERROR <CONDITIONS: SEE <PRINTSYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^DEFAULT\\
.INDEX ^^DEFAULT\\
.P-8
<DEFINITION: ^THIS ROUTINE ALLOWS DEFAULT SETTINGS TO BE APPLIED TO A
FILE SPECIFICATION RECORD.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^DEFAULT\\(%<RECORD(FILESPEC)%<NAME FS1,FS2)
.P
<CALL:	^^DEFAULT\\(FS1,FS2)
.LM 16;.F;.S 1

.I-8
FS1	IS THE NAME OF THE FILE SPECIFICATION RECORD TO WHICH
DEFAULTS ARE TO BE APPLIED
.I-8
FS2	IS A SIMILAR RECORD CONTAINING THE NECCESARY DEFAULT VALUES
.LM 8;.S 1
^THE ITEMS OF THE FIRST RECORD ARE EXAMINED AND IF AN ITEM
IS NULL THEN IT IS SET EQUAL TO THE VALUE OF THE CORRESPONDING ITEM
IN THE SECOND RECORD.
.NF.S
E.G.
<FS1 CONTAINS  THE SPEC. "MYFILE[11,22]"
<FS2 CONTAINS  THE SPEC. "DSK:FRED.REL[10,12]/BUFFERS:5"
A CALL OF <DEFAULT(FS1,FS2) RESULTS IN:-
<FS1 CONTAINING  THE SPEC. "DSK:MYFILE.REL[11,22]/BUFFERS:5"
<FS2 REMAINS UNCHANGED
.F
.UC.F.P
<ASSOCIATED <PROCEDURES: READ FS, WRITE FS, CUSP FILES
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^DEFINE INPUT\\
.INDEX ^^DEFINE INPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE ASSOCIATES A GIVEN DEVICE OR FILE WITH A GIVEN STREAM
NUMBER AND OPENS THAT DEVICE OR FILE FOR INPUT.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^DEFINE INPUT\\(N,SPEC)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION WHOSE VALUE MUST LIE BETWEEN 1 AND 15
AND WHICH REPRESENTS THE INPUT STREAM NUMBER TO BE USED.
.I-8
SPEC	IS A STRING CONTAINING A FULL ^^DEC\\SYSTEM-10 FILE SPECIFICATION
INCLUDING SWITCHES, A LIST OF WHICH IS GIVEN IN SECTION 3 OF THIS DOCUMENT.
.LM 8;.S 1
^THE GIVEN DEVICE OR FILE IS OPENED AND ASSOCIATED WITH THE LOGICAL INPUT
STREAM NUMBER 'N'. ^IT IS SELECTED AS THE CURRENT INPUT STREAM BY CALLING
<SELECT <INPUT FOR THAT STREAM.
.S
^THE DEVICE <TMP: IS ALLOWED USING A THREE CHARACTER FILE-NAME. ^IT READS
A TEMPORARY FILE RESIDING IN THE USERS STORE, WHICH EXISTS FOR THE
DURATION OF THE CURRENT JOB. (^SEE THE DESCRIPTION OF THE <TMPCOR
<UUO IN THE ^^DEC\\SYSTEM-10 ^MONITOR ^CALLS MANUAL). ^IF
THE FILE DOES NOT EXIST IN THE CURRENT <TMPCOR SPACE, A JOB-SPECIFIC
FILE IS LOOKED FOR ON DISK WITH THE NAME 'XXX<NAM.TMP', WHERE 'XXX'
IS THE CURRENT JOB-NUMBER.
.UC.F.P
<ASSOCIATED <PROCEDURES: JOBFILE, XDEFINE INPUT, SDEF INPUT, SELECT INPUT, CLOSE INPUT,
RESET INPUT
.LC.P
<ERROR <CONDITIONS: ^WHEN A SYNTAX ERROR IS FOUND IN THE STRING PARAMETER THE FOLLOWING
EVENT OCCURS:-
.NF.S
%<SIGNAL 10, 9, N, "^BAD FILE SPECIFICATION  'FILESPEC'"
.F.S
^A STREAM NUMBER LYING OUTSIDE THE RANGE 1 TO 15 CAUSES EVENT
.NF.S
%<SIGNAL 10, 1, N, "^DEFINING ILLEGAL STREAM"
.F.S
^TRYING TO RE-DEFINE A PREVIOUSLY DEFINED STREAM CAUSES EVENT
.NF.S
%<SIGNAL 10, 2, N, "^STREAM/CHANNEL ALREADY DEFINED"
.F.S
^WHEN AN UNKNOWN SWITCH IS FOUND IN THE SPECIFICATION:-
.S
%<SIGNAL 5, 10, 0, "^UNKNOWN SWITCH / ... "
.F.S
^AND WHEN AN ILLEGAL SWITCH ARGUMENT IS PASSED THE FOLLOWING EVENT OCCURS
.NF.S
%<SIGNAL 5, 9, ARG, "^INCORRECT ARGUMENT FOR SWITCH / ... "
.F.S
^TRYING TO OPEN AN UNKNOWN TYPE OF DEVICE CAUSES EVENT
.NF.S
%<SIGNAL 10, 3, 0, "^UNKNOWN DEVICE 'DEVICE'"
.F.S
^THE FOLLOWING INDICATES THAT THERE IS NOT ENOUGH STORE AVAILBLE FOR BUFFER SPACE
AND THAT A LARGER HEAP IS REQUIRED
.S
%<SIGNAL 2, 5, REQD. SPACE, "HEAP SPACE FULL"
.F.S
^AN ERROR OCCURING WHILE TRYING TO OPEN A FILE CAUSE EVENTS
.NF.S
%<SIGNAL 10, 6, 0, "^CANNOT OPEN DEVICE 'DEVICE'"
  OR (FOR ^^MAG\\TAPES ONLY)
%<SIGNAL 10, 15, ERR, "^TAPOP FAILURE"
  OR
%<SIGNAL 10, 4, ERR, "^LOOKUP ERROR FOR 'FILESPEC'"
.F.S
WHERE ERR IS AN ERROR CODE LISTED IN APPENDIX ^E OF ^^DEC\\SYSTEM-10
<MONITOR <CALLS ^MANUAL. (^NOTE THAT ERROR 0 INDICATES THAT
THE FILE WAS NOT FOUND.)

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^DEFINE OUTPUT\\
.INDEX ^^DEFINE OUTPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE ASSOCIATES A GIVEN DEVICE OR FILE WITH A GIVEN STREAM
NUMBER AND OPENS THAT DEVICE OR FILE FOR OUTPUT.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^DEFINE OUTPUT\\(N,SPEC)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION WHOSE VALUE MUST LIE BETWEEN 1 AND 15
AND WHICH REPRESENTS THE OUTPUT STREAM NUMBER TO BE USED.
.I-8
SPEC	IS A STRING CONTAINING A FULL ^^DEC\\SYSTEM-10 FILE SPECIFICATION
INCLUDING SWITCHES, A LIST OF WHICH IS GIVEN IN SECTION 3 OF THIS DOCUMENT.
.LM 8;.S 1
^THE GIVEN DEVICE OR FILE IS OPENED AND ASSOCIATED WITH THE LOGICAL OUTPUT
STREAM NUMBER 'N'. ^IT IS SELECTED TO BE THE CURRENT OUTPUT STREAM BY CALLING
<SELECT <OUTPUT FOR THAT STREAM.
.S
^THE DEVICE <TMP: IS ALLOWED USING A THREE CHARACTER FILE-NAME. ^IT CREATES
A TEMPORARY FILE RESIDING IN THE USERS STORE, WHICH EXISTS FOR THE
DURATION OF THE CURRENT JOB. (^SEE THE DESCRIPTION OF THE <TMPCOR
<UUO IN THE ^^DEC\\SYSTEM-10 ^MONITOR ^CALLS MANUAL). ^IF
THE FILE IS TOO LARGE FOR THE CURRENT <TMPCOR SPACE, A JOB-SPECIFIC
FILE IS CREATED ON DISK WITH THE NAME 'XXX<NAM.TMP', WHERE 'XXX'
IS THE CURRENT JOB-NUMBER.
.UC.F.P
<ASSOCIATED <PROCEDURES: JOBFILE, XDEFINE OUTPUT, SDEF OUTPUT, SELECT OUTPUT, CLOSE OUTPUT,
RESET OUTPUT
.LC.P
<ERROR <CONDITIONS: ^WHEN A SYNTAX ERROR IS FOUND IN THE STRING PARAMETER THE FOLLOWING
EVENT OCCURS:-
.NF.S
%<SIGNAL 10, 9, 0, "^BAD FILE SPEC:-  'FILESPEC'"
.F.S
^A STREAM NUMBER LYING OUTSIDE THE RANGE 1 TO 15 CAUSES EVENT
.NF.S
%<SIGNAL 10, 1, N, "^DEFINING ILLEGAL STREAM"
.F.S
^TRYING TO RE-DEFINE A PREVIOUSLY DEFINED STREAM CAUSES EVENT
.NF.S
%<SIGNAL 10, 2, N, "^STREAM/CHANNEL ALREADY DEFINED"
.F.S
^WHEN AN UNKNOWN SWITCH IS FOUND IN THE SPECIFICATION:-
.S
%<SIGNAL 5, 10, 0, "^UNKNOWN SWITCH / ... "
.F.S
^AND WHEN AN ILLEGAL SWITCH ARGUMENT IS PASSED THE FOLLOWING EVENT OCCURS
.NF.S
%<SIGNAL 5, 9, ARG, "^INCORRECT ARGUMENT FOR SWITCH / ... "
.F.S
^TRYING TO OPEN AN UNKNOWN TYPE OF DEVICE CAUSES EVENT
.NF.S
%<SIGNAL 10, 3, 0, "^UNKNOWN DEVICE 'DEVICE'"
.F.S
^THE FOLLOWING INDICATES THAT THERE IS NOT ENOUGH STORE AVAILBLE FOR BUFFER SPACE
AND THAT A LARGER HEAP IS REQUIRED
.S
%<SIGNAL 2, 5, REQD. SPACE, "HEAP SPACE FULL"
.F.S
^AN ERROR OCCURING WHILE TRYING TO OPEN A FILE CAUSE EVENTS
.NF.S
%<SIGNAL 10, 6, 0, "^CANNOT OPEN DEVICE 'DEVICE'"
  OR (FOR ^^MAG\\TAPES ONLY)
%<SIGNAL 10, 15, ERR, "^TAPOP FAILURE"
  OR
%<SIGNAL 10, 4, ERR, "^ENTER ERROR FOR 'FILESPEC'"
.F.S
WHERE ERR IS AN ERROR CODE LISTED IN APPENDIX ^E OF ^^DEC\\SYSTEM-10
<MONITOR <CALLS ^MANUAL.


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^DELETE\\
.INDEX ^^DELETE\\
.P-8
<DEFINITION: ^THIS ROUTINE DELETES THE FILE SPECIFIED IN THE STRING PARAMETER.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^DELETE\\(%<STRING(255) SPEC)
.P
<CALL:	^^DELETE\\(SPEC)
.LM 16;.F;.S 1

.I-8
SPEC	IS A STRING CONTAINING A FULL ^^DEC\\SYSTEM-10 STYLE FILE SPECIFICATION
INDICATING A FILE TO BE DELETED
.LM 8;.S 1
^THE FILE SPECIFIED IN THE STRING IS DELETED.
.UC.F.P
<ASSOCIATED <PROCEDURES: XDELETE, (X)RENAME, (X)COPY, (X)ISFILE
.LC.P
<ERROR <CONDITIONS: ^IF THE DELETION IS NOT SUCCESSFUL, THE FOLLOWING EVENT OCCURS
.NF.S
%<SIGNAL 10, 4, ERR, "^CANNOT <RENAME/DELETE 'FILESPEC'"
.F.S
^THE MEANING OF ERR IS GIVEN IN APPENDIX ^E OF THE ^^DEC\\SYSTEM-10 <MONITOR <CALLS ^MANUAL.
.S
^OTHER POSSIBLE ERRORS ARE:-
.NF.S
%<SIGNAL 10, 9, 0, "^BAD FILE SPECIFICATION - 'FILESPEC'"
%<SIGNAL 10, 6, 0, "^CANNOT OPEN DEVICE FOR 'FILESPEC'"
%<SIGNAL 2, 5, 0, "^ALL <I/O CHANNELS IN USE"


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^ECHO\\
.INDEX ^^ECHO\\
.P-8
<DEFINITION: ^THIS ROUTINE TURNS ON CHARACTER ECHOING ON THE USERS CONSOLE
(IT IS THE CONVERSE OF <NOECHO).
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^ECHO\\
.P
<CALL:	^^ECHO\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^ECHOING OF CHARACTERS TYPED TO THE ^^DEC\\SYSTEM-10 IN FULL-DUPLEX
MODE ON THE USERS CONSOLE IS ENABLED. ^IT IS NORMALLY ONLY DISABLED BY
A CALL OF <NOECHO.
.UC.F.P
<ASSOCIATED <PROCEDURES: NOECHO
.LC.P
<ERROR <CONDITIGNS: ^NONE


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^ENDOFPERIOD\\
.INDEX ^^ENDOFPERIOD\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION RETURNS THE DATE AND TIME IN UNIVERSAL
DATE-TIME FORMAT OF THE END OF THE GIVEN ACCOUNTING PERIOD.

.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^ENDOFPERIOD\\(%<INTEGER PERIOD)
.P
<USE:	UDT=^^ENDOFPERIOD\\(PERIOD)
.LM 16;.F;.S 1

.I-8
PERIOD	IS AN INTEGER EXPRESSION BEING A FOUR DIGIT ACCOUNTING PERIOD WHOSE
END DATE-TIME IS REQUIRED
.LM 8;.S 1
THE FINAL DATE AND TIME OF THE GIVEN ACCOUNTING PERIOD, IS RETURNED
AS A UNIVERSAL DATE-TIME INTEGER VIA %<RESULT.
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, TO DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TO TIME, TIMETOSTR,
DATETIME, GET NOW, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD
.F.LC.P
<ERROR <CONDITIONS: WHEN THE PARAMETERS IS NOT OF THE FORM <YYMM
OR IS AN IMPOSSIBLE VALUE, THE FOLLOWING EVENT IS CAUSED:-
.NF.S
%<SIGNAL 11, 22, PERIOD, "^ACCOUNTING PERIOD INCORRECTLY SPECIFIED"


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^ESC\\
.INDEX ^^ESC\\
.P-8
<DEFINITION: ^THIS INTEGER CONSTANT GIVES THE INTERNAL <ASCII CODE VALUE
FOR THE ESCAPE CHARACTER.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^ESC\\
.LM 8;.S 1
^THE NUMERICAL VALUE OF THE ESCAPE CHARACTER IS GIVEN.
.UC.F.P
<ASSOCIATED <CONSTANTS: SP, TAB, NL, FF
.LC

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^EVENT\\
.INDEX ^^EVENT\\

.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE LAST CLASS OF EVENT TO
HAVE BEEN TRAPPED BY AN %<ON %<EVENT BLOCK.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^EVENT\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
WHEN A SERIES OF POSSIBLE EVENTS HAVE BEEN TRAPPED, THIS
INTEGER FUNCTION RETURNS THE NUMBER OF THE EVENT WHICH CAUSED THE TRAP, VIA
%<RESULT.
.F.P.UC
<ASSOCIATED <PROCEDURES: SUB EVENT, EVENT INFO
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^EVENT INFO\\
.INDEX ^^EVENT INFO\\

.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE EXTRA INFORMATION
ASSOCIATED WITH THE LAST EVENT WHICH OCCURRED.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^EVENT INFO\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
WHEN AN EVENT HAS BEEN TRAPPED, THE EXTRA INFORMATION ASSOCIATED WITH THE EVENT
IS RETURNED VIA %<RESULT
.F.P.UC
<ASSOCIATED <PROCEDURES: EVENT, SUB EVENT
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^FF\\
.INDEX ^^FF\\
.P-8
<DEFINITION: ^THIS INTEGER CONSTANT GIVES THE INTERNAL <ASCII CODE VALUE
FOR THE FORM-FEED CHARACTER.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^FF\\
.F.LM 8;.S 1
^THE NUMERICAL VALUE OF THE FORM-FEED CHARACTER IS GIVEN.
.UC.F.P
<ASSOCIATED <CONSTANTS: SP, TAB, ESC, NL
.LC

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^FILOP\\
.INDEX ^^FILOP\\
.P-8
<DEFINITION: ^THIS PREDICATE PERFORMS OPERATIONS LIKE OPENING A DEVICE
OR FILE, BY USING THE '<FILOP' <UUO OR USING EQUIVALENT ^MONITOR ^CALLS.
.NF;.P
<SPEC:	%<SYSTEMPREDICATE ^^FILOP\\(%<RECORD(SCB)%<NAME SCB, %<INTEGER<NAME ERR)
.P
<USE:	%<IF ^^FILOP\\(SCB,ERR) <%THEN . . .
.LM 16;.F;.S 1

.I-8
SCB	IS THE NAME OF A ^STREAM ^CONTROL ^BLOCK RECORD WHICH
HAS BEEN COMPLETELY SET UP, INCLUDING THE REQUIRED '<FILOP' FUNCTION CODE
.I-8
ERR	IS THE NAME OF AN INTEGER VARIABLE WHICH CONTAINS -1 IF THE FUNCTION
WAS SUCCESSFUL OR ELSE AN ERROR CODE WHOSE VALUES ARE GIVEN IN APPENDIX ^E OF THE ^^DEC\\SYSTEM-10 <MONITOR <CALLS ^MANUAL.
.LM 8;.S 1
^THE <FILOP ^FUNCTION SPECIFIED IN THE GIVEN ^STREAM ^CONTROL
^BLOCK IS PERFORMED EITHER BY A '<FILOP' <UUO OR BY ITS EQUIVALENTS DEPENDING
ON THE ^MONITOR VERSION AND THE FUNCTION REQUIRED.
.B
^ON SUCCESSFUL EXECUTION THE PROCEDURE RETURNS A VALUE <%TRUE AND 'ERR' = -1
.B
^ON FAILURE IT RETURNS A VALUE %<FALSE AND 'ERR' CONTAINS THE ERROR CODE.
.UC.F.P
<ASSOCIATED <PROCEDURES: TAPOP, IOUUO
.LC.P
<ERROR <CONDITIONS: ^AS WELL AS RETURNING ANY OF THE ERROR CODES MENTIONED ABOVE
THE FOLLOWING TWO EVENTS MAY OCCUR:-
.NF.S
%<SIGNAL 10, 6, 0, "^CANNOT OPEN DEVICE 'DEVICE'"


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^FINIT\\
.INDEX ^^FINIT\\
.P-8
<DEFINITION: ^THIS ROUTINE CLOSES ANY STREAMS WHICH USE <TMPCOR FILES, AND
IS USED BY THE RUN TIME SYSTEM AT THE TERMINATION OF A
PROGRAM PRIOR TO THE CLOSING OF ALL OTHER STREAMS.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^FINIT\\
.P
<CALL:	^^FINIT\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^STREAMS ASSOCIATED WITH <TMPCOR FILES ARE SPECIAL
CASES AND REQUIRE TO BE CLOSED EXPLICITLY BY THE PROGRAM. ^THIS ROUTINE
CLOSES ANY CURRENTY OPEN <TMPCOR OUTPUT FILES AND IS USED
BY THE RUN TIME SYSTEM PRIOR TO RELEASING ALL ASSIGNED CHANNELS AT
THE TERMINATION OF A RUN.
.UC.F.P
<ASSOCIATED <PROCEDURES: INITIO, CLOSE OUTPUT, DEFINE OUTPUT
.LC.P
<ERROR <CONDITIONS: ^ANY OF THOSE ERRORS ASSOCIATED WITH <CLOSE <OUTPUT AND  <DEFINE <OUTPUT
COULD, BUT SHOULD NOT OCCUR.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^FLOAT\\
.INDEX ^^FLOAT\\
.P-8
<DEFINITION: ^THIS REAL FUNCTION RETURNS THE VALUE OF THE GIVEN INTEGER
AS A FLOATING POINT NUMBER.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	R=^^FLOAT\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION WHICH IS TO BE CONVERTED TO A REAL
.LM 8;.S 1
THE INTEGER PARAMETER IS CONVERTED TO A REAL
NUMBER WHOSE VALUE IS RETURNED VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: INT, INT PT, FRAC PT
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^FRAC PT\\
.INDEX ^^FRAC PT\\
.P-8
<DEFINITION: ^THIS LONGREAL FUNCTION GIVES THE VALUE OF THE FRACTIONAL
PART OF THE GIVEN LONGREAL EXPRESSION.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	R=^^FRAC PT\\(X)
.LM 16;.F;.S 1

.I-8
X	IS A LONGREAL EXPRESSION FOR WHICH THE FRACTIONAL PART IS TO BE
RETURNED
.LM 8;.S 1
^THE FRACTIONAL PART OF 'X' IS RETURNED AS A LONG REAL VIA <%RESULT.
.NF.S
E.G.  THE <FRAC <PT(3.14159)  IS 0.14159
.UC.F.P
<ASSOCIATED <PROCEDURES: INT, INT PT, FLOAT
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^FREE VEC\\
.INDEX ^^FREE VEC\\
.P-8
<DEFINITION: ^THIS ROUTINE RETURNS A GIVEN VECTOR BACK TO THE ^HEAP.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^FREE VEC\\(%<INTEGER N,M)
.P
<CALL:	^^FREE VEC\\(N,M)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING START ADDRESS OF THE
VECTOR TO BE RETURNED
.I-8
M	IS AN INTEGER EXPRESSION WHICH REPRESENTS THE LENGTH OF THE VECTOR
TO BE RETURNED.
.LM 8;.S 1
^THE SPACE CLAIMED FROM THE ^HEAP IS RETURNED
USING THIS ROUTINE. ^IT IS USED BY THE RUN-TIME SYSTEM FOR RETURNING <I/O BUFFER SPACE.
.UC.F.P
<ASSOCIATED <PROCEDURES: GET VEC, INIT HEAP
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^FROM DATE\\
.INDEX ^^FROM DATE\\
.P-8
<DEFINITION: ^THIS ROUTINE TAKES A DATE IN <DEC INTERNAL FORMAT AND RETURNS
THE DAY, MONTH AND YEAR AS INTEGERS.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^FROM DATE\\(%<INTEGER<NAME D, M, Y)
.P
<CALL:	^^FROM DATE\\(D,M,Y)
.LM 16;.F;.S 1

.I-8
D	IS THE NAME OF AN INTEGER VARIABLE WHICH WILL CONTAIN THE RETURNED DAY
OF THE MONTH
.I-8
M	IS THE NAME OF AN INTEGER VARIABLE WHICH WILL CONTAIN THE RETURNED MONTH
OF THE YEAR
.I-8
Y	IS THE NAME OF AN INTEGER VARIABLE WHICH WILL CONTAIN THE RETURNED YEAR
INCLUDING CENTURIES
.LM 8;.S 1
THE DATE IN <DEC INTERNAL DATE FORMAT IS CONVERTED TO THREE
INTEGERS REPRESENTING THE DAY, MONTH AND YEAR, AND THESE ARE RETURNED
IN THE INTEGERNAME PARAMETERS GIVEN. ^THE YEAR IS RETURNED AS A FOUR DIGIT
NUMBER.
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, TO DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TO TIME, TIMETOSTR,
DATETIME, GET NOW, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^FROM TIME\\
.INDEX ^^FROM TIME\\
.P-8
<DEFINITION: ^THIS ROUTINE CONVERTS TIME IN MILLISECONDS (<DEC INTERNAL FORM),
INTO HOURS, MINUTES AND SECONDS.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^FROM TIME\\(%<INTEGER TIME, %<INTEGER<NAME H, M, S)
.P
<CALL:	^^FROM TIME\\(TIME,H,M,S)
.LM 16;.F;.S 1

.I-8
TIME	IS AN INTEGER EXPRESSION BEING THE TIME IN MILLISECONDS
.I-8
H	IS THE NAME OF AN INTEGER VARIABLE WHICH WILL CONTAIN THE RETURNED NUMBER OF
HOURS
.I-8
M	IS THE NAME OF AN INTEGER VARIABLE WHICH WILL CONTAIN THE RETURNED
NUMBER OF MINUTES PAST THE HOUR
.I-8
S	IS THE NAME OF AN INTEGER VARIABLE WHICH WILL CONTAIN THE RETRUNED NUMBER OF
SECONDS PAST THE MINUTE
.LM 8;.S 1
THE TIME IN MILLISECONDS PAST MIDNIGHT (<DEC INTERNAL FORM)
IS CONVERTED TO HOURS, MINUTES AND SECONDS PAST
MIDNIGHT AND RETURNED IN THE GIVEN NAME TYPE PARAMETERS.
.S
^NO PARAMETER CHECKING IS DONE SO THAT THE RESULT IS CALCULATED FOR ANY
NUMBER OF MILLISECONDS.
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, TO DATE, DATETOSTR,
TIME, GET TIME, TO TIME, TIMETOSTR,
DATETIME, GET NOW, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^FROM UDT\\
.INDEX ^^FROM UDT\\
.P-8
<DEFINITION: ^THIS ROUTINE CONVERTS DATE AND TIME SPECIFIED IN
UNIVERSAL DATE-TIME FORMAT, TO DATE AND TIME IN <DEC INTERNAL FORMAT.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^FROM UDT\\(%<INTEGER UDT, %<INTEGER<NAME DATE, TIME)
.P
<CALL:	^^FROM UDT\\(UDT,DATE,TIME)
.LM 16;.F;.S 1

.I-8
UDT	IS AN INTEGER EXPRESSION BEING DATE AND TIME IN UNIVERSAL DATE-TIME
FORMAT
.I-8
DATE	IS THE NAME OF AN INTEGER VARIABLE WHICH WILL CONTAIN THE RETURNED
DATE IN <DEC INTERNAL FORM
.I-8
TIME	IS THE NAME OF AN INTEGER VARIABLE WHICH WILL CONTAIN THE RETURNED
TIME IN <DEC INTERNAL FORM
.LM 8;.S 1
THE DATE AND TIME SPECIFIED IN THE UNIVERSAL DATE-TIME FORM IS RETURNED
AS DATE AND TIME IN THE <DEC INTERNAL FORM IN THE THE NAME TYPE PARAMETERS
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, TO DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TO TIME, TIMETOSTR,
DATETIME, GET NOW, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^FSTOSTR\\
.INDEX ^^FSTOSTR\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION CONVERTS A GIVEN FILE SPECIFICATION
RECORD INTO A STRING.
.NF;.P
<SPEC:	%<EXTERNALSTRING(255)%FN ^^FSTOSTR\\ (%<RECORD(FILESPEC)%<NAME FS)
.P
<USE:	S=^^FSTOSTR\\(FS)
.LM 16;.F;.S 1

.I-8
FS	IS THE NAME OF A FILE SPECIFICATION RECORD TO BE CONVERTED
.LM 8;.S 1
^THE GIVEN RECORD IS CONVERTED TO AN <IMP STRING AND RETURNED
VIA %<RESULT
.UC.F.P
<ASSOCIATED <PROCEDURES: STRTOFS, READ FS, WRITE FS, DEFAULT
.LC.P
<ERROR <CONDITIONS: ^NONE
.S 4;.TEST PAGE 20;.NAP;.F;.C
^^GET CHANNEL\\
.INDEX ^^GET CHANNEL\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE NEXT FREE PHYSICAL
CHANNEL.
.NF;.P
<SPEC:	%<SYSTEMINTEGERFN ^^GET CHANNEL\\
.P
<USE:	N=^^GET CHANNEL\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^THE NEXT FREE PHYSICAL CHANNEL NUMBER IS RETURNED VIA %<RESULT.
^THE RUN-TIME SYSTEM USES THIS FUNCTION WHEN DEFINING STREAMS
AND OPENING <DA OR <SQ CHANNELS.
.UC.F.P
<ASSOCIATED <PROCEDURES: GETSTS, SETSTS, CLOSE, RELEASE, IOUUO
.LC.P
<ERROR <CONDITIONS: ^WHEN ALL <I/O CHANNELS ARE IN USE (I.E. WHEN 15 STREAMS OR
CHANNELS ARE OPEN SIMULTANEOUSLY) THE FOLLOWING EVENT OCCURS:-
.NF.S
<%SIGNAL 2, 5, 0, "^ALL <I/O CHANNELS IN USE"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^GET DATE\\
.INDEX ^^GET DATE\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE CURRENT DATE
IN <DEC INTERNAL FORM
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^GET DATE\\
.P
<USE:	D=^^GET DATE\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
THE CURRENT DATE IN <DEC INTERNAL FORM IS RETURNED VIA %<RESULT.
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, FROM DATE, TO DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TO TIME, TIMETOSTR,
DATETIME, GET NOW, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^GET NOW\\
.INDEX ^^GET NOW\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE CURRENT DATE AND TIME IN UNIVERSAL DATE-TIME FORMAT
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^GET NOW\\
.P
<USE:	UDT=^^GET NOW\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
THE CURRENT DATE AND TIME ARE RETURNED IN UNIVERSAL
DATE-TIME FORMAT VIA %<RESULT.
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, TO DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TO TIME, TIMETOSTR,
DATETIME, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^GET PAGES\\
.INDEX ^^GET PAGES\\
.P-8
<DEFINITION: ^THIS ROUTINE GETS A NUMBER OF FREE PAGES FROM THE ^^DEC\\SYSTEM-10 ^MONITOR
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^GET PAGES\\(%<INTEGER FIRST, LAST)
.P
<CALL:	^^GET PAGES\\(FIRST,LAST)
.LM 16;.F;.S 1

.I-8
FIRST	IS AN INTEGER EXPRESSION BEING THE PAGE NUMBER OF THE FIRST PAGE
REQUIRED
.I-8
LAST	IS AN INTEGER EXPRESSION BEING THE PAGE NUMBER OF THE LAST PAGE REQUIRED
.LM 8;.S 1
A NUMBER OF CONSECUTIVE PAGES IN STORE ARE OBTAINED FROM THE MONITOR.
^IF NECESSARY AND IF POSSIBLE, THE ROUTINE WILL GET VIRTUAL STORE IF
NO MORE PHYSICAL STORE IS AVAILABLE.
.S
^ON A ^^DEC\\SYSTEM-20 THIS ROUTINE JUST RETURNS.
.S
^IT IS UP TO THE USER TO KNOW WHAT THEY ARE DOING AND NOT TO OBTAIN PAGES
THAT THE RUN TIME SYSTEM MAY REQUIRE FOR STACK SPACE.
.F.LC.P
<ERROR <CONDITIONS: WHEN CORE CANNOT BE OBTAINED FOR ANY REASON THE FOLLOWING EVENT
IS CAUSED:-
.S
%<SIGNAL 2, 1, FAULT, "^CANNOT GET STORE"
.B
WHERE FAULT IS A PAGE FAULT NUMBER WHOSE MEANING CAN BE FOUND IN THE
^^DEC\\SYSTEM-10 <MONITOR <CALLS ^MANUAL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^GETSEG\\
.INDEX ^^GETSEG\\
.P-8
<DEFINITION: ^THIS ROUTINE HAS THE EFFECT OF REPLACING THE CURRENT
HIGH SEGMENT OF A PROGRAM BY THE ONE SPECIFIED, WHILST LEAVING THE
LOW SEGMENT DATA UNALTERED.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^GETSEG\\(%<STRING(6) DEV,FILE, %<STRING(3) EXT, %<INTEGER PPN)
.P
<CALL:	^^GETSEG\\(DEV,FILE,EXT,PPN)
.LM 16;.F;.S 1

.I-8
DEV	IS A STRING CONTAINING THE NAME OF THE DEVICE FROM WHICH THE
NEW HIGH SEGMENT IS TO BE TAKEN
.I-8
FILE	IS A STRING CONTAINING THE FILE NAME OF THE FILE FROM WHICH
THE NEW HIGH SEGMENT IS TO BE TAKEN
.I-8
EXT	IS A STRING SPECIFYING THE EXTENSION TO THE FILE NAME
(^IF AN EXTENSION <.SAV IS GIVEN, <.EXE WILL BE TRIED FIRST)
.I-8
PPN	IS AN INTEGER EXPRESSION GIVING THE OCTAL REPRESENTATION OF THE
PROJECT-PROGRAMMER PAIR FOR THE NEW HIGH-SEGMENT FILE
(^IF ZERO IS GIVEN, THE USERS OWN AREA IS ASSUMED.)
.LM 8;.S 1
^THIS ROUTINE ALLOWS THE USER TO USE A NUMBER OF CODE SEGMENTS
TO OPERATE ON THE SAME DATA SEGMENT. ^IT LEAVES THE REGISTERS UNALTERED
AND RETURNS CONTROL TO THE START OF THE NEW PROGRAM SEGMENT.
.UC.F.P
<ASSOCIATED <PROCEDURES: RUN
.LC.P
<ERROR <CONDITIONS: ^THE MONITOR MAY PRODUCE ONE OF THE FOLLOWING MESSAGES:-
.NF.S
.UC
?NOT A SAVE FILE
? ... .SAV NOT FOUND
?TRANSMISSION ERROR
?LOOKUP FAILURE 'N'
?'N'P OF CORE NEEDED
?NO START ADDRESS
.LC

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^GETSTS\\
.INDEX ^^GETSTS\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE STATUS WORD
FOR THE DEVICE ASSOCIATED WITH A GIVEN PHYSICAL CHANNEL NUMBER.
.NF;.P
<SPEC:	%<SYSTEMINTEGERFN ^^GETSTS\\(%<INTEGER N)
.P
<USE:	N=^^GETSTS\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION GIVING THE NUMBER OF THE PHYSICAL
CHANNEL NUMBER TO BE LOOKED AT (THE LEFT-HALF OF THE <FILOPFN ITEM IN AN
<SCB RECORD)
.LM 8;.S 1
^EACH PHYSICAL CHANNEL HAS ASSOCIATED WITH IT A SET OF STATUS BITS
WHICH THIS FUNCTION READS AND RETURNS VIA %<RESULT. ^NOTE THAT THE
MEANING OF THESE BITS DEPEND ON THE PARTICULAR DEVICE BEING EXAMINED (SEE
THE ^^DEC\\SYSTEM-10 <MONITOR <CALLS ^MANUAL FOR THE PARTICULAR DEVICE
IN QUESTION).
.P
<ASSOCIATED <PROCEDURES:  <INSTATUS, <OUTSTATUS, <SETSTS
.P
<ERROR <CONDITIONS: ^WHEN THE CHANNEL NUMBER REFERS TO A CHANNEL WHICH HAS
NO DEVICE ASSOCIATED WITH IT, THE MONITOR GIVES THE FOLLOWING FATAL ERROR:-
.NF.S
?<I/O <TO <UNASSIGNED <CHANNEL <AT <USER ADDR

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^GETTAB\\
.INDEX ^^GETTAB\\
.P-8
<DEFINITION: ^THIS PREDICATE RETURNS INFORMATION FROM ^^DEC\\SYSTEM-10 ^MONITOR TABLES.
.NF;.P
<SPEC:	%<SYSTEMPREDICATE ^^GETTAB\\(%<INTEGER TABLE,INDEX, %<INTEGER<NAME RESULT)
.P
<USE:	<%IF ^^GETTAB\\(TABLE,INDEX,RESULT) <%THEN . . .
.LM 16;.F;.S 1

.I-8
TABLE	IS AN INTEGER EXPRESSION GIVING THE TABLE NUMBER TO BE EXAMINED
.I-8
INDEX	IS AN INTEGER EXPRESSION GIVING THE INDEX INTO THAT TABLE
.I-8
RESULT	IS THE NAME OF AN INTEGER VARIABLE WHICH CONTAINS THE
RESULTANT VALUE IF THE PREDICATE WAS SUCCESSFUL, OTHERWISE IS CONTAINS ZERO
.LM 8;.S 1
^THIS PREDICATE USES THE ^MONITOR <GETTAB <UUO
WHICH IS A WAY OF EXAMINING THE TABLES IN WHICH THE ^MONITOR KEEPS
INFORMATION ABOUT JOBS AND ITSELF. (SEE THE DECRIPTION OF THE <GETTAB
<UUO IN THE ^^DEC\\SYSTEM-10 <MONITOR <CALLS ^MANUAL FOR A LIST OF ITS
POSSIBLE ARGUMENT VALUES). ^WHEN THE PREDICATE IS <%TRUE THE RESULT IS
PASSED BACK IN THE THIRD PARAMETER, OTHERWISE THAT PARAMETER IS SET TO ZERO.
.UC.F.P
<ASSOCIATED <PROCEDURES: CALLI1, CALLI2, CALLI3
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^GET TIME\\
.INDEX ^^GET TIME\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION  RETURNS THE TIME OF DAY
IN MILLISECONDS SINCE MIDNIGHT.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^GET TIME\\
.P
<USE:	T=^^GET TIME\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^THE TIME OF DAY IN MILLISECONDS PAST MIDNIGHT (<DEC INTERNAL FORM) IS RETURNED VIA %<RESULT.
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, TO DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TO TIME, TIMETOSTR,
DATETIME, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^GET VEC\\
.INDEX ^^GET VEC\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION ALLOCATES SPACE IN THE <HEAP
AND RETURNS THE START ADDRESS OF THE REQUIRED VECTOR.
.NF;.P
<SPEC:	%<SYSTEMINTEGERFN ^^GET VEC\\(%<INTEGER SIZE)
.P
<USE:	N=^^GET VEC\\(SIZE)
.LM 16;.F;.S 1

.I-8
SIZE	IS AN INTEGER EXPRESSION SPECIFYING THE AMMOUNT OF <HEAP SPACE
REQUIRED
.LM 8;.S 1
^THE <HEAP IS SCANNED UNTIL A HOLE THE SIZE OF THE REQUIRED
LENGTH IS FOUND. ^THIS IS THEN FLAGGED AS ALLOCATED AND THE START ADDRESS
OF THE VECTOR IS RETURNED VIA <%RESULT.
.B
^THE SYSTEM USES THIS ROUTINE WHENEVER SPACE IS REQUIRED FOR <I/O  E.G.
<DEFINE <INPUT, <OPEN <SQ ETC. ^BUT TOGETHER WITH <FREE <VEC IT IS USEFUL
WHENEVER DYNAMIC STORAGE IS REQUIRED.
.UC.F.P
<ASSOCIATED <PROCEDURES: FREE VEC, INIT HEAP
.LC.P
<ERROR <CONDITIONS: ^WHEN NO HOLE LARGE ENOUGH IS FOUND IN THE HEAP
THE FOLLOWING EVENT OCCURS:-
.NF.S
%<SIGNAL 2, 4, SIZE, "^HEAP SPACE FULL"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^HEXTOSTR\\
.INDEX ^^HEXTOSTR\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION RETURNS A STRING CONTAINING THE
REPRESENTION OF AN UNSIGNED HEXIDECIMAL INTEGER AS A STRING OF DIGITS.
.NF;.P
<SPEC:	%<EXTERNALSTRING(9)%FN ^^HEXTOSTR\\(%<INTEGER N)
.P
<USE:	S=^^HEXTOSTR\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION  REPRESENTING AN HEXIDECIMAL NUMBER
.LM 8;.S 1
^AN INTEGER EXPRESSION IS TREATED AS AN UNSIGNED HEXIDECIMAL NUMBER
AND RETURNED AS A STRING OF UP TO 9 DIGITS AND LETTERS
WITHOUT LEADING ZEROES OR SPACES VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: READ HEX, WRITE HEX, STRTOHEX
.LC.P
<ERROR <CONDITIONS: ^NONE


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^ICALL (0-9)\\
.INDEX ^^ICALL (0-9)\\
.P-8
<DEFINITION: ^THESE INTEGER FUNCTIONS CALL THE <FORTRAN FUNCTION NAMED AS
THE FIRST PARAMETER WITH THE NECESSARY ARGUMENTS GIVEN AS THE SUCCEEDING PARAMETERS.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^ICALL (0-9)\\(%<<NAME IFN, %<<NAME ARG1, .. %<<NAME ARG9)
.P
<USE:	^^N = ICALL (0-9)\\(IFN,ARG1, .. ARG9)
.LM 16;.F;.S 1

.I-8
IFN	IS THE NAME OF A EXTERNAL <FORTRAN INTEGER FUNCTION.
^FOR EASE OF HANDLING, IT IS REQUIRED THAT THE SPEC GIVEN
IN THE <IMP PROGRAM IS THAT OF %<EXTERNALINTEGERSPEC.
.I-8
ARG1	IS THE NAME OF THE FIRST ARGUMENT IF ONE IS NEEDED
.I-8
AND SO ON UP TO
.I-8
ARG9	IS THE NAME OF THE NINTH ARGUMENT IF ONE IS NEEDED
.LM 8;.S 1
THERE ARE A SET OF <IMP INTEGER FUNCTIONS CALLED <ICALL0, <ICALL1, ETC.
UP TO <ICALL9. ^THE NUMBER REFERS TO THE NUMBER OF ARGUMENTS
WHICH THE <FORTRAN FUNCTION REQUIRES. ^SEE THE FOLLOWING EXAMPLE:-
.NF.UC.S.LIT
%BEGIN
%EXTERNALINTEGERSPEC FNOARG
      !A FORTRAN FUNCTION WITH NO ARGUMENTS
%EXTERNALINTEGERSPEC F3ARGS
      !A FORTRAN FUNCTION WITH THREE ARGUMENTS

%EXTERNALINTEGERFNSPEC ICALL0(%NAME FN)
%EXTERNALINTEGERFNSPEC ICALL3(%NAME FN, %NAME A,B,C)

%INTEGER ARG1,ARG2,ARG3
%INTEGER N,M

ARG1=1; ARG2=2; ARG3=3
N = ICALL0(FNOARG);                 !CALL FORTRAN
M = ICALL3(F3ARGS,ARG1,ARG2,ARG3);  !CALL FORTRAN
WRITE(N,0) %IF M < 0

%ENDOFPROGRAM
.END LITERAL
.LC.F.S
^THE %<INCLUDE FILE "<IMP:FORTRA.INC" CONTAINS ALL THE SPECS FOR THE <ICALL FUNCTIONS.
.UC.F.P
<ASSOCIATED <PROCEDURES: CALL (0-9), RCALL (0-9)
.LC.P
<ERROR <CONDITIONS: ^DEPENDING ON THE <FORTRAN FUNCTION CALLED.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^IMOD\\
.INDEX ^^IMOD\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE MODULUS
(I.E. THE ABSOLUTE VALUE) OF THE GIVEN INTEGER QUANTITY.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	M=^^IMOD\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION 
.LM 8;.S 1
^THE INTEGER VALUE OF THE MODULUS OF 'N' IS RETURNED VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: MOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F.C
^^INDEV\\
.INDEX ^^INDEV\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE DEVICE TYPE
ASSOCIATED WITH THE CURRENT INPUT STREAM.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^INDEV\\
.P
<USE:	N=^^INDEV\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^A NUMBER INDICATING THE GENERIC TYPE OF THE DEVICE ASSOCIATED
WITH THE CURRENT INPUT STREAM IS RETURNED VIA %<RESULT.
.B
^BELOW IS LISTED THE CURRENT RANGE OF POSSIBLE VALUES AND THEIR MEANINGS.
.NF.S.TS 28 34
%<CONSTINTEGER ^NAME	^VALUE	^DEVICE ^TYPE
.S
   <TMPDEV   = -2  A <TMPCOR FILE RESIDING IN CORE
   <NULDEV   = -1  A NULL DEVICE
            (DEFAULT VALUE FOR UNASSIGNED STREAMS)
   <DSKDEV   =  0  A ^DISK DEVICE
   <DTADEV   =  1  A <DEC TAPE
   <MTADEV   =  2  A MAGNETIC TAPE
   <TTYDEV   =  3  A TELETYPE
   <XDSKDEV _>=  4  ANY OTHER ^DISK-TYPE DEVICE
.TS 8 16
.UC.F.P
<ASSOCIATED <PROCEDURES: INSTREAM, SELECT INPUT, INSTATUS
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^INITFOR\\
.INDEX ^^INITFOR\\
.P-8
<DEFINITION: ^THIS ROUTINE INITIALISES <FOROTS - THE <FORTRAN ^RUNTIME SYSTEM.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^INITFOR\\
.P
<CALL:	^^INITFOR\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^WHEN CALLING <FORTRAN ^PROCEDURES FROM <IMP, THE USER MAY WANT TO
USE THE FACILITIES OF <FOROTS (E.G. <FORTRAN <I/O).
THIS ROUTINE CAUSES THE <FOROTS LIBRARY TO BE SEARCHED AT LOAD TIME
AND INITIALISES THE <FOROTS SYSTEM FOR SUBSEQUENT USE.
 ^IT IS INADVISABLE TO MIX <IMP AND <FORTRAN <I/O TO
ANYTHING OTHER THAN THE USER'S TERMINAL, BUT IF THE <FORTRAN STREAMS
ARE SET UP BEFORE ANY <IMP STREAMS THEN NO TROUBLE SHOULD BE EXPERIENCED.
.UC.F.P
<ASSOCIATED <PROCEDURES: CALL, ICALL, RCALL
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^INITHEAP\\
.INDEX ^^INITHEAP\\
.P-8
<DEFINITION: ^THIS ROUTINE INITIALISES THE HEAP SPACE FOR <IMP.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^INITHEAP\\
.P
<CALL:	^^INITHEAP\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
THE HEAP WHICH <IMP USES FOR <I/O BUFFER SPACE IS NORMALLY SET UP
BY AN <IMP MAIN PROGRAM. ^WHEN CALLING <IMP FROM ANOTHER LANGUAGE, AND
HEAP SPACE IS REQUIRED, THIS ROUTINE WILL NEED TO BE CALLED TO SET UP THE
LIST STRUCTURE OF THE HEAP. ^THE HEAP IS SET UP BY DEFAULT TO START AT
THE TOP OF THE LOW SEGMENT AND ALLOWED TO GROW UPWARDS DYNAMICALLY.
^THE HEAP CAN BE FIXED IN SIZE BY DECLARING AN EXTERNAL INTEGER <HEAPSIZE
AND BROUGHT INTO THE LOW SEGMENT BY DECLARING AN ARRAY CALLED
<HEAP.
.S
^FOR A FULL DESCIPTION OF THE MEMORY MANAGEMENT SYSTEM SEE THAT
SECTION IN THE '<IMP ON THE <DEC-10 - ^USER ^GUIDE'.
.UC.F.P
<ASSOCIATED <PROCEDURES: INITSTACK, GETVEC, FREEVEC, SAVE ACS, RESTORE,
INITIO
.F.LC.P
<ERROR <CONDITIONS: IF THE STORE IS BEING SET UP DYNAMICALLY AND THERE IS NOT
ENOUGH SPACE THE FOLLOWING EVENT IS CAUSED:-
.S
%<SIGNAL 2, 4, REQD SIZE, "^CANNOT GET STORE FOR HEAP"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^INITIO\\
.INDEX ^^INITIO\\
.P-8
<DEFINITION: ^THIS ROUTINE SETS UP THE INPUT AND OUTPUT STREAMS
AT THE START OF PROGRAM EXECUTION.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^INITIO\\
.P
<CALL:	^^INITIO\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^THE SYSTEM USES THIS ROUTINE TO SET ALL STREAMS TO NULL
EXCEPT STREAMS ZERO WHICH ARE SET TO THE USERS CONSOLE AND ARE
SELECTED AS THE CURRENT INPUT AND OUTPUT STREAMS.
.S
^THIS ROUTINE IS IMPLICITLY CALLED BY AN <IMP MAIN PROGRAM, AND NEED ONLY
BE CALLED EXPLICITLY WHEN <IMP IS BEING CALLED FROM A MAIN
PROGRAM IN ANOTHER LANGUAGE AND <IMP REQUIRES TO DO INPUT OR OUTPUT.
.UC.F.P
<ASSOCIATED <PROCEDURES: INITHEAP, INITSTACK, SAVE ACS, RESTORE
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^INITSTACK\\
.INDEX ^^INITSTACK\\
.P-8
<DEFINITION: ^THIS ROUTINE SETS UP THE <IMP STACK.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^INITSTACK\\
.P
<CALL:	^^INITSTACK\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
<IMP USES A STACK FOR RETURN ADDRESSES FROM PROCEDURES, THE PREVIOUS
STACK BASE ADDRESS AND FOR LOCAL DATA STORAGE. ^THE STACK
IS SET UP AUTOMATICALLY BY THE <IMP MAIN PROGRAM, HOWEVER IF
AN <IMP PROCEDURE IS BEING CALLED FROM ANOTHER LANGUAGE, THE STACK
MAY NEED TO BE SET UP. ^THIS ROUTINE SETS UP THE STACK BY DEFAULT
TO LIE AT THE TOP OF THE USER'S HIGH SEGMENT, AND IS ALLOWED TO
GROW UPWARDS. ^IT CAN HOWEVER BE MADE OF FIXED SIZE BY DECLARING THE EXTERNAL
INTEGER <STACKSIZE AND CAN BE BROUGHT INTO THE LOW SEGMENT BY
DECLARING AN EXTERNAL ARRAY <STACK.
.S
^FOR A FULL DESCIPTION OF THE MEMORY MANAGEMENT SYSTEM SEE THAT
SECTION IN THE '<IMP ON THE <DEC-10 - ^USER ^GUIDE'.
.UC.F.P
<ASSOCIATED <PROCEDURES: INITHEAP, INITIO, SAVE ACS, RESTORE
.LC.P
<ERROR <CONDITIONS: IF NO STORE CAN BE ALLOCATED FOR THE DYNAMIC STACK, THE FOLLOWING
EVENT IS CAUSED:-
.NF.S
%<SIGNAL 2, 4, FAULT, "^CANNOT GET STORE"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^INPUT\\
.INDEX ^^INPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE CAUSES THE NEXT INPUT BUFFER ON THE CURRENTLY SELECTED
INPUT STREAM TO BE READ.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^INPUT\\
.P
<CALL:	^^INPUT\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
THIS ROUTINE PERFORMS THE ^^DEC\\SYSTEM-10 ^MONITOR <IN <UUO
WHICH CAUSES ALL SUBSEQUENT INPUT TO COME FROM THE NEXT BUFFER
AVAILABLE ON THE CURRENTLY SELECTED INPUT STREAM.
.S
^WHEN CALLED ON A TELETYPE OR NULL STREAM, NO ACTION IS PERFORMED.
.F.P.UC
<ASSOCIATED <PROCEDURES: OUTPUT, USETI, USETO, READ SYMBOL, PRINT SYMBOL
.LC.P
<ERROR <CONDITIONS: SEE <READ <SYMBOL

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^INPUT PENDING\\
.INDEX ^^INPUT PENDING\\
.P-8
<DEFINITION: ^THIS PREDICATE RETURNS THE VALUE %<TRUE WHEN THERE IS
ANY INPUT PENDING ON THE CURRENT INPUT STREAM.
.NF;.P
<SPEC:	%<EXTERNALPREDICATE ^^INPUT PENDING\\
.P
<USE:	<%IF ^^INPUT PENDING\\ <%THEN . . .
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^A VALUE OF %<TRUE IS RETURNED WHEN THE CURRENT INPUT STREAM IS
ASSOCIATED WITH A DEVICE OTHER THAN A TELETYPE TYPE OR WHEN THERE ARE
CHARACTERS WAITING TO BE INPUT FROM THE USERS CONSOLE.  ^IT RETURNS %<FALSE
WHEN THERE ARE NO CHARACTERS WAITING TO BE INPUT FROM THE CURRENT INPUT
STREAM AND THAT STREAM IS THE USERS CONSOLE.
.UC.F.P
<ASSOCIATED <PROCEDURES: PROMPT
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^INSTATUS\\
.INDEX ^^INSTATUS\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE STATUS WORD
FOR THE DEVICE ASSOCIATED WITH THE CURRENTLY SELECTED INPUT STREAM.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^INSTATUS\\
.P
<USE:	N=^^INSTATUS\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
EACH DEVICE HAS ASSOCIATED WITH IT A SET OF STATUS BITS, WHICH
THIS FUNCTION READS AND RETURNS VIA %<RESULT.
^THE MEANING OF THESE BITS IS DEVICE DEPENDENT AND ARE DESCRIBED IN
THE ^^DEC\\SYSTEM-10 <MONITOR <CALLS ^MANUAL.
.S
^ZERO IS RETURNED IF THE CURRENTLY SELECTED INPUT STREAM IS THE NUL DEVICE OR THE TELETYPE.
.UC.F.P
<ASSOCIATED <PROCEDURES: OUTSTATUS, GETSTS, SETSTS, INDEV, INSTREAM
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^INSTREAM\\
.INDEX ^^INSTREAM\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE NUMBER OF THE CURRENTLY SELECTED
INPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^INSTREAM\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^THE NUMBER (BETWEEN 0 AND 15) OF THE CURRENTLY SELECTED INPUT STREAM IS
RETURNED VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: INDEV, SELECT INPUT
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^INT\\
.INDEX ^^INT\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE NEAREST INTEGER
TO THE LONG REAL QUANTITY SPECIFIED
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^INT\\(A)
.LM 16;.F;.S 1

.I-8
A	IS A LONGREAL EXPRESSION 
.LM 8;.S 1
^THE VALUE OF THE NEAREST INTEGER TO A IS RETURNED VIA <%RESULT. ^IT IS
EQUIVALENT TO <INTPT (A+0.5).
.UC.F.P
<ASSOCIATED <PROCEDURES: INT PT, FRAC PT, FLOAT
.LC.P
<ERROR <CONDITIONS: ^SEE <INT <PT.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^INTEGER\\
.INDEX ^^INTEGER\\
.P-8
<DEFINITION: ^THIS MAP ENABLES THE USER TO ACCESS DIRECTLY A PARTICULAR
LOCATION WHOSE ADDRESS IS SPECIFIED.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^INTEGER\\(ADR)
.LM 16;.F;.S 1

.I-8
ADR	IS AN INTEGER EXPRESSION GIVING THE ADDRESS OF THE
REQUIRED LOCATION.
.LM 8;.S 1
^THIS MAP ALLOWS THE USER TO READ OR WRITE DIRECTLY TO A LOCATION
IN STORE BY SPECIFYING THE ABSOLUTE ADDRESS IN 'ADR'.
.UC.F.P
<ASSOCIATED <PROCEDURES: BYTE INTEGER, SHORT INTEGER, REAL,
STRING, RECORD
.LC.P
<ERROR <CONDITIONS: ^IF THE VALUE OF 'ADR' LIES OUTSIDE THE CURRENT ADDRESSING SPACE THE
FOLLOWING FATAL ERROR WILL OCCUR:-
.NF.S
?<IMP: ^ILL ^MEM ^REF AT USER PC  'ADDR'

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^INT PT\\
.INDEX ^^INT PT\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE INTEGRAL PART OF
THE GIVEN LONG REAL EXPRESSION.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^INT PT\\(A)
.LM 16;.F;.S 1

.I-8
A	IS A LONGREAL EXPRESSION 
.LM 8;.S 1
^THE INTEGRAL PART OF A IS RETURNED VIA <%RESULT.
.B
^THE INTEGRAL PART IS THE INTEGER THAT IS LESS THAN OR EQUAL TO THE
EXPRESSION. ^HENCE <INT <PT (-3.6) IS -4.
.UC.F.P
<ASSOCIATED <PROCEDURES: INT, FRAC PT, FLOAT
.LC.P
<ERROR <CONDITIONS: ^IF A IS LESS THAN 34359738367 OR GREATER THAN
-34359738368 THEN THE ^MONITOR GIVES THE FOLLOWING ERROR:-
.NF.S
?ARITHMETIC OVERFLOW AT USER <PC 'ADDR'


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^INTTOSTR\\
.INDEX ^^INTTOSTR\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION GIVES THE VALUE OF THE GIVEN
INTEGER AS A STRING OF DECIMAL DIGITS.
.NF;.P
<SPEC:	%<EXTERNALSTRING(12)%FN ^^INTTOSTR\\(%<INTEGER N)
.P
<USE:	S=^^INTTOSTR\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION 
.LM 8;.S 1
^AN INTEGER EXPRESSION IS TREATED AS A DECIMAL NUMBER
AND RETURNED AS A SIGNED STRING OF DIGITS WITH NO LEADING SPACES
VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: OCTTOSTR, HEXTOSTR, BINTOSTR, SIXTOSTR, FSTOSTR, STRTOINT
.LC
.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^IOUUO\\
.INDEX ^^IOUUO\\
.P-8
<DEFINITION: ^THIS PREDICATE WILL PERFORM ONE OF THE ^^DEC\\SYSTEM-10 ^MONITOR CALLS
ASSOCIATED WITH INPUT AND OUTPUT, NAMELY <OPEN, <LOOKUP, <ENTER AND <RENAME.
.NF;.P
<SPEC:	%<SYSTEMPREDICATE ^^IOUUO\\(%<INTEGER OP,CHAN, %<NAME ADR)
.P
<USE:	<%IF ^^IOUUO\\(OP,CHAN,ADR) <%THEN . . .
.LM 16;.F;.S 1

.I-8
OP	IS AN INTEGER EXPRESSION GIVING THE OP-CODE OF THE REQUIRED
<I/O FUNCTION
.I-8
CHAN	IS AN INTEGER EXPRESSION GIVING THE PHYSICAL CHANNEL NUMBER
.I-8
ADR	IS THE NAME OF A VARIABLE CONTAINING THE ADDRESS OF THE
BLOCK OF INFORMATION THAT THE SPECIFIC FUNCTION REQUIRES.
.LM 8;.S 1
^THE PREDICATE HAS THE VALUE %<TRUE WHEN THE FUNCTION IS SUCESSFULLY
COMPLETED AND %<FALSE OTHERWISE. 
.UC.F.P
<ASSOCIATED <PROCEDURES: GET CHANNEL, FILOP, TAPOP, CLOSE, RELEASE
.LC.P
<ERROR <CONDITIONS: ^ANY OF THE ^MONITOR ERRORS ASSOCIATED WITH THE
GIVEN FUNCTION MAY OCCUR. ^FOR THE APPROPRIATE ACTION FOLLOWING A VALUE
OF %<FALSE THE USER WILL NEED TO CONSULT THE ^^DEC\\SYSTEM-10 <MONITOR
<CALLS ^MANUAL UNDER THE APPROPRIATE SECTION.


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^IOWD\\
.INDEX ^^IOWD\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF A WORD GENERATED
BY AN EQIVALENT TO THE ^MACRO TYPE <IOWD PSEUDO-OP.
.NF;.P
<SPEC:	%<SYSTEMINTEGERFN ^^IOWD\\(%<INTEGER LEN, %<INTEGER<NAME ADR)
.P
<USE:	N=^^IOWD\\(LEN,ADR)
.LM 16;.F;.S 1

.I-8
LEN	IS AN INTEGER EXPRESSION GIVING THE LENGTH OF A BLOCK
.I-8
ADR	IS THE NAME OF AN INTEGER VARIABLE BEING THE ADDRESS OF THE START
OF THE BLOCK
.LM 8;.S 1
^THIS EQUIVALENT TO THE <MACRO PSEUDO-OP <IOWD HAS THE SAME FUNCTION.
^IT GENERATES THE FORM OF WORD REQUIRED BY <BLKI, <BLKO AND ALL FOUR
PUSHDOWN INSTRUCTIONS, FROM THE TWO PIECES OF INFORMATION SUPPLIED RELATING
TO THE LENGTH AND LOCATION OF A BLOCK OF DATA. ^THE GENERATED WORD IS RETURNED VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: ADDR, INTEGER
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^IS FILE\\
.INDEX ^^IS FILE\\
.P-8
<DEFINITION: ^THIS PREDICATE TESTS TO SEE WHETHER THE SPECIFIED FILE EXISTS
OR NOT.
.NF;.P
<SPEC:	%<EXTERNALPREDICATE ^^IS FILE\\(%<STRING(255) SPEC)
.P
<USE:	<%IF ^^IS FILE\\(SPEC) <%THEN . . .
.LM 16;.F;.S 1

.I-8
SPEC	IS A STRING CONTAINING THE SPECIFICATION OF THE FILE
TO BE TESTED
.LM 8;.S 1
^THE PREDICATE HAS THE VALUE %<TRUE IF THE FILE EXISTS AND
%<FALSE IF IT DOES NOT, OR CANNOT BE ACCESSED FOR SOME REASON.
.UC.F.P
<ASSOCIATED <PROCEDURES: XISFILE, (X)COPY, (X)DELETE, (X)RENAME
.LC.P
<ERROR <CONDITIONS: ^THE ERRORS WHICH MAY OCCUR DURING THIS PREDICATE ARE:-
.F.S
^WHEN A SYNTAX ERROR IS FOUND IN THE STRING PARAMETER THE FOLLOWING
EVENT OCCURS:-
.NF.S
%<SIGNAL 10, 9, N, "^BAD FILE SPECIFICATION  'FILESPEC'"
.S
   (WHEN THE FULL <I/O CAPACITY IS BEING USED)
%<SIGNAL 2, 5, 0, "^ALL <I/O CHANNELS IN USE"
   OR (USUALLY WHEN A BAD DEVICE IS GIVEN)
%<SIGNAL 10, 6, 0, "^CANNOT OPEN DEVICE 'DEVICE'"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^JOBFILE\\
.INDEX ^^JOBFILE\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION GENERATES  SIX CHARACTER FILE NAME
OF THE FORM '<XXXNAM' WHERE XXX IS THE JOB NUMBER AS A THREE DIGIT NUMBER
AND '<NAM' IS A NAME GIVEN AS THE PARAMETER.
.NF;.P
<SPEC:	%<EXTERNALSTRING(6)%FN ^^JOBFILE\\(%<STRING(3) S)
.P
<USE:	ST=^^JOBFILE\\(S)
.LM 16;.F;.S 1

.I-8
S	IS A STRING FOR THE LAST PART OF THE FILE NAME
.LM 8;.S 1
^THERE ARE TIMES WHEN ONE WISHES TO CREATE FILES
HAVING UNIQUE FILE NAMES, DEPENDING ON WHICH JOB CREATED THEM.
^THIS FUNCTION CONCATENATES A THREE DIGIT STRING REPRESENTING THE JOB
NUMBER, TO THE STRING GIVEN TO THE FUNCTION. ^THE RESULTANT
JOB SPECIFIC NAME IS RETURNED VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)DEFINE INPUT, (X)DEFINE OUTPUT, (X)ISFILE,
(X)COPY, (X)DELETE, (X)RENAME
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^JOBNUM\\
.INDEX ^^JOBNUM\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE JOB NUMBER
OF THE USERS JOB.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^JOBNUM\\
.P
<USE:	N=^^JOBNUM\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
THE JOB NUMBER OF THE USERS CURRENT JOB IS RETURNED VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: PPN, CPUTIME, TIME, JOBFILE
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^JSYS(0-4)\\
.INDEX ^^JSYS(0-4)\\
.P-8
<DEFINITION: ^THESE ROUTINES PERFORM <JSYS ^MONITOR CALLS ON THE
^^DEC\\SYSTEM-20 OPERATING SYSTEM.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^JSYS(0-4)\\(%<INTEGER N, %<INTEGER<NAME AC1, ... AC4)
.P
<CALL:	^^JSYS(0-4)\\(N,AC1, ... AC4)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING THE <JSYS NUMBER
.I-8
AC1	IS THE NAME OF AN INTEGER VARIABLE CONTAINING THE
VALUE REQUIRED IN <AC1 BY THE <JSYS.
.I-8
AND SO ON UP TO
.I-8
AC4	IS THE NAME OF AN INTEGER VARIABLE CONTAINING THE VALUE REQUIRED IN <AC4 BY THE <JSYS.
.LM 8;.S 1
THE GIVEN <JSYS ^MONITOR CALL IS EXECUTED WITH THE APPROPRIATE
VALUES PROVIDED IN THE ARGUMENTS. ^THERE ARE FIVE ROUTINES PROVIDED, DEPENDING
ON THE NUMBER OF ARGUMENTS REQUIRED. <JSYS0, <JSYS1, <JSYS2, <JSYS3 AND <JSYS4.
^THEY ALL HAVE THE FIRST PARAMETER, BUT VARY IN THE NUMBER OF <%INTEGERNAME
ARGUMENTS WHICH THEY TAKE.
^THERE IS AN <INCLUDE FILE CALLED "<IMP:JSYS.INC" WHICH CONTAINS
SPECIFICATIONS FOR THEM.
.F.P.UC
<ASSOCIATED <PROCEDURES: 
.LC.P
<ERROR <CONDITIONS: ON AN ERROR RETURN FROM A <JSYS, THE FOLLOWING EVENT
IS CAUSED:-
.NF
%<SIGNAL 11, 0, N, "<JSYS ERROR RETURN"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^LENGTH\\
.INDEX ^^LENGTH\\
.P-8
<DEFINITION: ^THIS BYTEINTEGER FUNCTION GIVES LENGTH OF THE GIVEN STRING
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^LENGTH\\(S)
.LM 16;.F;.S 1

.I-8
S	IS THE NAME OF A STRING WHOSE LENGTH IS REQUIRED
.LM 8;.S 1
^THE LENGTH OF THE STRING S IS RETURNED VIA <%RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: CHARNO, SUB STRING, TO STRING
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^MATCH\\
.INDEX ^^MATCH\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE STARTING
CHARACTER POSITION IN A NAMED STRING OF A MATCHING SUB-STRING.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^MATCH\\(%<STRINGNAME S, %<STRING(255) T)
.P
<USE:	N=^^MATCH\\(S,T)
.LM 16;.F;.S 1

.I-8
S	IS THE NAME OF A STRING IN WHICH THE OCCURENCE OF A SUB-STRING IS TO
BE TESTED
.I-8
T	IS A STRING CONTAINING THE SUB-STRING WHOSE OCCURRENCE IS QUESTIONED
.LM 8;.S 1
^THE OCCURRENCE OF THE SUB-STRING 'T' IS TESTED IN THE STRING NAMED
IN 'S'. ^IF A MATCH IS FOUND THEN THE CHARACTER POSITION OF THE START OF
THIS MATCH IN 'S' IS RETURNED VIA %<RESULT.
.B
^IF NO MATCH IS FOUND THEN A VALUE OF ZERO IS RETURNED.
.UC.F.P
<ASSOCIATED <PROCEDURES: LENGTH, SUB STRING, TO STRING
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^MOD\\
.INDEX ^^MOD\\
.P-8
<DEFINITION: ^THIS LONGREAL FUNCTION GIVES THE VALUE OF THE MODULUS (I.E.
THE ABSOLUTE VALUE) OF THE QUANTITY GIVEN ON ENTRY.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	B=^^MOD\\(A)
.LM 16;.F;.S 1

.I-8
A	IS A LONGREAL EXPRESSION 
.LM 8;.S 1
^THE LONG REAL VALUE OF THE MODULUS OF A IS RETURNED VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: IMOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^NEWLINE\\
.INDEX ^^NEWLINE\\
.P-8
<DEFINITION: ^THIS ROUTINE CAUSES A NEWLINE (CR-LF) SEQUENCE TO BE OUTPUT
ON THE CURRENTLY SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^NEWLINE\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^A NEWLINE IS SENT TO THE OUTPUT STREAM.
.UC.F.P
<ASSOCIATED <PROCEDURES: NEWLINES, NEWPAGE, SPACE, SPACES
.LC.P
<ERROR <CONDITIONS: ^SEE <PRINT <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^NEWLINES\\
.INDEX ^^NEWLINES\\
.P-8
<DEFINITION: ^THIS ROUTINE CAUSES A SPECIFIED NUMBER OF NEWLINE (CR-LF)
CHARACTER SEQUENCES TO BE OUTPUT ON THE CURRENTLY SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^NEWLINES\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION SPECIFYING THE NUMBER OF NEWLINES
REQUIRED
.LM 8;.S 1
'N' NEWLINE CHARACTER  SEQUENCES ARE SENT TO THE OUTPUT STREAM.
.UC.F.P
<ASSOCIATED <PROCEDURES: NEWLINE, NEWPAGE, SPACE, SPACES
.LC.P
<ERROR <CONDITIONS: ^SEE <PRINT <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^NEWPAGE\\
.INDEX ^^NEWPAGE\\
.P-8
<DEFINITION: ^THIS ROUTINE CAUSES THE 'FORM-FEED' CHARACTER TO BE OUTPUT
TO THE CURRENTLY SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^NEWPAGE\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
A 'FORM-FEED' CHARACTER IS SENT TO THE CURRENT OUTPUT STREAM.
.UC.F.P
<ASSOCIATED <PROCEDURES: NEWLINE, NEWLINES, SPACE, SPACES
.LC.P
<ERROR <CONDITIONS: ^SEE <PRINT <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^NEXT ITEM\\
.INDEX ^^NEXT ITEM\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION RETURNS THE NEXT SYMBOL FROM THE
CURRENTLY SELECTED INPUT STREAM, AS A ONE-CHARACTER STRING.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	S=^^NEXT ITEM\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^A STRING OF LENGTH ONE, CONSISTING OF THE NEXT <ASCII CHARACTER ON
THE CURRENT INPUT STREAM IS RETURNED VIA %<RESULT.
.B
^THE FILE POINTERS ARE NOT AFFECTED
AND THE CHARACTER MAY BE READ AGAIN BY <NEXT <ITEM, <READ <ITEM,
<NEXT <SYMBOL OR <READ <SYMBOL.
.UC.F.P
<ASSOCIATED <PROCEDURES: READ ITEM, READ SYMBOL, NEXT SYMBOL, SKIP SYMBOL
.LC.P
<ERROR <CONDITIONS: ^SEE <READ <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^NEXT SYMBOL\\
.INDEX ^^NEXT SYMBOL\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE NEXT SYMBOL
ON THE CURRENTLY SELECTED INPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^NEXT SYMBOL\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^THE VALUE OF THE NEXT SYMBOL ON THE CURRENT INPUT STREAM IS RETURNED VIA
%<RESULT.
.B
^THE FILE POINTERS ARE NOT ALTERED, SO THE SAME SYMBOL MAY BE OBTAINED
FROM A SUBSEQUENT CALL OF <NEXT <SYMBOL OR <READ <SYMBOL.
.UC.F.P
<ASSOCIATED <PROCEDURES: READ SYMBOL, SKIP SYMBOL, READ ITEM, NEXT ITEM
.LC.P
<ERROR <CONDITIONS: ^SEE <READ <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^NL\\
.INDEX ^^NL\\
.P-8
<DEFINITION: ^THIS INTEGER CONSTANT GIVES THE INTERNAL <ASCII CODE VALUE
FOR THE NEWLINE CHARACTER.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^NL\\
.F.LM 8;.S 1
^THE NUMERICAL VALUE OF THE NEWLINE (LF) CHARACTER IS GIVEN.
.UC.F.P
<ASSOCIATED <CONSTANTS: SP, ESC, TAB, FF
.LC

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^NO ECHO\\
.INDEX ^^NO ECHO\\
.P-8
<DEFINITION: ^THIS ROUTINE HAS THE EFFECT OF TURNING OFF THE ECHOING OF
CHARACTERS FROM THE ^^DEC\\SYSTEM-10 TO THE USERS CONSOLE.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^NO ECHO\\
.P
<CALL:	^^NO ECHO\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^CHARACTERS TYPED ON THE USERS CONSOLE ARE NOT ECHOED AFTER
THIS ROUTINE IS CALLED. ^ECHOING MAY BE RE-ENABLED
BY CALLING THE ROUTINE <ECHO.
.UC.F.P
<ASSOCIATED <PROCEDURES: ECHO
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^OCTTOSTR\\
.INDEX ^^OCTTOSTR\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION RETURNS A STRING CONTAINING THE
REPRESENTION OF AN UNSIGNED OCTAL INTEGER AS A STRING OF DIGITS.
.NF;.P
<SPEC:	%<EXTERNALSTRING(12)%FN ^^OCTTOSTR\\(%<INTEGER N)
.P
<USE:	S=^^OCTTOSTR\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION  REPRESENTING AN OCTAL NUMBER
.LM 8;.S 1
^AN INTEGER EXPRESSION IS TREATED AS AN UNSIGNED OCTAL NUMBER
AND RETURNED AS A STRING OF UP TO 12 DIGITS
WITHOUT LEADING ZEROES OR SPACES VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: READ OCT, WRITE OCT, STRTOOCT
.LC.P
<ERROR <CONDITIONS: ^NONE


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^OPEN DA\\
.INDEX ^^OPEN DA\\
.P-8
<DEFINITION: ^THIS ROUTINE OPENS A DIRECT ACCESS CHANNEL FOR A SPECIFIED
FILE ON A GIVEN CHANNEL NUMBER.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^OPEN DA\\(%<INTEGER N, %<STRING(255) SPEC)
.P
<CALL:	^^OPEN DA\\(N,SPEC)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING THE LOGICAL CHANNEL NUMBER TO BE
ASSOCIATED WITH THE SPECIFIED FILE. ^IT MUST LIE IN THE RANGE 1 TO 15.
.I-8
SPEC	IS A STRING CONTAINING A ^^DEC\\SYSTEM-10 STYLE FILE
SPECIFICATION FOR THE FILE TO BE OPENED
.LM 8;.S 1
^THE SPECIFIED FILE IS OPENED FOR BOTH READING OR WRITING AND
IS ASSOCIATED WITH THE GIVEN LOGICAL CHANNEL NUMBER.
.UC.F.P
<ASSOCIATED <PROCEDURES: XOPEN DA, READ DA, WRITE DA, CLOSE DA
.LC.P
<ERROR <CONDITIONS: ^THE MOST COMMON ERROR IS:-
.NF.S
%<SIGNAL 10, 21, ERR, "^CANNOT <OPEN <DA/SQ FILE 'FILESPEC' ERROR: 'ERR'"
.F
^WHERE ERR IS AN ERROR CODE LISTED IN APPENDIX ^E OF THE ^^DEC\\SYSTEM-10
<MONITOR <CALLS ^MANUAL.
.NF.S
^OR ON A SYNTAX ERROR IN THE FILE SPECIFICATION
.S
%<SIGNAL 10, 9, 0, "^BAD FILE SPECIFICATION:- 'FILESPEC'"
.S
^OTHER POSSIBLE ERRORS ARE:-
%<SIGNAL 10, 20, 0, "^NOT A <DA OR <SQ DEVICE 'DEV'"
%<SIGNAL 10, 22, N, "^^OPEN\\ING ALREADY OPEN <DA/SQ CHANNEL FOR 'FILESPEC'"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^OPEN SQ\\
.INDEX ^^OPEN SQ\\
.P-8
<DEFINITION: ^THIS ROUTINE OPENS A SEQUENTIAL FILE CHANNEL FOR A SPECIFIED
FILE ON A GIVEN CHANNEL NUMBER.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^OPEN SQ\\(%<INTEGER N, %<STRING(255) SPEC)
.P
<CALL:	^^OPEN SQ\\(N,SPEC)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING THE LOGICAL CHANNEL NUMBER TO BE
ASSOCIATED WITH THE SPECIFIED FILE. ^IT MUST LIE IN THE RANGE 1 TO 15.
.I-8
SPEC	IS A STRING CONTAINING A FULL ^^DEC\\SYSTEM-10 STYLE FILE
SPECIFICATION FOR THE FILE TO BE OPENED
.LM 8;.S 1
^THE SPECIFIED FILE IS OPENED FOR EITHER READING OR WRITING AND
IS ASSOCIATED WITH THE GIVEN LOGICAL CHANNEL NUMBER.
^BUT NOTE THAT BOTH OPTIONS OF READING AND WRITING MAY NOT BE EXERCISED
AND THAT THE FIRST CALL OF EITHER <READ <SQ OR <WRITE <SQ
DETERMINES THE SUBSEQUENT TYPE OF ACCESS.
.UC.F.P
<ASSOCIATED <PROCEDURES: XOPEN SQ, READ SQ, WRITE SQ
.LC.P
<ERROR <CONDITIONS: ^SEE <OPEN <DA.


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^OUTDEV\\
.INDEX ^^OUTDEV\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE DEVICE TYPE
ASSOCIATED WITH THE CURRENTLY SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^OUTDEV\\
.P
<USE:	N=^^OUTDEV\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^A NUMBER INDICATING THE GENERIC TYPE OF THE DEVICE ASSOCIATED
WITH THE CURRENT OUTPUT STREAM IS RETURNED VIA %<RESULT.
.B
^BELOW IS LISTED THE CURRENT RANGE OF POSSIBLE VALUES AND THEIR MEANINGS.
.NF.S.TS 28 34
%<CONSTINTEGER ^NAME	^VALUE	^DEVICE ^TYPE
.S
   <TMPDEV   = -2  A <TMPCOR FILE RESIDING IN CORE
   <NULDEV   = -1  A NULL DEVICE
            (DEFAULT VALUE FOR UNASSIGNED STREAMS)
   <DSKDEV   =  0  A ^DISK DEVICE
   <DTADEV   =  1  A <DEC TAPE
   <MTADEV   =  2  A MAGNETIC TAPE
   <TTYDEV   =  3  A TELETYPE
   <XDSKDEV _>=  4  ANY OTHER ^DISK-TYPE DEVICE
.TS 8 16
.UC.F.P
<ASSOCIATED <PROCEDURES: OUTSTREAM, SELECT OUTPUT, OUTSTATUS
.LC.P
<ERROR <CONDITIONS: ^NONE


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^OUTPUT\\
.INDEX ^^OUTPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE CAUSES THE CURRENT OUTPUT BUFFER ON THE CURRENTLY SELECTED
OUTPUT STREAM TO BE SENT.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^OUTPUT\\
.P
<CALL:	^^OUTPUT\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
THIS ROUTINE PERFORMS THE ^^DEC\\SYSTEM-10 ^MONITOR <OUT <UUO
WHICH CAUSES THE CONTENTS OF THE CURRENT OUTPUT BUFFER TO BE FORCED OUT
ON THE CURRENTLY SELECTED OUTPUT STREAM.
.S
^WHEN CALLED ON A TELETYPE OR NULL STREAM, NO ACTION IS PERFORMED.
.F.P.UC
<ASSOCIATED <PROCEDURES: INPUT, USETI, USETO, READ SYMBOL, PRINT SYMBOL
.LC.P
<ERROR <CONDITIONS: SEE <PRINT SYMBOL

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^OUTSTATUS\\
.INDEX ^^OUTSTATUS\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE STATUS WORD
FOR THE DEVICE ASSOCIATED WITH THE CURRENTLY SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^OUTSTATUS\\
.P
<USE:	N=^^OUTSTATUS\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
EACH DEVICE HAS ASSOCIATED WITH IT A SET OF STATUS BITS, WHICH
THIS FUNCTION READS AND RETURNS VIA %<RESULT.
^THE MEANING OF THESE BITS IS DEVICE DEPENDENT AND ARE DESCRIBED IN
THE ^^DEC\\SYSTEM-10 <MONITOR <CALLS ^MANUAL.
.S
^ZERO IS RETURNED IF THE CURRENTLY SELECTED OUTPUT STREAM IS THE NUL DEVICE OR THE TELETYPE.
.UC.F.P
<ASSOCIATED <PROCEDURES: INSTATUS, GETSTS, SETSTS, OUTDEV, OUTSTREAM
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^OUTSTREAM\\
.INDEX ^^OUTSTREAM\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE NUMBER OF THE CURRENTLY SELECTED
OUTPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^OUTSTREAM\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^THE NUMBER (BETWEEN 0 AND 15) OF THE CURRENTLY SELECTED OUTPUT STREAM IS
RETURNED VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: OUTDEV, SELECT OUTPUT, OUTSTATUS
.LC.P
<ERROR <CONDITIONS: ^NONE


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^PI\\
.INDEX ^^PI\\
.P-8
<DEFINITION: ^THIS LONGREAL CONSTANT GIVES THE VALUE OF PI.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	R=^^PI\\
.F.LM 8;.S 1
^THE VALUE OF PI (3.141592653589793238) IS GIVEN.
.LC

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^PPN\\
.INDEX ^^PPN\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE PROJECT-PROGRAMMER
NUMBER ASSOCIATED WITH THE CURRENT JOB.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^PPN\\
.P
<USE:	P=^^PPN\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
THE PROJECT-PROGRAMMER NUMBER ASSOCIATED WITH THE CURRENT JOB IS RETURNED
VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: JOBNUM, CPUTIME, TIME
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^PRINT\\
.INDEX ^^PRINT\\
.P-8
<DEFINITION: ^THIS ROUTINE PRINTS THE VALUE OF THE SPECIFIED LONG REAL
NUMBER ON THE CURRENTLY SELECTED OUTPUT STREAM IN FIXED-POINT FORM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^PRINT\\(X,N,M)
.LM 16;.F;.S 1

.I-8
X	IS A LONGREAL EXPRESSION WHICH IS TO BE OUTPUT
.I-8
N	IS AN INTEGER EXPRESSION INDICATING HOW MANY PRINTING POSITIONS,
INCLUDING THE SIGN, ARE TO BE OUTPUT BEFORE THE DECIMAL POINT
.I-8
M	IS AN INTEGER EXPRESSION INDICATING HOW MANY DIGITS TO
BE OUTPUT AFTER THE DECIMAL POINT
.LM 8;.S 1
X IS PRINTED ON THE CURRENT OUTPUT STREAM IN FIXED-POINT FORM, WITH
'N' PRINTING POSITIONS BEFORE AND 'M' DIGITS AFTER THE DECIMAL POINT.
^THE DIGITS BEFORE THE DECIMAL POINT ARE RIGHT JUSTIFIED AND LEADING
ZEROS ARE REPLACED BY SPACES.
^THE POSITIVE SIGN IS REPRESENTED BY A SPACE.
.B
^IF MORE THAN N SIGNIFICANT DIGITS OCCUR BEFORE THE DECIMAL POINT, THESE
WILL BE PRINTED AND THE REST OF THE DIGITS WILL BE DISPLACED TO THE RIGHT.
^IF 'N' IS ZERO, NO LEADING SPACES OR POSITIVE SIGN WILL BE OUTPUT.
.S
^IF 'X' IS _> 34359738367 THEN THE ROUTINE ^^PRINT FL\\(X,N+M) WILL BE USED.
.UC.F.P
<ASSOCIATED <PROCEDURES: WRITE, PRINT FL
.LC.P
<ERROR <CONDITIONS: ^SEE <PRINT <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^PRINT FL\\
.INDEX ^^PRINT FL\\
.P-8
<DEFINITION: ^THIS ROUTINE PRINTS THE SPECIFIED LONG REAL VALUE  ON
THE CURRENTLY SELECTED OUTPUT STREAM IN FLOATING-POINT FORM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^PRINT FL\\(X,N)
.LM 16;.F;.S 1

.I-8
X	IS A LONGREAL EXPRESSION WHICH IS TO BE PRINTED OUT
.I-8
N	IS AN INTEGER EXPRESSION INDICATING THE NUMBER OF DIGITS TO BE
PRINTED AFTER THE DECIMAL POINT
.LM 8;.S 1
^A FLOATING-POINT LONG REAL NUMBER IS PRINTED OUT USING N+7
PRINTING POSITIONS, WITH N DIGITS AFTER THE DECIMAL POINT.
^THE NUMBER IS STANDARDISED IN THE RANGE 1_<=X_<=10.
.NF
E.G.   ^^PRINT FL\\(PI,5)  GIVES 3.14159@ 0
.UC.F.P
<ASSOCIATED <PROCEDURES: WRITE, PRINT
.LC.P
<ERROR <CONDITIONS: ^SEE <PRINT <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^PRINT STRING\\
.INDEX ^^PRINT STRING\\
.P-8
<DEFINITION: ^THIS ROUTINE OUTPUTS A STRING ON THE CURRENTLY SELECTED
OUTPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^PRINT STRING\\(S)
.LM 16;.F;.S 1

.I-8
S	IS A STRING EXPRESSION TO BE OUTPUT
.LM 8;.S 1
^THE STRING S IS PRINTED ON THE CURRENT OUTPUT STREAM.
.UC.F.P
<ASSOCIATED <PROCEDURES: PRINT SYMBOL, REPORT, PROMPT
.LC.P
<ERROR <CONDITIONS: ^^SEE <PRINT <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^PRINT SYMBOL\\
.INDEX ^^PRINT SYMBOL\\
.P-8
<DEFINITION: ^THIS ROUTINE PRINTS THE SYMBOL WHOSE VALUE IS GIVEN, ON THE
CURRENTLY SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^PRINT SYMBOL\\(S)
.LM 16;.F;.S 1

.I-8
S	IS AN INTEGER EXPRESSION BEING THE VALUE OF THE SYMBOL TO
BE PRINTED
.LM 8;.S 1
^THE SYMBOL WHOSE VALUE IS GIVEN IS OUTPUT TO THE CURRENT
OUTPUT STREAM. ^NOTE THAT NUMBER OF BITS ACTUALLY OUTPUT DEPEND ON THE
MODE OF THE OUTPUT STREAM (E.G. ASCII = 7,  BINARY = 36 ).
.UC.F.P
<ASSOCIATED <PROCEDURES: SPACE, NEWLINE, NEWPAGE
.LC.P
<ERROR <CONDITIONS: ^IF AN ERROR OCCURS DURING OUTPUT, THE FOLLOWING EVENT OCCURS:-
.NF.S
%<SIGNAL 4, 1, STATUS, "<I/O TRANSMISSION ERROR"
.F.S
WHERE 'STATUS' IS A DEVICE DEPENDENT STATUS WORD WHOSE MEANING
IS DESCRIBED IN THE ^^DEC\\SYSTEM-10 <MONITOR <CALLS
^MANUAL UNDER THE SECTION DEALING WITH THE PARTICULAR DEVICE IN QUESTION.
^IT SHOULD BE NOTED THAT THE STATUS WILL BE OUTPUT AS A DECIMAL NUMBER BUT SHOULD
BE INTERPRETED IN OCTAL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^PROMPT\\
.INDEX ^^PROMPT\\
.P-8
<DEFINITION: ^THIS ROUTINE OUTPUTS THE GIVEN PROMPT STRING TO THE
USERS CONSOLE IF THE USERS CONSOLE IS ALSO SELECTED AS THE CURRENT INPUT
STREAM.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^PROMPT\\(%<STRING(255) PR)
.P
<CALL:	^^PROMPT\\(PR)
.LM 16;.F;.S 1

.I-8
PR	IS A STRING TO BE OUTPUT AS A PROMPT
.LM 8;.S 1
^THIS ROUTINE ALLOWS THE USER TO OUTPUT A PROMPT FOR INPUT WHICH
WILL ONLY BE OUTPUT IF IT IS RELEVANT, THAT IS IF THE INPUT IS COMING
FROM THE USERS CONSOLE.
.UC.F.P
<ASSOCIATED <PROCEDURES: INPUT PENDING, PRINT STRING, REPORT
.LC.P
<ERROR <CONDITIONS: ^SEE <PRINT <SYMBOL.


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^RAD50\\
.INDEX ^^RAD50\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE INTEGER VALUE OF THE
^^DEC\\SYSTEM-10 ^RADIX-50 REPRENTATION OF A SIX CHARACTER STRING.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^RAD50\\(%<STRING(6) S)
.P
<USE:	N=^^RAD50\\(S)
.LM 16;.F;.S 1

.I-8
S	IS A SIX CHARACTER STRING CONTAINING THE WORD TO BE ENCODED
.LM 8;.S 1
^THE ^RADIX-50 REPRESENTATION ALLOWS UP TO SIX CHARACTERS TO BE
REPRESENTED BY A SINGLE INTEGER WHICH IS HERE RETURNED VIA %<RESULT.
.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^RCALL (0-9)\\
.INDEX ^^RCALL (0-9)\\
.P-8
<DEFINITION: ^THESE REAL FUNCTIONS CALL THE <FORTRAN FUNCTION NAMED AS
THE FIRST PARAMETER WITH THE NECESSARY ARGUMENTS GIVEN AS THE SUCCEEDING PARAMETERS.
.NF;.P
<SPEC:	%<EXTERNALREALFN ^^RCALL (0-9)\\(%<<NAME RFN, %<<NAME ARG1, .. %<<NAME ARG9)
.P
<USE:	^^R = RCALL (0-9)\\(RFN,ARG1, .. ARG9)
.LM 16;.F;.S 1

.I-8
RFN	IS THE NAME OF A EXTERNAL <FORTRAN REAL FUNCTION.
^FOR EASE OF HANDLING, IT IS REQUIRED THAT THE SPEC GIVEN
IN THE <IMP PROGRAM IS THAT OF %<EXTERNALINTEGERSPEC.
.I-8
ARG1	IS THE NAME OF THE FIRST ARGUMENT IF ONE IS NEEDED
.I-8
AND SO ON UP TO
.I-8
ARG9	IS THE NAME OF THE NINTH ARGUMENT IF ONE IS NEEDED
.LM 8;.S 1
THERE ARE A SET OF <IMP REAL FUNCTIONS CALLED <RCALL0, <RCALL1, ETC.
UP TO <RCALL9. ^THE NUMBER REFERS TO THE NUMBER OF ARGUMENTS
WHICH THE <FORTRAN FUNCTION REQUIRES. ^SEE THE FOLLOWING EXAMPLE:-
.NF.UC.S.LIT
%BEGIN
%EXTERNALINTEGERSPEC FNOARG
      !A FORTRAN FUNCTION WITH NO ARGUMENTS
%EXTERNALINTEGERSPEC F3ARGS
      !A FORTRAN FUNCTION WITH THREE ARGUMENTS

%EXTERNALREALFNSPEC RCALL0(%NAME FN)
%EXTERNALREALFNSPEC RCALL3(%NAME FN, %NAME A,B,C)

%INTEGER ARG1,ARG2,ARG3
%REAL R,P

ARG1=1; ARG2=2; ARG3=3
R = RCALL0(FNOARG);                 !CALL FORTRAN
P = RCALL3(F3ARGS,ARG1,ARG2,ARG3);  !CALL FORTRAN
PRINT(P,2,3) %IF R < 0.0

%ENDOFPROGRAM
.END LITERAL
.LC.F.S
^THE %<INCLUDE FILE "<IMP:FORTRA.INC" CONTAINS ALL THE SPECS FOR THE <RCALL FUNCTIONS.
.UC.F.P
<ASSOCIATED <PROCEDURES: CALL (0-9), ICALL (0-9)
.LC.P
<ERROR <CONDITIONS: ^DEPENDING ON THE <FORTRAN FUNCTION CALLED.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^READ\\
.INDEX ^^READ\\
.P-8
<DEFINITION: ^THIS ROUTINE READS DATA OF THE APPROPRIATE TYPE AS SPECIFIED BY THE
TYPE OF THE NAME TYPE PARAMETER, FROM THE CURRENTLY SELECTED INPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^READ\\(A)
.LM 16;.F;.S 1

.I-8
A	IS THE NAME OF ANY TYPE EXCEPT RECORDS, WHICH DETERMINES THE NATURE
OF THE READING PROCEDURE USED
.LM 8;.S 1
^THIS ROUTINE MAY RESULT IN NUMERICAL DATA BEING READ INTO A <BYTE,
<SHORT OR FULL LENGTH <INTEGER, OR A <REAL OF <LONG <REAL VARIABLE OR
INTO A <STRING, DEPENDING ON THE TYPE OF THE %<NAME PARAMETER GIVEN WHEN
CALLED.
.S
^WHEN READING NUMBERS, CHARACTERS ARE READ UP TO, BUT NOT INCLUDING
THE FIRST NON-NUMERIC CHARACTER. ^THUS READING AN INTEGER FROM 12.34
WOULD RETURN THE INTEGER 12 AND LEAVE THE DECIMAL POINT AS THE NEXT
CHARACTER TO BE READ.
.UC.F.P
<ASSOCIATED <PROCEDURES: READ STRING, READ TEXT, READ OCT, READ HEX, WRITE, PRINT, PRINT FL
.LC.P
<ERROR <CONDITIONS: ^AS WELL AS THE ERRORS WHICH MAY RESULT FROM THE <READSYMBOL ROUTINE
(^SEE <READ <SYMBOL), THE FOLLOWING MAY ALSO OCCUR, DEPENDING ON THE
TYPE OF DATA BEING READ.
.NF.S
%<SIGNAL 1, 1, 0, "^INTEGER TOO LARGE"
%<SIGNAL 1, 1, N, "^INTEGER TOO LARGE FOR SHORT OR BYTE INTEGER"
%<SIGNAL 3, 1, SYMBOL, "^NUMBER NOT FOUND"
%<SIGNAL 3, 1, SYMBOL, "^INTEGER NOT FOUND"
%<SIGNAL 3, 2, SYMBOL, "^NO OPENING STRING QUOTE"
    WHERE 'SYMBOL' IS THE VALUE OF THE FIRST ILLEGAL SYMBOL FOUND.
%<SIGNAL 5, 6, TYPE, "^ILLEGAL %<NAME TYPE PARAMETER"
%<SIGNAL 6, 1, 0, "^STRING CAPACITY EXCEEDED"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^READ DA\\
.INDEX ^^READ DA\\
.P-8
<DEFINITION: ^THIS ROUTINE READS DATA FROM THE FILE ASSOCIATED WITH THE
GIVEN LOGICAL CHANNEL NUMBER INTO AN SPECIFIED AREA, STARTING
FROM A SPECIFIED BLOCK OF THE FILE.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^READ DA\\(%<INTEGER N, %<INTEGER<NAME BLOCK, %<NAME BEGIN,END)
.P
<CALL:	^^READ DA\\(N,BLOCK,BEGIN,END)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING THE LOGICAL CHANNEL NUMBER AND LYING
IN THE RANGE 1 TO 15
.I-8
BLOCK	IS THE NAME OF AN INTEGER VARIABLE WHICH ON ENTRY SPECIFIES THE
BLOCK NUMBER AT WHICH READING IS TO START AND ON EXIT CONTAINS THE BLOCK
NUMBER OF THE LAST BLOCK READ FROM
.I-8
BEGIN	IS THE NAME OF A VARIABLE SPECIFYING THE FIRST DATA ITEM INTO
WHICH DATA IS TO BE READ
.I-8
END	IS THE NAME OF A VARIABLE SPECIFYING THE LAST DAT ITEM INTO
WHICH DATA IS TO BE READ
.LM 8;.S 1
^DATA FROM THE FILE ASSOCIATED WITH A GIVEN LOGICAL CHANNEL
NUMBER N, STARTING AT BLOCK BLOCK IS WRITTEN INTO AN AREA STARTING AT
BEGIN AND FINISHING AT END.
^THIS AREA IS NORMALLY AN ARRAY BUT MAY BE ANY TYPE OF DATA ITEM
INCLUDING RECORDS.
.S 1
^DATA IS STORED ON THE EXTERNAL MEDIUM IN MULTIPLES OF FIXED LENGTH
BLOCKS (FOR DISK IT IS 200 OCTAL WORDS). ^INCOMPLETE BLOCKS READ ARE FILLED
OUT WITH WORDS CONTAINING ZERO. ^IT IS THE USERS RESPONSIBILITY, WHEN
READING, TO KNOW THE STARTING BLOCK AND LENGTH OF DATA RECORD TO BE READ,
AS READING ALWAYS STARTS AT THE HEAD OF THE BLOCK
SPECIFIED AND CONTINUES UNTIL THE REQUIRED DATA AREA IS FILLED
OR THE END-OF-FILE CONDITION OCCURS (%<EVENT 9).
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)OPEN DA, WRITE DA, CLOSE DA
.LC.P
<ERROR <CONDITIONS: ^THE FOLLOWING EVENTS MAY OCCUR:-
.NF.S
%<SIGNAL 20, 23, CHAN, "^READ/WRITE TO ILLEGAL <DA/SQ CHANNEL"
%<SIGNAL 20, 23, CHAN, "^READ/WRITE TO <DA/SQ CHANNEL BEFORE ^^OPEN\\ING IT"
%<SIGNAL 20, 24, CHAN, "^ACCESSING <DA CHANNEL BY <SQ ROUTINE OR VICE VERSA"
%<SIGNAL 20, 25, 0, "^STORAGE AREA FOR <DA/SQ ROUTINE INSIDE OUT"
%<SIGNAL 20, 26, BLOCK, "^ILLEGAL BLOCK NUMBER FOR <DA READ/WRITE ROUTINE"
%<SIGNAL 9, 0, CHAN, "<EOF ON <DA OR <SQ CHANNEL"


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^READ FS\\
.INDEX ^^READ FS\\
.P-8
<DEFINITION: ^THIS ROUTINE READS A ^^DEC\\SYSTEM-10 FILE SPECIFICATION FROM
THE CURRENTLY SELECTED INPUT STREAM AND PARSES IT INTO A FILE SPECIFICATION RECORD.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^READ FS\\(%<RECORD(FILESPEC)%<NAME FS)
.P
<CALL:	^^READ FS\\(FS)
.LM 16;.F;.S 1

.I-8
FS	IS THE NAME OF A FILE SPECIFICATION RECORD WHICH WILL CONTAIN
THE SPECIFICATION READ FROM THE INPUT STREAM
.LM 8;.S 1
^A ^^DEC\\SYSTEM-10 TYPE FILE SPECIFICATION IS READ FROM THE CURRENT
INPUT STREAM AND PARSED INTO THE FORM A FILE SPECIFICATION RECORD (SEE
SECTION 3).
.B
.UC.F.P
<ASSOCIATED <PROCEDURES: STRTOFS, FSTOSTR, WRITE FS, DEFAULT
.LC.P
<ERROR <CONDITIONS: ^IF A SYNTAX ERROR IS FOUND IN THE SPECIFICATION,
THE FOLLOWING EVENT IS CAUSED:-
.NF.S
%<SIGNAL 10, 9, 0, "^BAD FILE SPEC:-  'FILESPEC'"


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^READ HEX\\
.INDEX ^^READ HEX\\
.P-8
<DEFINITION: ^THIS ROUTINE READS AN HEXIDECIMAL NUMBER FROM THE CURRENTLY
SELECTED INPUT STREAM.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^READ HEX\\(%<INTEGER<NAME N)
.P
<CALL:	^^READ HEX\\(N)
.LM 16;.F;.S 1

.I-8
N	IS THE NAME OF AN INTEGER VARIABLE IN WHICH AN HEXIDECIMAL NUMBER
IS RETURNED
.LM 8;.S 1
^A SIGNED HEX NUMBER IS READ FROM THE CURRENT INPUT STREAM AND RETURNED
IN 'N'.
.S
^IF A NON-LEADING NON-HEXIDECIMAL CHARACTER IS FOUND IN A
SERIES OF DIGITS THEN THE NUMBER READ WILL ONLY INCLUDE THE DIGITS UP
TO THAT POINT.
.S
E.G.   A NUMBER  '-<1FA73J5' WILL GIVE AN HEXIDECIMAL NUMBER '-<1FA73' AND
THE NEXT CHARACTER AVAILABLE FOR INPUT WILL BE '<J'
.UC.F.P
<ASSOCIATED <PROCEDURES: HEXTOSTR, WRITE HEX, READ OCT
.LC.P
<ERROR <CONDITIONS: ^IF A LEADING NON-HEXIDECIMAL CHARACTER IS FOUND THE
FOLLOWING EVENT OCCURS:-
.NF.S
%<SIGNAL 3, 1, SYMBOL, "^HEX INTEGER NOT FOUND"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^READ ITEM\\
.INDEX ^^READ ITEM\\
.P-8
<DEFINITION: ^THIS ROUTINE READS THE NEXT SYMBOL FROM THE CURRENTLY SELECTED
INPUT STREAM INTO A SINGLE-CHARACTER STRING.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^READ ITEM\\(S)
.LM 16;.F;.S 1

.I-8
S	IS THE NAME OF A STRING IN WHICH THE SYMBOL IS STORED
.LM 8;.S 1
^THE NEXT SYMBOL ON THE CURRENT INPUT STREAM IS CONSTRUCTED INTO
A ONE-CHARACTER STRING  AND RETURNED IN S.
.UC.F.P
<ASSOCIATED <PROCEDURES: NEXT ITEM, NEXT SYMBOL, READ SYMBOL, SKIP SYMBOL
.LC.P
<ERROR <CONDITIONS: ^SEE <READ <SYMBOL.


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^READ OCTAL\\
.INDEX ^^READ OCTAL\\
.P-8
<DEFINITION: ^THIS ROUTINE READS AN OCTAL NUMBER FROM THE CURRENTLY
SELECTED INPUT STREAM.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^READ OCTAL\\(%<INTEGER<NAME N)
.P
<CALL:	^^READ OCTAL\\(N)
.LM 16;.F;.S 1

.I-8
N	IS THE NAME OF AN INTEGER VARIABLE IN WHICH AN OCTAL NUMBER
IS RETURNED
.LM 8;.S 1
^A SIGNED OCTAL NUMBER IS READ FROM THE CURRENT INPUT STREAM AND RETURNED
IN 'N'.
.S
^IF A NON-LEADING NON-OCTAL DIGIT IS FOUND IN A
SERIES OF DIGITS THEN THE NUMBER READ WILL ONLY INCLUDE THE DIGITS UP
TO THAT POINT.
.S
E.G.   A NUMBER  '-1067389' WILL GIVE AN OCTAL NUMBER '-10673' AND
THE NEXT CHARACTER AVAILABLE FOR INPUT WILL BE '8'
.UC.F.P
<ASSOCIATED <PROCEDURES: OCTTOSTR, WRITE OCT, READ HEX
.LC.F.P
<ERROR <CONDITIONS: ^IF A LEADING NON-OCTAL DIGIT IS FOUND THE FOLLOWING EVENT OCCURS:-
.S
%<SIGNAL 3, 1, SYMBOL, "^OCTAL INTEGER NOT FOUND"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^READ PPN\\
.INDEX ^^READ PPN\\
.P-8
<DEFINITION: ^THIS ROUTINE READS A PAIR OF OCTAL NUMBERS SEPARATED BY A
COMMA FROM THE CURRENTLY SELECTED INPUT STREAM AND RETURNS AN INTEGER
HAVING THE FIRST NUMBER IN THE LEFT HALF
AND THE SECOND NUMBER IN THE RIGHT HALF.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^READ PPN\\(%<INTEGER<NAME PPN)
.P
<CALL:	^^READ PPN\\(PPN)
.LM 16;.F;.S 1

.I-8
PPN	IS THE NAME OF AN INTEGER VARIABLE IN WHICH THE PAIR OF
OCTAL NUMBERS ARE RETURNED
.LM 8;.S 1
^A PAIR OF OCTAL NUMBERS SEPARATED BY A COMMA ARE READ FROM THE
THE CURRENT INPUT STREAM.  ^AN INTEGER IS RETURNED WITH THE
FIRST NUMBER IN THE LEFT HALF AND THE SECOND NUMBER IN THE RIGHT HALF.
.UC.F.P
<ASSOCIATED <PROCEDURES: WRITE PPN, READ OCTAL, WRITE OCTAL
.LC.P
<ERROR <CONDITIONS: ^IF NO COMMA IS FOUND AFTER THE FIRST NUMBER ONLY
THAT FIRST NUMBER IS READ.  ^OTHERWISE SEE <READ <OCTAL
.S 4;.TEST PAGE 20;.NAP;.F;.C
^^READ SQ\\
.INDEX ^^READ SQ\\
.P-8
<DEFINITION: ^THIS ROUTINE READS DATA FROM THE FILE ASSOCIATED WITH THE
GIVEN LOGICAL CHANNEL NUMBER INTO A SPECIFIED AREA.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^READ SQ\\(%<INTEGER N, %<NAME BEGIN,END)
.P
<CALL:	^^READ SQ\\(N,BEGIN,END)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING THE LOGICAL CHANNEL NUMBER AND LYING
IN THE RANGE 1 TO 15
.I-8
BEGIN	IS THE NAME OF A VARIABLE SPECIFYING THE FIRST DATA ITEM INTO
WHICH DATA IS TO BE READ
.I-8
END	IS THE NAME OF A VARIABLE SPECIFYING THE LAST DATA ITEM INTO
WHICH DATA IS TO BE READ
.LM 8;.S 1
^DATA FROM THE FILE ASSOCIATED WITH A GIVEN LOGICAL CHANNEL
NUMBER N IS READ INTO AN AREA STARTING AT
BEGIN AND FINISHING AT END.
^THIS AREA IS NORMALLY AN ARRAY BUT MAY BE ANY TYPE OF DATA ITEM
INCLUDING RECORDS.
^THE FIRST CALL OF THIS ROUTINE AFTER A SEQUENTIAL CHANNEL HAS BEEN
OPENED DETERMINES THAT ALL SUBSEQUENT ACCESS ON THAT CHANNEL MUST BE
FOR READING UNLESS THE CHANNEL IS RE-OPENED.
.S 1
^DATA IS STORED ON THE EXTERNAL MEDIUM AS AN UNSTRUCTURED SEQUENCE
OF WORDS. ^IT IS THE USERS RESPONSIBILITY TO KNOW THE NATURE OF THE
DATA STORED BECAUSE ONCE READ, DATA CANNOT BE REREAD UNLESS THE CHANNEL
IS RE-OPENED. ^ONCE STARTED, READING CONTINUES UNTIL THE REQUIRED
AREA IS FILLED OR THE END-OF-FILE CONDITION OCCURS (%<EVENT 9).
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)OPEN SQ, WRITE SQ, CLOSE SQ
.LC.P
<ERROR <CONDITIONS: ^THE FOLLOWING EVENTS MAY OCCUR:-
.NF.S
%<SIGNAL 20, 23, CHAN, "^READ/WRITE TO ILLEGAL <DA/SQ CHANNEL"
%<SIGNAL 20, 23, CHAN, "^READ/WRITE TO <DA/SQ CHANNEL BEFORE ^^OPEN\\ING IT"
%<SIGNAL 20, 24, "^ACCESSING <DA CHANNEL BY <SQ ROUTINE OR VICE VERSA"
%<SIGNAL 20, 25, 0, "^STORAGE AREA FOR <DA/SQ ROUTINE INSIDE OUT"
%<SIGNAL 20, 26, BLOCK, "^ILLEGAL BLOCK NUMBER FOR <DA READ/WRITE ROUTINE"
%<SIGNAL 20, 27, CHAN, "^INPUTTING FROM <SQ CHANNEL SET FOR OUTPUT"
%<SIGNAL 9, 0, CHAN, "<EOF ON <DA OR <SQ CHANNEL"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^READ STRING\\
.INDEX ^^READ STRING\\
.P-8
<DEFINITION: ^THIS ROUTINE READS A STRING FROM THE CURRENTLY SELECTED INPUT
STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^READ STRING\\(S)
.LM 16;.F;.S 1

.I-8
S	IS THE NAME OF A STRING INTO WHICH THE STRING OF SYMBOLS IS STORED
.LM 8;.S 1
^THE STRING OF SYMBOLS, WHICH MUST BE ENCLOSED BETWEEN
STRING QUOTES, IS READ FROM THE CURRENT INPUT STREAM INTO 'S'.
^TO INCLUDE A DOUBLE QUOTE CHARACTER IN THE STRING TO BE
READ, TWO DOUBLE QUOTES SHOULD BE GIVEN.
.UC.F.P
<ASSOCIATED <PROCEDURES: PRINT STRING, READ TEXT, READ
.LC.P
<ERROR <CONDITIONS: ^THE FOLLOWING TWO EVENTS MAY OCCUR:-
.NF.S
%<SIGNAL 3, 2, SYMBOL, "^NO OPENING STRING QUOTE"
%<SIGNAL 6, 1, 0, "^STRING CAPACITY EXCEEDED"
.F.S
^AND ALSO SEE <READ <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^READ SYMBOL\\
.INDEX ^^READ SYMBOL\\
.P-8
<DEFINITION: ^THIS ROUTINE READS THE NEXT SYMBOL FROM THE CURRENTLY SELECTED
INPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^READ SYMBOL\\(S)
.LM 16;.F;.S 1

.I-8
S	IS THE NAME OF AN INTEGER, SHORT INTEGER OR BYTE INTEGER VARIABLE
INTO WHICH THE NEXT SYMBOL IS READ
.LM 8;.S 1
^THE NEXT SYMBOL ON THE INPUT STREAM IS READ INTO 'S'. ^THE NUMBER
OF BITS READ DEPENDS ON THE MODE AND TYPE OF DEVICE WHICH IS CURRENTLY
SELECTED.
^IN <ASCII MODE, NULL CHARACTERS AND CARRIAGE RETURNS ARE IGNORED,
ALL OTHER SYMBOLS ARE PASSED THROUGH.
.UC.F.P
<ASSOCIATED <PROCEDURES: NEXT SYMBOL, SKIP SYMBOL
.LC.P
<ERROR <CONDITIONS: ^WHEN THE END OF A FILE IS READ THE FOLLOWING EVENT IS CAUSED:-
.NF.S
%<SIGNAL 9, 0, STREAM, "<EOF ON STREAM"
.F.S
^IF A SYSTEM-DETECTED ERROR OCCURS DURING READING FROM THE CURRENT DEVICE
THE FOLLOWING OCCURS:-
.NF.S
%<SIGNAL 4, 1, STATUS, "<I/O TRANSMISSION ERROR"
.F.S
WHERE 'STATUS' IS A DEVICE DEPENDENT STATUS WORD WHOSE MEANING
IS DESCRIBED IN THE ^^DEC\\SYSTEM-10 <MONITOR <CALLS
^MANUAL UNDER THE SECTION DEALING WITH THE PARTICULAR DEVICE IN QUESTION.
^IT SHOULD BE NOTED THAT THE STATUS WILL BE OUTPUT AS A DECIMAL NUMBER BUT SHOULD
BE INTERPRETED IN OCTAL.


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^READ TEXT\\
.INDEX ^^READ TEXT\\
.P-8
<DEFINITION: ^THIS ROUTINE READS A STRING OF TEXT FROM THE CURRENTLY
SELECTED INPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^READ TEXT\\(S,DELIM)
.LM 16;.F;.S 1

.I-8
S	IS THE NAME OF A STRING INTO WHICH THE STRING OF SYMBOLS IS STORED
.I-8
DELIM	IS AN INTEGER VARIABLE CONTAINING THE VALUE OF THE
<ASCII CHARACTER ON WHICH READING IS TO TERMINATE
.LM 8;.S 1
^THE STRING OF SYMBOLS, FROM THE NEXT SYMBOL UP TO THE NEXT OCCURRENCE
OF THE GIVEN DELIMITER, IS READ FROM THE CURRENT INPUT STREAM INTO 'S'.
^THE TERMINATING DELIMITER IS READ BUT NOT INCLUDED IN THE STRING.
.S
E.G. ^^READ TEXT\\(STR,NL) WILL RETURN A STRING CONTAINING THE
REST OF THE CURRENT LINE, BUT THE NEXT CHARACTER TO BE READ WILL BE THE
FIRST CHARACTER OF THE NEXT LINE.
.UC.F.P
<ASSOCIATED <PROCEDURES: PRINT STRING, READ STRING
.LC.P
<ERROR <CONDITIONS: ^THE FOLLOWING EVENT MAY OCCUR:-
.NF.S
%<SIGNAL 6, 1, 0, "^STRING CAPACITY EXCEEDED"
.F.S
^AND ALSO SEE <READ <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^REAL\\
.INDEX ^^REAL\\
.P-8
<DEFINITION: ^THIS MAP ENABLES THE USER TO ACCESS DIRECTLY A PARTICULAR
LOCATION WHOSE ADDRESS IS SPECIFIED.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^REAL\\(ADR)
.LM 16;.F;.S 1

.I-8
ADR	IS AN INTEGER EXPRESSION GIVING THE ADDRESS OF THE
REQUIRED LOCATION.
.LM 8;.S 1
^THIS MAP ALLOWS THE USER TO READ OR WRITE DIRECTLY TO A LOCATION
IN STORE BY SPECIFYING THE ABSOLUTE ADDRESS IN 'ADR'.
.UC.F.P
<ASSOCIATED <PROCEDURES: BYTE INTEGER, SHORT INTEGER, INTEGER,
RECORD, STRING
.LC.P
<ERROR <CONDITIONS: ^SEE <INTEGER.


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^RECORD\\
.INDEX ^^RECORD\\
.P-8
<DEFINITION: ^THIS MAP ALLOWS A SECTION OF DATA WHOSE START ADDRESS IS GIVEN
TO BE ACCESSED AS A RECORD.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^RECORD\\(ADR)
.LM 16;.F;.S 1

.I-8
ADR	IS AN INTEGER EXPRESSION BEING THE ABSOLUTE ADDRESS OF THE
START OF THE DATA SECTION TO BE MAPPED ONTO
.LM 8;.S 1
^THE ADDRESS OF THE START OF THE GIVEN DATA SECTION, SUCH THAT
IT CAN BE ACCESSED AS A RECORD, IS RETURNED VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: BYTE INTEGER, SHORT INTEGER, INTEGER,
REAL, STRING
.LC.P
<ERROR <CONDITIONS: ^SEE <INTEGER.

.LC.S 4;.TEST PAGE 20;.NAP;.F;.C
^^RELEASE\\
.INDEX ^^RELEASE\\
.P-8
<DEFINITION: ^THIS ROUTINE RELEASES THE DEVICE ATTACHED TO A GIVEN
PHYSICAL CHANNEL NUMBER.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^RELEASE\\(%<INTEGER N)
.P
<CALL:	^^RELEASE\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION GIVING THE PYSICAL CHANNEL NUMBER
ASSOCIATED WITH A PARTICULAR DEVICE
.LM 8;.S 1
^THIS ROUTINE IS USED BY THE RUN TIME SYSTEM TO RELEASE
THE DEVICES ASSOCIATED WITH <I/O STREAMS AND CHANNELS
IN THE <CLOSE <INPUT, <CLOSE <OUTPUT, <CLOSE <DA AND <CLOSE <SQ ROUTINES.
.UC.F.P
<ASSOCIATED <PROCEDURES: GET CHANNEL, IOUUO, CLOSE, FILOP, TAPOP
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^REM\\
.INDEX ^^REM\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE REMAINDER OF
THE DIVISION SPECIFIED IN ITS PARAMETERS
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	X=^^REM\\(N,M)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING THE DIVIDEND
.I-8
M	IS AN INTEGER EXPRESSION BEING THE DIVISOR
.LM 8;.S 1
^THE REMAINDER OF THE GIVEN DIVISION IS RETURNED VIA %<RESULT.
^THE QUOTIENT IS LOST.
.F.P
<ERROR <CONDITIONS: ^IF THE DIVISOR IS ZERO, THE FOLLOWING FATAL ERROR WILL OCCUR:-
.NF.S
?ARITHMETIC OVERFLOW AT USER <PC 'ADDR'

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^RENAME\\
.INDEX ^^RENAME\\
.P-8
<DEFINITION: ^THIS ROUTINE ALLOWS A SPECIFIED DISK FILE TO BE RENAMED.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^RENAME\\(%<STRING(255) OLD,NEW)
.P
<CALL:	^^RENAME\\(OLD,NEW)
.LM 16;.F;.S 1

.I-8
OLD	IS A STRING CONTAINING THE NAME OF THE FILE TO BE RENAMED
.I-8
NEW	IS A STRING CONTAINING THE NAME WHICH FILE IS TO BE GIVEN
.LM 8;.S 1
^A SPECIFIED FILE IS GIVEN A NEW NAME.
.UC.F.P
<ASSOCIATED <PROCEDURES: XRENAME, (X)COPY, (X)DELETE, (X)ISFILE
.LC.P
<ERROR <CONDITIONS: ^IF THE RENAMING IS NOT SUCCESSFUL, THE FOLLOWING EVENT OCCURS
.NF.S
%<SIGNAL 10, 4, ERR, "^CANNOT <RENAME/DELETE 'FILESPEC'"
.F.S
^THE MEANING OF ERR IS GIVEN IN APPENDIX ^E OF THE ^^DEC\\SYSTEM-10 <MONITOR <CALLS ^MANUAL.
.S
^OTHER POSSIBLE ERRORS ARE:-
.NF.S
%<SIGNAL 10, 9, 0, "^BAD FILE SPECIFICATION - 'FILESPEC'"
%<SIGNAL 10, 6, 0, "^CANNOT OPEN DEVICE FOR 'FILESPEC'"
%<SIGNAL 2, 5, 0, "^ALL <I/O CHANNELS IN USE"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^REPORT\\
.INDEX ^^REPORT\\
.P-8
<DEFINITION: ^THIS ROUTINE PRINTS THE GIVEN STRING ON THE USERS CONSOLE.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^REPORT\\(%<STRING(255) S)
.P
<CALL:	^^REPORT\\(S)
.LM 16;.F;.S 1

.I-8
S	IS A STRING TO BE OUTPUT
.LM 8;.S 1
^THE GIVEN STRING IS OUTPUT ON THE USERS CONSOLE, IRRESPECTIVE
OF WHETHER OR NOT IT IS THE CURRENTLY SELECTED OUTPUT STREAM.
.UC.F.P
<ASSOCIATED <PROCEDURES: PRINT STRING, PROMPT
.LC.P
<ERROR <CONDITIONS: ^SEE <PRINT <STRING.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^RESET INPUT\\
.INDEX ^^RESET INPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE REWINDS THE CURRENTLY SELECTED INPUT STREAM
TO THE BEGINNING.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^RESET INPUT\\
.P
<CALL:	^^RESET INPUT\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^THE CURRENT INPUT STREAM IS CLOSED AND RE-OPENED SO THAT
INPUT STARTS FROM THE BEGINNING AGAIN.
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)DEFINE INPUT, SDEF INPUT, SELECT INPUT, CLOSE INPUT
.LC.P
<ERROR <CONDITIONS: ^IF FOR SOME REASON AN INPUT FILE CANNOT BE RE-OPENED
THE FOLLOWING EVENT OCCURS:-
.NF.S
%<SIGNAL 10, 12, STREAM, "^CANNOT <RESET INPUT STREAM"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^RESET OUTPUT\\
.INDEX ^^RESET OUTPUT\\
.P-8
<DEFINITION: ^THIS  ROUTINE REWINDS THE CURRENTLY SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^RESET OUTPUT\\
.P
<CALL:	^^RESET OUTPUT\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^THE CURRENT OUTPUT STREAM IS REWOUND TO THE BEGINNING.
^IN THE CASE OF THE USERS CONSOLE, IT WILL HAVE NO EFFECT. ^IN THE CASE
OF DISK TYPE DEVICES, IT WILL OVERWRITE ALL PREVIOUS OUTPUT.
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)DEFINE OUTPUT, SDEF OUTPUT, SELECT OUTPUT, CLOSE OUTPUT
.LC.P
<ERROR <CONDITIONS: ^IF FOR SOME REASON A FILE CANNOT BE RE-OPENED THE
FOLLOWING EVENT WILL OCCUR:-
.NF.S
%<SIGNAL 10, 13, STREAM, "^CANNOT <RESET OUTPUT STREAM"


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^RESTORE\\
.INDEX ^^RESTORE\\
.P-8
<DEFINITION: ^THIS ROUTINE RESTORES THE REGISTERS IN A <MACRO PROGRAM
WHICH HAS JUST CALLED AN <IMP PROCEDURE.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^RESTORE\\
.P
<CALL:	^^RESTORE\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^ONCE A <MACRO PROGRAM HAS SAVED THE REGISTERS WITH A CALL TO <SAVE <ACS
AND THEN CALLED THE <IMP PROCEDURE, THIS ROUTINE WILL
RESET THE <MACRO ENVIRONMENT TO WHAT IT WAS BEFORE <IMPENV WAS CALLED.
^THE REGISTERS ARE ALL RESTORED, WITH THE EXCEPTION OF REGISTERS
0 AND 1 IN CASE A FUNCTION OR MAP HAS BEEN CALLED, AND HAS RETURNED
AN ARGUMENT.
.S
^A TYPICAL CALLING SEQUENCE FROM MACRO IS THEREFORE:-
.UC.NF
  PUSHJ   P,SAVEACS_#_# ;SAVE THE MACRO ENVIRONMENT
  PUSHJ   P,FRED_#_#    ;CALL THE REQUIRED IMP ROUTINE
  PUSHJ   P,RESTORE_#_# ;RESTORE THE MACRO ENVIRONMENT
.LC.F
.UC.F.P
<ASSOCIATED <PROCEDURES: SAVE ACS, INITHEAP, INITIO, INITSTACK
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^RUN\\
.INDEX ^^RUN\\
.P-8
<DEFINITION: ^THIS ROUTINE CAUSES THE SPECIFIED PROGRAM TO BE RUN.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^RUN\\(%<STRING(6) DEV,FILE, %<STRING(3) EXT, %<INTEGER PPN,INC)
.P
<CALL:	^^RUN\\(DEV,FILE,EXT,PPN,INC)
.LM 16;.F;.S 1

.I-8
DEV	IS A STRING CONTAINING THE DEVICE NAME OF THE PROGRAM TO BE RUN
.I-8
FILE	IS A STRING CONTAINING THE FILE NAME OF THE PROGRAM TO BE RUN
.I-8
EXT	IS A STRING CONTAINING THE EXTENSION OF THE FILE NAME OF THE
PROGRAM TO BE RUN
(^IF AN EXTENSION OF <.SAV IS GIVEN <.EXE WILL BE LOOKED FOR FIRST.)
.I-8
PPN	IS AN INTEGER EXPRESSION BEING THE PROJECT-PROGRAMMER PAIR OF THE
PROGRAM TO BE RUN
.I-8
INC	IS AN INTEGER EXPRESSION SPECIFYING THE START ADDRESS INCREMENT
FOR THE PROGRAM TO BE RUN (ONLY 0 AND 1 ARE ALLOWED). 1 BEING THE
<CCL
START ADDRESS INCREMENT.
.LM 8;.S 1
^ALL THE CURRENT INPUT AND OUTPUT STREAMS ARE CLOSED AND
THE PROGRAM SPECIFIED IS RUN THEREBY DESTROYING THE CURRENT CORE IMAGE.
.UC.F.P
<ASSOCIATED <PROCEDURES: GETSEG
.LC.P
<<ERROR <CONDITIONS: ^THE MONITOR MAY PRODUCE ONE OF THE FOLLOWING MESSAGES:-
.NF.S
.UC
?NOT A SAVE FILE
? ... .SAV NOT FOUND
?TRANSMISSION ERROR
?LOOKUP FAILURE 'N'
?'N'P OF CORE NEEDED
?NO START ADDRESS
.LC

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SAVE ACS\\
.INDEX ^^SAVE ACS\\
.P-8
<DEFINITION: ^THIS ROUTINE SAVES THE REGISTERS WHEN CALLING AN <IMP ROUTINE FROM <MACRO.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^SAVE ACS\\
.P
<CALL:	^^SAVE ACS\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
WHEN USING <IMP FROM MACRO, THE DATA STACK POINTER'S LEFT HALF WILL
BE CORRUPTED, AND NONE OF THE REST OF THE REGISTERS CAN BE GUARANTEED.
^THIS ROUTINE SAVES REGISTERS 2-17. ^IT IS ALSO NECESSARY THAT THERE IS
ENOUGH STACK SPACE FOR <IMP SO THAT IT DOES NOT TRY TO EXPAND IT.
^IF <IMP IS REQUIRED TO DO <I/O THEN THE ROUTINE
<INITIO MUST BE CALLED, AND IF ANY BUT STREAMS ZERO ARE TO BE USED THEN
THE HEAP MUST BE SET UP (SEE <INITHEAP).
^THIS ROUTINE IS TO BE USED IN CONJUCTION WITH <RESTORE
WHICH WILL RESTORE THE ORIGINAL REGISTERS.
.S
^A TYPICAL CALLING SEQUENCE FROM MACRO IS THEREFORE:-
.NAP.UC.NF
  PUSHJ   P,SAVEACS_#_# ;SAVE THE MACRO ENVIRONMENT
  PUSHJ   P,FRED_#_#    ;CALL THE REQUIRED IMP ROUTINE
  PUSHJ   P,RESTORE_#_# ;RESTORE THE MACRO ENVIRONMENT
.AP.LC.F
.UC.F.P
<ASSOCIATED <PROCEDURES: RESTORE, INITHEAP, INITIO, INITSTACK
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SDEF INPUT\\
.INDEX ^^SDEF INPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE OPENS THE STRING GIVEN IN THE STRING NAME
PARAMETER AND ASSOCIATES IT WITH A LOGICAL INPUT STREAM NUMBER.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^SDEF INPUT\\(%<INTEGER N, %<STRINGNAME S)
.P
<CALL:	^^SDEF INPUT\\(N,S)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION SPECIFYING THE LOGICAL INPUT
STREAM NUMBER IN THE RANGE 1 TO 15
.I-8
S	IS THE NAME OF A STRING VARIABLE TO BE OPENED FOR INPUT
.LM 8;.S 1
^THE STRING SPECIFIED IS ASSOCIATED WITH THE GIVEN LOGICAL
INPUT STREAM NUMBER, SO THAT INPUT MAY BE SUBEQUENTLY READ DIRECTLY FROM IT.
.F.P
<ASSOCIATED <PROCEDURES: <DEFINE <INPUT, <XDEFINE <INPUT, <SELECT <INPUT, <CLOSE <INPUT, <RESET <INPUT
.LC.P
<ERROR <CONDITIONS: ^A STREAM NUMBER LYING OUTSIDE THE RANGE 1 TO 15 CAUSES EVENT
.NF.S
%<SIGNAL 10, 1, N, "^DEFINING ILLEGAL STREAM"
.F.S
^TRYING TO RE-DEFINE A PREVIOUSLY DEFINED STREAM CAUSES EVENT
.NF.S
%<SIGNAL 10, 2, N, "^STREAM/CHANNEL ALREADY DEFINED"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SDEF OUTPUT\\
.INDEX ^^SDEF OUTPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE OPENS THE STRING GIVEN IN THE STRING NAME
PARAMETER AND ASSOCIATES IT WITH A LOGICAL OUTPUT STREAM NUMBER.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^SDEF OUTPUT\\(%<INTEGER N, %<STRINGNAME S)
.P
<CALL:	^^SDEF OUTPUT\\(N,S)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION SPECIFYING THE LOGICAL OUTPUT
STREAM NUMBER IN THE RANGE 1 TO 15
.I-8
S	IS THE NAME OF A STRING VARIABLE TO BE OPENED FOR OUTPUT
.LM 8;.S 1
^THE STRING SPECIFIED IS ASSOCIATED WITH THE GIVEN LOGICAL
OUTPUT STREAM NUMBER, SO THAT OUTPUT MAY BE SUBEQUENTLY WRITTEN DIRECTLY TO IT.
.F.P
<ASSOCIATED <PROCEDURES: <DEFINE <OUTPUT, <XDEFINE <OUTPUT, <SELECT <OUTPUT, <CLOSE <OUTPUT, <RESET <OUTPUT
.LC.P
<ERROR <CONDITIONS:  ^SEE <SDEF <INPUT

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SELECT INPUT\\
.INDEX ^^SELECT INPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE SELECTS THE GIVEN STREAM NUMBER TO BE THE STREAM
FROM WHICH ALL SUBSEQUENT INPUT WILL BE TAKEN.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^SELECT INPUT\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING THE STREAM NUMBER TO BE SELECTED
IN THE RANGE 0 TO 15
.LM 8;.S 1
^THE GIVEN STREAM NUMBER IS SELECTED TO BE THE ONE FROM WHICH
ALL SUBSEQUENT INPUT IS TAKEN, UNTIL ANOTHER CALL OF <SELECT <INPUT.
.S
^IF THE STREAM NUMBER SELECTED IS NOT DEFINED BY THE
USER, IT DEFAULTS TO BEING THE <NUL: DEVICE. I.E. ANY INPUT WILL CAUSE
AN END OF FILE EVENT (%<EVENT 9).
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)DEFINE INPUT, SDEF INPUT, CLOSE INPUT, RESET INPUT
.LC.P
<ERROR <CONDITIONS: ^IF THE STREAM NUMBER GIVEN LIES OUTSIDE THE RANGE 0 TO 15 THE
FOLLOWING EVENT IS CAUSED:-
.NF.S
%<SIGNAL 10, 10, N, "^SELECTING ILLEGAL INPUT STREAM"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SELECT OUTPUT\\
.INDEX ^^SELECT OUTPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE SELECTS THE GIVEN STREAM NUMBER TO BE THE STREAM
TO WHICH ALL SUBSEQUENT OUTPUT WILL BE SENT.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^SELECT OUTPUT\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING THE STREAM NUMBER TO BE SELECTED
IN THE RANGE 0 TO 15
.LM 8;.S 1
^THE GIVEN STREAM NUMBER IS SELECTED TO BE THE ONE TO WHICH
ALL SUBSEQUENT OUTPUT IS SENT, UNTIL ANOTHER CALL OF <SELECT <OUTPUT.
.S
^IF THE STREAM NUMBER SELECTED IS NOT DEFINED BY THE
USER, IT DEFAULTS TO BEING THE <NUL: DEVICE. I.E. ANY OUTPUT WILL BE LOST.
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)DEFINE OUTPUT, SDEF OUTPUT, CLOSE OUTPUT, RESET OUTPUT
.LC.P
<ERROR <CONDITIONS: ^IF THE STREAM NUMBER GIVEN LIES OUTSIDE THE RANGE 0 TO 15 THE
FOLLOWING EVENT IS CAUSED:-
.NF.S
%<SIGNAL 10, 11, N, "^SELECTING ILLEGAL OUTPUT STREAM"


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SET STREAMS\\
.INDEX ^^SET STREAMS\\
.P-8
<DEFINITION: ^THIS ROUTINE SETS UP, UP TO THREE INPUT AND THREE OUTPUT STREAMS.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^SET STREAMS\\
.P
<CALL:	^^SET STREAMS\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^THE USER IS PROMPTED,
.NF.S
^FILES:- 
.F.S
TO WHICH THE RESPONSE IS A LIST OF UP TO THREE OUTPUT FILE SPECIFICATIONS
SEPARATED BY COMMAS, FOLLOWED BY AN EQUALS SIGN AND UP TO THREE
INPUT FILE SPECIFICATIONS SEPARATED BY COMMAS. ^THE COMMAS MAY BE ABSENT
IF NO FURTHER OUTPUT OR INPUT FILE SPECIFICATIONS FOLLOW.
^SIMILARLY NO EQUALS SIGN IS NEEDED IF NO INPUT FILES ARE GIVEN.
 ^THE STREAMS ARE SET UP TO BE STREAM 1, 2 AND 3 RESPECTIVELY FOR BOTH THE
OUTPUT AND INPUT SIDES.
.S
^THE FOLLOWING ARE EXAMPLES OF LEGAL RESPONSES.
.NF.S
^FILES:- TTY:=FRED.IMP
	!SETS OUTPUT STREAM 1 = <TTY:
	!SETS INPUT STREAM 1 = <FRED.IMP
^FILES:- =FRED.IMP,JOE.IMP,TTY:
	!SETS INPUT STREAM 1 = <FRED.IMP
	!SETS INPUT STREAM 2 = <JOE.IMP
	!SETS INPUT STREAM 3 = <TTY:
^FILES:- FRED.IMP
	!SETS OUTPUT STREAM 1 = <FRED.IMP
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)DEFINE (INPUT/OUTPUT), SELECT (INPUT/OUTPUT),
CLOSE (INPUT/OUTPUT), READFS, CUSPFS
.F.LC.P
<ERROR <CONDITIONS: ^IF A BAD COMMAND LINE IS TYPED THE FOLLOWING MESSAGE
IS OUTPUT
.NF.S
^COMMAND ERROR:  "REST OF LINE"
.S.F
TOGETHER WITH THE REST OF THE INPUT LINE STARTING AFTER THE OFFENDING CHARACTER.
.B
^FOR NON-SYNTACTIC ERRORS SEE <DEFINE <INPUT, <DEFINE <OUTPUT.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SETSTS\\
.INDEX ^^SETSTS\\
.P-8
<DEFINITION: ^THIS ROUTINE SETS THE STATUS BITS OF THE DEVICE
ASSOCIATED WITH A GIVEN PHYSICAL CHANNEL NUMBER.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^SETSTS\\(%<INTEGER CHAN,BITS)
.P
<CALL:	^^SETSTS\\(CHAN,BITS)
.LM 16;.F;.S 1

.I-8
CHAN	IS AN INTEGER EXPRESSION GIVING THE NUMBER OF THE PHYSICAL
CHANNEL NUMBER TO BE AFFECTED (THE LEFT-HALF OF THE <FILOPFN ITEM IN AN
<SCB RECORD)
.I-8
BITS	IS AN INTEGER EXPRESSION GIVING THE STATUS BITS TO BE CHANGED
.LM 8;.S 1
^EACH PHYSICAL CHANNEL NUMBER HAS ASSOCIATED WITH IT A SET OF STATUS BITS
WHICH THIS ROUTINE CAN SET. ^NOTE THAT THE
MEANING OF THESE BITS DEPEND ON THE PARTICULAR DEVICE (SEE
THE ^^DEC\\SYSTEM-10 <MONITOR <CALLS ^MANUAL FOR A PARTICULAR DEVICE).
.UC.F.P
<ASSOCIATED <PROCEDURES: GETSTS, INSTATUS, OUTSTATUS
.LC.P
<ERROR <CONDITIONS: ^WHEN THE CHANNEL NUMBER REFERS TO A CHANNEL WHICH HAS
NO DEVICE ASSOCIATED WITH IT, THE MONITOR GIVES THE FOLLOWING FATAL ERROR:-
.NF.S
?<I/O <TO <UNASSIGNED <CHANNEL <AT <USER ADDR


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SHIFTC\\
.INDEX ^^SHIFTC\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION CYCLICALLY SHIFTS A GIVEN BIT
PATTERN A SPECIFIED NUMBER OF BIT POSITIONS.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^SHIFTC\\(%<INTEGER N,M)
.P
<USE:	X=^^SHIFTC\\(N,M)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION WHOSE BINARY PATTERN IS TO BE SHIFTED
.I-8
M	IS AN INTEGER EXPRESSION INDICATING THE NUMBER OF BIT POSITIONS THAT
'N' IS TO BE SHIFTED.
.LM 8;.S 1
^THE BIT PATTERN IN 'N' IS SHIFTED 'M' (MODULO 72) PLACES, LEFT OR RIGHT
ACCORDING TO THE SIGN OF 'M' (+ OR - RESPECTIVELY). ^BITS LOST OFF ONE
END OF THE WORD, REAPPEAR IN THE SAME ORDER AT THE OTHER END OF THE WORD.
.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SHORT INTEGER\\
.INDEX ^^SHORT INTEGER\\
.P-8
<DEFINITION: ^THIS MAP ENABLES THE USER TO ACCESS DIRECTLY A PARTICULAR
SHORT INTEGER WHOSE ADDRESS IS SPECIFIED.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^SHORT INTEGER\\(ADR)
.LM 16;.F;.S 1

.I-8
ADR	IS AN INTEGER EXPRESSION GIVING THE ADDRESS OF THE
REQUIRED LOCATION.
.LM 8;.S 1
^THIS MAP ALLOWS THE USER TO READ OR WRITE DIRECTLY TO A LOCATION
IN STORE BY SPECIFYING THE ABSOLUTE ADDRESS IN 'ADR'.
.UC.F.P
<ASSOCIATED <PROCEDURES: BYTE INTEGER, INTEGER, REAL,
STRING, RECORD
.LC.P
<ERROR <CONDITIONS: ^IF THE VALUE OF 'ADR' LIES OUTSIDE THE CURRENT ADDRESSING SPACE THE
FOLLOWING FATAL ERROR WILL OCCUR:-
.NF.S
?<IMP: ^ILL ^MEM ^REF AT USER PC  'ADDR'

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SIXTOSTR\\
.INDEX ^^SIXTOSTR\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION TAKES A ^^DEC\\SYSTEM-10 <SIXBIT
INTEGER WORD AND RETURNS IT AS AN <IMP STRING OF SIX <ASCII CHARACTERS.
.NF;.P
<SPEC:	%<EXTERNALSTRING(6)%FN ^^SIXTOSTR\\(%<INTEGER SIXBIT)
.P
<USE:	S=^^SIXTOSTR\\(SIXBIT)
.LM 16;.F;.S 1

.I-8
SIXBIT	IS AN INTEGER EXPRESSION REPRESENTING A WORD OF SIX <SIXBIT CHARACTERS
.LM 8;.S 1
^AN <IMP STRING OF SIX <ASCII CHARACTERS IS GENERATED FROM
THE GIVEN <SIXBIT INTEGER WORD AND RETURNED VIA %<RESULT. ^SEE THE
^^DEC\\SYSTEM-10 ^HARDWARE ^REFERENCE ^MANUAL FOR A LIST OF THE <SIXBIT
CHARACTER SET.
.UC.F.P
<ASSOCIATED <PROCEDURES: STRTOSIX
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SKIP SYMBOL\\
.INDEX ^^SKIP SYMBOL\\
.P-8
<DEFINITION: ^THIS ROUTINE PASSES OVER THE NEXT SYMBOL ON THE CURRENTLY
SELECTED INPUT STREAM, WITHOUT READING IT.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^SKIP SYMBOL\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^THE NEXT CHARACTER FOR INPUT IS PASSED OVER AND IGNORED.
.UC.F.P
<ASSOCIATED <PROCEDURES: READ SYMBOL, NEXT SYMBOL
.LC.P
<ERROR <CONDITIONS: ^SEE <READ <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SLEEP\\
.INDEX ^^SLEEP\\
.P-8
<DEFINITION: ^THIS ROUTINE CAUSES THE USERS PROGRAM TO GO TO SLEEP FOR
A SPECIFIED LENGTH OF TIME.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^SLEEP\\(%<INTEGER N)
.P
<CALL:	^^SLEEP\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION INDICATING THE TIME IN MILLISECONDS FOR
THE REQUIRED SLEEP
.LM 8;.S 1
^THE PROGRAM IS CAUSED TO GO INTO A SPECIAL STATE CALLED HIBERNATION
FROM WHICH IT AWAKENS AFTER THE GIVEN NUMBER OF MILLISECONDS. ^THE
MAXIMUM PERIOD IS 68 SECONDS.
.P
<ERROR <CONDITIONS: ^A VALUE OF N <= 0 WILL CAUSE AN IMMEDIATE RETURN.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SP\\
.INDEX ^^SP\\
.P-8
<DEFINITION: ^THIS INTEGER CONSTANT GIVES THE INTERNAL <ASCII CODE VALUE
FOR THE SPACE CHARACTER.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^SP\\
.F.LM 8;.S 1
^THE NUMERICAL VALUE OF THE SPACE CHARACTER IS GIVEN.
.UC.F.P
<ASSOCIATED <CONSTANTS: NL, TAB, ESC, FF
.LC

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SPACE\\
.INDEX ^^SPACE\\
.P-8
<DEFINITION: ^THIS ROUTINE CAUSES ONE 'SPACE' CHARACTER TO BE SENT TO
THE CURRENTLY SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^SPACE\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
^ONE 'SPACE' CHARACTER IS SENT TO THE OUTPUT STREAM.
.UC.F.P
<ASSOCIATED <PROCEDURES: SPACES, NEWLINE, NEWLINES, NEWPAGE
.LC.P
<ERROR <CONDITIONS: ^SEE <PRINT <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SPACES\\
.INDEX ^^SPACES\\
.P-8
<DEFINITION: ^THIS ROUTINE CASES A SPECIFIED NUMBER OF 'SPACE' CHARACTERS
TO BE SENT TO THE CURRENTLY SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^SPACES\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION GIVING THE NUMBER OF 'SPACE' CHARACTERS
TO BE OUTPUT
.LM 8;.S 1
N 'SPACE' CHARACTERS ARE SENT TO THE OUTPUT STREAM.
.UC.F.P
<ASSOCIATED <PROCEDURES: SPACE, NEWLINE, NEWLINES, NEWPAGE
.LC.P
<ERROR <CONDITIONS: ^SEE <PRINT <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^STARTOFPERIOD\\
.INDEX ^^STARTOFPERIOD\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION RETURNS THE DATE AND TIME IN UNIVERSAL
DATE-TIME FORMAT OF THE START OF THE GIVEN ACCOUNTING PERIOD.

.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^STARTOFPERIOD\\(%<INTEGER PERIOD)
.P
<USE:	UDT=^^STARTOFPERIOD\\(PERIOD)
.LM 16;.F;.S 1

.I-8
PERIOD	IS AN INTEGER EXPRESSION BEING A FOUR DIGIT ACCOUNTING PERIOD WHOSE
START DATE-TIME IS REQUIRED
.LM 8;.S 1
THE INITIAL DATE AND TIME OF THE GIVEN ACCOUNTING PERIOD, IS RETURNED
AS A UNIVERSAL DATE-TIME INTEGER VIA %<RESULT.
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, TO DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TO TIME, TIMETOSTR,
DATETIME, GET NOW, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, ENDOFPERIOD
.F.LC.P
<ERROR <CONDITIONS: WHEN THE PARAMETERS IS NOT OF THE FORM <YYMM
OR IS AN IMPOSSIBLE VALUE, THE FOLLOWING EVENT IS CAUSED:-
.NF.S
%<SIGNAL 11, 22, PERIOD, "^ACCOUNTING PERIOD INCORRECTLY SPECIFIED"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^STRING\\
.INDEX ^^STRING\\
.P-8
<DEFINITION: ^THIS MAP ENABLES THE USER TO ACCESS DIRECTLY AS A STRING
A PARTICULAR LOCATION WHOSE ADDRESS IS SPECIFIED.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^STRING\\(ADR)
.LM 16;.F;.S 1

.I-8
ADR	IS AN INTEGER EXPRESSION GIVING THE ADDRESS OF THE
REQUIRED LOCATION.
.LM 8;.S 1
^THIS MAP ALLOWS THE USER TO READ OR WRITE DIRECTLY TO A LOCATION
IN STORE AS A STRING BY SPECIFYING THE ABSOLUTE ADDRESS IN 'ADR'.
.UC.F.P
<ASSOCIATED <PROCEDURES: BYTE INTEGER, SHORT INTEGER, INTEGER,
REAL, RECORD
.LC.P
<ERROR <CONDITIONS: ^IF THE VALUE OF 'ADR' LIES OUTSIDE THE CURRENT ADDRESSING SPACE THE
FOLLOWING FATAL ERROR WILL OCCUR:-
.NF.S
?<IMP: ^ILL ^MEM ^REF AT USER PC  'ADDR'

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^STRTOASC\\
.INDEX ^^STRTOASC\\
.P-8
<DEFINITION: ^THIS ROUTINE CONVERTS AN <IMP STRING INTO AN <ASCIZ
STRING.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^STRTOASC\\(%<STRING<NAME S, %<<NAME ADR)
.P
<CALL:	^^STRTOASC\\(S,ADR)
.LM 16;.F;.S 1

.I-8
S	IS THE NAME OF A N <IMP TYPE STRING WHICH IS TO BE CONVERTED
TO <ASCIZ FORM.
.I-8
ADR	IS THE NAME OF A  VARIABLE AT WHICH THE CONVERTED STRING IS TO START
.LM 8;.S 1
THE GIVEN <IMP STRING IS CONVERTED TO <ASCIZ FORM
(7-BIT BYTES, TERMINATED BY A ZERO BYTE) AND RETURNED IN MEMORY STARTING
AT ADDRESS 'ADR'.
.F.P.UC
<ASSOCIATED <PROCEDURES: ASCTOSTR
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^STRTOFS\\
.INDEX ^^STRTOFS\\

.P-8
<DEFINITION: ^THIS RECORD FUNCTION PARSES THE GIVEN STRING INTO A FILE
SPECIFICATION RECORD.
.NF;.P
<SPEC:	%<EXTERNAL%RECORD(FILESPEC)%FN ^^STRTOFS\\(%<STRING(255) SPEC)
.P
<USE:	FS = ^^STRTOFS\\(SPEC)
.LM 16;.F;.S 1

.I-8
SPEC	IS A STRING CONTAINING A ^^DEC\\SYSTEM-10 STYLE FILE
SPECIFICATION, WHICH MAY INCLUDE SWITCHES WITH VALUES (SEE APPENDIX
^B FOR A LIST OF SWITCHES RECOGNISED BY THE SYSTEM)
.I-8
.LM 8;.S 1
^THE STRING 'SPEC' CONTAINS A ^^DEC\\SYSTEM-10 STYLE FILE
SPECIFICATION, WHICH IS PARSED INTO ITS CONSTITUENT ITEMS AND
WHICH ARE RETURNED IN THE FORM OF A FILE SPECIFICATION RECORD (SEE
SECTION 3) VIA %<RESULT.
.B
.UC.F.P
<ASSOCIATED <PROCEDURES: FSTOSTR, READFS, WRITE FS, DEFAULT
.LC.P
<ERROR <CONDITIONS: ^IF A SYNTAX ERROR IS FOUND IN THE STRING, THE FOLLOWING EVENT OCCURS:-
.NF.S
%<SIGNAL 10, 9, 0, "^BAD FILE SPEC:-  'FILESPEC'"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^STRTOHEX\\
.INDEX ^^STRTOHEX\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION CONVERTS AN STRING OF DIGITS INTO AN
HEXIDECIMAL INTEGER.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^STRTOHEX\\(%<STRINGNAME S)
.P
<USE:	N=^^STRTOHEX\\(S)
.LM 16;.F;.S 1

.I-8
S	IS THE NAME OF A STRING CONTAINING THE NUMBER TO BE CONVERTED
.LM 8;.S 1
^THE GIVEN STRING IS READ SEQUENTIALLY AND THE FIRST SET OF HEXIDECIMAL
DIGITS FOUND ARE CONVERTED INTO A HEXIDECIMAL INTEGER WHICH IS RETURNED
VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: HEXTOSTR, READ HEX
.LC.P
<ERROR <CONDITIONS: ^SEE <READ <HEX


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^STRTOINT\\
.INDEX ^^STRTOINT\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION CONVERTS AN STRING OF DIGITS INTO AN
DECIMAL INTEGER.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^STRTOINT\\(%<STRINGNAME S)
.P
<USE:	N=^^STRTOINT\\(S)
.LM 16;.F;.S 1

.I-8
S	IS THE NAME OF A STRING CONTAINING THE NUMBER TO BE CONVERTED
.LM 8;.S 1
^THE GIVEN STRING IS READ SEQUENTIALLY AND THE FIRST SET OF DIGITS FOUND
ARE CONVERTED INTO A DECIMAL INTEGER WHICH IS RETURNED VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: INTTOSTR, READ
.LC.P
<ERROR <CONDITIONS: ^SAME AS <READ ROUTINE FOR INTEGERS.


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^STRTOOCT\\
.INDEX ^^STRTOOCT\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION CONVERTS AN STRING OF OCTAL DIGITS
INTO AN OCTAL INTEGER.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^STRTOOCT\\(%<STRINGNAME S)
.P
<USE:	N=^^STRTOOCT\\(S)
.LM 16;.F;.S 1

.I-8
S	IS THE NAME OF A STRING CONTAINING THE NUMBER TO BE CONVERTED
.LM 8;.S 1
^THE GIVEN STRING IS READ SEQUENTIALLY AND THE FIRST SET OF OCTAL DIGITS FOUND
ARE CONVERTED INTO A OCTAL INTEGER WHICH IS RETURNED VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: OCTTOSTR, READ OCTAL
.LC.P
<ERROR <CONDITIONS: ^SEE <READ <OCTAL


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^STRTOSIX\\
.INDEX ^^STRTOSIX\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF A ^^DEC\\SYSTEM-10
<SIXBIT WORD REPRESENTING THE CHARACTERS IN A GIVEN <IMP STRING.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^STRTOSIX\\(%<STRING(6) S)
.P
<USE:	N=^^STRTOSIX\\(S)
.LM 16;.F;.S 1

.I-8
S	IS A STRING OF UP TO SIX CHARACTERS TO BE CONVERTED TO <SIXBIT
REPRESENTATION (^THEY MUST
LIE WITHIN THE <SIXBIT CHARACTER SET)
.LM 8;.S 1
^THE GIVEN STRING IS CONVERTED INTO ITS EQUIVALENT <SIXBIT
REPRESENTATION AND RETURNED IN AN INTEGER WORD VIA %<RESULT.
^SEE ^^DEC\\SYSTEM-10 ^HARDWARE ^REFERENCE ^MANUAL FOR THE FULL <SIXBIT
CHARACTER SET.
.UC.F.P
<ASSOCIATED <PROCEDURES: SIXTOSTR
.LC.P
<ERROR <CONDITIONS: ^ALL CHARACTERS ARE ASSUMED TO LIE WITHIN THE <SIXBIT CHARACTER
SET AND UNPREDICTABLE CHARCTERS WILL BE FORMED IF THIS IS NOT THE CASE.


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SUB EVENT\\
.INDEX ^^SUB EVENT\\

.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE SUB-CLASS OF
THE LAST EVENT TO HAVE BEEN TRAPPED BY AN %<ON %<EVENT BLOCK.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^SUB EVENT\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
THE SUB-CLASS OF THE LAST EVENT IS RETURNED VIA %<RESULT
.F.P.UC
<ASSOCIATED <PROCEDURES: EVENT, EVENT INFO
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SUB STRING\\
.INDEX ^^SUB STRING\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION EXTRACTS A SET OF CHARACTERS FORMING
A SUB-STRING FROM A STRING.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	T=^^SUB STRING\\(S,N,M)
.LM 16;.F;.S 1

.I-8
S	IS THE NAME OF A STRING FROM WHICH THE SUB-STRING IS REQUIRED
.I-8
N	IS AN INTEGER EXPRESSION GIVING THE LOWER BOUND OF THE REQUIRED SUB-STRING
.I-8
M	IS AN INTEGER EXPRESSION GIVING THE UPPER BOUND OF THE REQUIRED
SUB-STRING
.LM 8;.S 1
^A STRING OF CHARACTERS FROM POSITIONS 'N' TO 'M' INCLUSIVE OF STRING 'S'
IS RETURNED VIA %<RESULT.
^IF M=N-1 THEN A NULL STRING IS RETURNED.
.UC.F.P
<ASSOCIATED <PROCEDURES: TO STRING, LENGTH, CHARNO, MATCH
.F.LC.P
<ERROR <CONDITIONS: M _< N-1 CAUSES THE EVENT:-
.NF.S
<%SIGNAL 5, 8, 0, "^STRING PARAMETERS INSIDE OUT"
.F.S
^UNLESS 0 _< N _<= ^^LENGTH\\(S) OR 0 _<= M _<= ^^LENGTH\\(S) THEN THE
FOLLOWING EVENT IS CAUSED:-
.NF.S
<%SIGNAL 5, 7, INDEX, "^ILLEGAL STRING INDEX"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^SWITCH ARG\\
.INDEX ^^SWITCH ARG\\
.P-8
<DEFINITION: ^THIS PREDICATE SEARCHES FOR THE OCCURENCE OF A SWITCH
IN A GIVEN STRING AND RETURNS A SWITCH ARGUMENT, IF ONE IS GIVEN.
.NF;.P
<SPEC:	%<EXTERNALPREDICATE ^^SWITCH ARG\\(%<STRING(255)%<NAME S, %<STRING(15) T, %<<NAME X)
.P
<USE:	<%IF ^^SWITCH ARG\\(S,T,X) <%THEN . . .
.LM 16;.F;.S 1

.I-8
S	IS THE NAME OF A STRING TO BE SCANNED
.I-8
T	IS A STRING CONTAINING THE SWITCH NAME TO BE SCANNED FOR
.I-8
X	IS THE NAME OF AN INTEGER OR STRING INTO WHICH AN ARGUMENT IS READ
.LM 8;.S 1
^THE GIVEN STRING IS SCANNED FOR A GIVEN SWITCH NAME AND RETURNS
A VALUE %<TRUE IF ONE IS FOUND, AND %<FALSE OTHERWISE.  ^IN ADDITION,
IF A MATCH IS FOUND, ANY ARGUMENT IS READ INTO THE STRING OR INTEGER
NAME SPECIFIED. ^IT IS UP TO THE USER TO SUPPLY THE CORRECT TYPE OF
THIRD PARAMETER FOR ANY GIVEN SWITCH.
.UC.F.P
<ASSOCIATED <PROCEDURES: MATCH
.LC.P
<ERROR <CONDITIONS: ^IF THE THIRD PARAMETER SUPPLIED IS NOT EITHER AN
INTEGER OR STRING, THE FOLLOWING EVENT IS CAUSED:-
.NF.S
%<SIGNAL 5, 6, TYPE, "^ILLEGAL %<NAME TYPE PARAMETER"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^TAB\\
.INDEX ^^TAB\\
.P-8
<DEFINITION: ^THIS INTEGER CONSTANT GIVES THE INTERNAL <ASCII CODE VALUE
FOR THE TAB CHARACTER.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	N=^^TAB\\
.F.LM 8;.S 1
^THE NUMERICAL VALUE OF THE TAB CHARACTER IS GIVEN.
.UC.F.P
<ASSOCIATED <CONSTANTS: ESC, SP, NL, FF
.LC

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^TAPOP\\
.INDEX ^^TAPOP\\
.P-8
<DEFINITION: ^THIS PREDICATE PERFORMS THE ^^DEC\\SYSTEM-10 <TAPOP ^MONITOR
FUNCTION.
.NF;.P
<SPEC:	%<SYSTEMPREDICATE ^^TAPOP\\(%<INTEGER FUNCT,CHAN,NARGS, %<INTEGERARRAYNAME ARGS(0:12), %<INTEGERNAME RESULT)
.P
<USE:	<%IF ^^TAPOP\\(FUNCT,CHAN,NARGS,ARGS,RESULT) <%THEN . . .
.LM 16;.F;.S 1

.I-8
FUNCT	IS AN INTEGER EXPRESSION BEING THE <TAPOP FUNCTION CODE TO BE PERFORMED
.I-8
CHAN	IS AN INTEGER EXPRESSION BEING THE PHYSICAL
CHANNEL NUMBER ASSOCIATED WITH THE DEVICE, (OBTAINED FROM THE LEFT-HALF
OF THE <FILOPFN WORD IN THE ^STREAM ^CONTROL ^BLOCK FOR THAT STREAM)
.I-8
NARGS	IS AN INTEGER EXPRESSION GIVING THE NUMBER OF ARGUMENTS BEING
PASSED TO THE <TAPOP <UUO IN THE ARRAY 'ARGS'
.I-8
ARGS	IS THE NAME OF AN INTEGER ARRAY WHICH CONTAINS THE RELEVANT ARGUMENTS
FOR THE FUNCTION REQUIRED.
.I-8
RESULT	IS THE NAME OF AN INTEGER WHICH WILL CONTAIN ANY RESULT PASSED BACK BY
THE <TAPOP <UUO.
.I-8
.F;.LM 8;.S 1
^THE <TAPOP ^MONITOR FUNCTION IS PERFORMED ACCORDING TO
THE VALUES SUPPLIED. ^A VALUE OF %<TRUE IS RETURNED
IF THE FUNCTION IS SUCCESSFUL AND %<FALSE OTHERWISE. ^ANY RESULT IS PASSED
BACK IN THE RESULT ITEM OF THE RECORD. ^FOR THE FULL DESCRIPTION
OF THE <TAPOP <UUO SEE THE ^^DEC\\SYSTEM-10 <MONITOR <CALLS ^MANUAL.
.UC.F.P
<ASSOCIATED <PROCEDURES: FILOP
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^TIME\\
.INDEX ^^TIME\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION RETURNS THE CURRENT TIME
AS AN EIGHT CHARACTER STRING.
.NF;.P
<SPEC:	%<EXTERNALSTRING(8)%FN ^^TIME\\
.P
<USE:	S=^^TIME\\
.F;.S 1
^NO PARAMETERS
.LM 8;.S 1
THE CURRENT TIME IS RETURNED AS AN EIGHT CHARACTER STRING OF THE
FORM <HH:MM:SS VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, TO DATE, DATETOSTR,
GET TIME, FROM TIME, TO TIME, TIMETOSTR,
DATETIME, GET NOW, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^TIMETOSTR\\
.INDEX ^^TIMETOSTR\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION RETURNS THE TIME GIVEN IN MILLISECONDS
(<DEC INTERNAL FORM), AS AN EIGHT CHARACTER STRING.
.NF;.P
<SPEC:	%<EXTERNALSTRING(8)%FN ^^TIMETOSTR\\(%<INTEGER TIME)
.P
<USE:	S=^^TIMETOSTR\\(TIME)
.LM 16;.F;.S 1

.I-8
TIME	IS AN INTEGER EXPRESSION BEING THE TIME IN MILLISECONDS
PAST MIDNIGHT (<DEC INTERNAL FORM)
.LM 8;.S 1
THE GIVEN TIME IS CONVERTED TO AN EIGHT CHARACTER STRING
OF THE FORM <HH:MM:SS IS RETURNED VIA %<RESULT.
.S
^NO PARAMETER CHECKING IS DONE SO THAT THE RESULT IS CALCULATED FOR ANY
NUMBER OF MILLISECONDS.
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, TO DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TO TIME,
DATETIME, GET NOW, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^TMPCOR\\
.INDEX ^^TMPCOR\\
.P-8
<DEFINITION: ^THIS ROUTINE EXECUTES A ^^DEC\\SYSTEM-10 ^MONITOR <TMPCOR <UUO.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^TMPCOR\\(%<INTEGER TYP,IOWD,NAM)
.P
<CALL:	^^TMPCOR\\(TYP,IOWD,NAM)
.LM 16;.F;.S 1

.I-8
TYP	IS AN INTEGER EXPRESSION GIVING THE TYPE OF <TMPCOR
FUNCTION REQUIRED
.I-8
IOWD	IS AN INTEGER EXPRESSION GIVING AN <IOWD (SEE <IOWD
INTEGER FUNCTION) RELATING TO AN AREA OF STORE
.I-8
NAM	IS AN INTEGER EXPRESSION BEING A FILE NAME IN <SIXBIT
FORMAT
.LM 8;.S 1
^A <TMPCOR <UUO FUNCTION IS EXECUTED. ^FOR A LIST OF
THE TYPES OF FUNCTION AVAILABLE AND THE FORM OF THE DATA BLOCK SEE THE
^^DEC\\SYSTEM-10 <MONITOR <CALLS ^MANUAL.
.UC.F.P
<ASSOCIATED <PROCEDURES: (X) DEFINE (INPUT/OUTPUT), FINIT, IOWD, STRTOSIX
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^TODATE\\
.INDEX ^^TODATE\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE DATE IN <DEC
INTERNAL FORM GIVEN THE DAY, MONTH AND YEAR
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^TODATE\\(%<INTEGER DAY, MON, YEAR)
.P
<USE:	D=^^TODATE\\(DAY,MON,YEAR)
.LM 16;.F;.S 1

.I-8
DAY	IS AN INTEGER EXPRESSION BEING THE DAY OF THE MONTH
.I-8
MON	IS AN INTEGER EXPRESSION BEING THE MONTH OF THE YEAR
.I-8
YEAR	IS AN INTEGER EXPRESSION BEING THE YEAR, WHERE THE CENTURIES
MAY OR MAY NOT BE GIVEN
.LM 8;.S 1
THE DATE IN <DEC INTERNAL FORMAT IS COMPUTED FROM
THE INTEGER PARAMETERS AND IS RETURNED VIA %<RESULT.
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TO TIME, TIMETOSTR,
DATETIME, GET NOW, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^TO STRING\\
.INDEX ^^TO STRING\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION CREATES A ONE CHARACTER STRING
FROM A GIVEN SYMBOL.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<USE:	S=^^TO STRING\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION WHOSE LEAST SIGNIFICANT 7 BITS ARE
TO BE PLACED IN A STRING
.LM 8;.S 1
^A STRING IS CONSTRUCTED FROM THE SYMBOL GIVEN AND RETURNED
VIA %<RESULT.
.UC.F.P
<ASSOCIATED <PROCEDURES: SUB STRING, LENGTH, CHARNO
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^TOTIME\\
.INDEX ^^TOTIME\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION GIVES THE VALUE OF THE TIME OF DAY
AS MILLISECONDS PAST MIDNIGHT (<DEC INTERNAL FORM), FROM THE GIVEN PARAMETERS.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^TOTIME\\(%<INTEGER HRS, MINS, SECS)
.P
<USE:	T=^^TOTIME\\(HRS,MINS,SECS)
.LM 16;.F;.S 1

.I-8
HRS	IS AN INTEGER EXPRESSION BEING THE HOUR OF THE DAY
.I-8
MINS	IS AN INTEGER EXPRESSION BEING THE MINUTE OF THE HOUR
.I-8
SECS	IS AN INTEGER EXPRESSION BEING THE SECOND OF THE MINUTE
.LM 8;.S 1
THE TIME IN <DEC INTERNAL FORM IS COMPUTED
FROM THE GIVEN PARAMETERS AND RETURNED VIA %<RESULT.
.S
^NO PARAMETER CHECKING IS DONE SO THAT THE RESULT IS CALCULATED FOR ANY
NUMBER OF HOURS, MINUTES AND SECONDS.
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, TO DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TIMETOSTR,
DATETIME, GET NOW, FROM UDT, TO UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^TO UDT\\
.INDEX ^^TO UDT\\
.P-8
<DEFINITION: ^THIS INTEGER FUNCTION RETURNS THE DATE AND TIME
IN THE UNIVERSAL DATE-TIME FORM GIVEN THE DATE
AND TIME IN <DEC INTERNAL FORM.
.NF;.P
<SPEC:	%<EXTERNALINTEGERFN ^^TO UDT\\(%<INTEGER DATE, TIME)
.P
<USE:	UDT=^^TO UDT\\(DATE,TIME)
.LM 16;.F;.S 1

.I-8
DATE	IS AN INTEGER EXPRESSION BEING THE DATE IN <DEC INTERNAL FORM
.I-8
TIME	IS AN INTEGER EXPRESSION BEING THE TIME IN <DEC INTERNAL FORM
.LM 8;.S 1
THE DATE AND TIME IN UNIVERSAL DATE-TIME FORM IS COMPUTED
FROM THE DATE AND TIME IN <DEC INTERNAL FORM
AND RETURNED VIA %<RESULT.
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, TO DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TO TIME, TIMETOSTR,
DATETIME, GET NOW, FROM UDT, UDTTOSTR,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^UDTTOSTR\\
.INDEX ^^UDTTOSTR\\
.P-8
<DEFINITION: ^THIS STRING FUNCTION RETURNS THE DATE AND
TIME GIVEN IN UNIVERSAL DATE-TIME FORM, AS AN EIGHTEEN CHARACTER STRING.
.NF;.P
<SPEC:	%<EXTERNALSTRING(18)%FN ^^UDTTOSTR\\(%<INTEGER UDT)
.P
<USE:	S=^^UDTTOSTR\\(UDT)
.LM 16;.F;.S 1

.I-8
UDT	IS AN INTEGER EXPRESSION BEING THE DATE AND TIME IN UNVERSAL DATE-TIME
FORM
.LM 8;.S 1
THE DATE-TIME PARAMETER IS TRANSLATED INTO A STRING OF THE
FORM <HH:MM:SS <DD-MON-YY AND RETURNED VIA %<RESULT.
.S
^SEE ^SECTION 2 FOR A DESCRIPTION OF THE VARIOUS DATE AND TIME FORMATS.
.UC.F.P
<ASSOCIATED <PROCEDURES: DATE, GET DATE, FROM DATE, TO DATE, DATETOSTR,
TIME, GET TIME, FROM TIME, TO TIME, TIMETOSTR,
DATETIME, GET NOW, FROM UDT, TO UDT,
DAY, DAYTOSTR,
ACCPER, STARTOFPERIOD, ENDOFPERIOD
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^USET INPUT\\
.INDEX ^^USET INPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE GIVES THE ABILITY TO READ THE NEXT BUFFER
FOR INPUT FROM A GIVEN BLOCK IN THE CURRENT INPUT FILE.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^USET INPUT\\(%<INTEGER N)
.P
<CALL:	^^USET INPUT\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION SPECIFYING THE BLOCK NUMBER
TO BE READ NEXT
.LM 8;.S 1
^THIS ROUTINE PERFORMS THE <USETI ^MONITOR CALL ON THE CURRENT
INPUT STREAM.
^THIS ^MONITOR CALL ALLOWS THE USER TO SET THE
BLOCK NUMBER OF THE NEXT BLOCK TO BE READ FROM. ^SEE THE ^^DEC\\SYSTEM-10
<MONITOR <CALLS ^MANUAL FOR FULL DETAILS OF THE FORM OF ARGUMENT AND
ITS CONDITIONS.
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)DEFINE INPUT, SELECT INPUT, CLOSE INPUT, RESET INPUT
.LC.P
<ERROR <CONDITIONS: ^NONE

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^USET OUTPUT\\
.INDEX ^^USET OUTPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE GIVES THE ABILITY TO WRITE THE NEXT BUFFER
FOR OUTPUT TO A GIVEN BLOCK IN THE CURRENT OUTPUT FILE.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^USET OUTPUT\\(%<INTEGER N)
.P
<CALL:	^^USET OUTPUT\\(N)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION SPECIFYING THE BLOCK NUMBER
TO BE WRITTEN NEXT
.LM 8;.S 1
^THIS ROUTINE PERFORMS THE <USETO ^MONITOR CALL ON THE CURRENT
OUTPUT STREAM.
^THIS ^MONITOR CALL ALLOWS THE USER TO SET THE
BLOCK NUMBER OF THE NEXT BLOCK TO BE WRITTEN TO. ^SEE THE ^^DEC\\SYSTEM-10
<MONITOR <CALLS ^MANUAL FOR FULL DETAILS OF THE FORM OF ARGUMENT AND
ITS CONDITIONS.
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)DEFINE OUTPUT, SELECT OUTPUT, CLOSE OUTPUT,
RESET OUTPUT
.LC.P
<ERROR <CONDITIONS: ^NONE


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^WRITE\\
.INDEX ^^WRITE\\
.P-8
<DEFINITION: ^THIS ROUTINE PRINTS A SIGNED DECIMAL INTEGER ON THE CURRENTLY
SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	^NOT REQUIRED
.P
<CALL:	^^WRITE\\(N,M)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION WHOSE VALUE IS TO BE PRINTED OUT
.I-8
M	IS AN INTEGER EXPRESSION SPECIFYING THE NUMBER OF PRINTING
POSITIONS THAT THE NUMBER IS TO OCCUPY
.LM 8;.S 1
^A DECIMAL INTEGER IS OUTPUT ON THE CURRENT OUTPUT STREAM
WITH 'M' PRINTING POSITIONS INCLUDING THE SIGN.
^NON-SIGNIFICANT LEADING ZEROS ARE REPLACED WITH SPACES AND A POSITIVE
SIGN IS INDICATED BY A SPACE. ^IF THE NUMBER IS HAS MORE THAN
'M' SIGNIFICANT DIGITS, THESE WILL ALL BE OUTPUT AND THE SUBSEQUENT ALLIGNMENT
OF THE OUTPUT WILL BE RIGHT SHIFTED.
.S
^IF 'M' HAS THE VALUE ZERO THEN ALL LEADING SPACES AND POSITIVE SIGN ARE SUPPRESSED.
.UC.F.P
<ASSOCIATED <PROCEDURES: READ
.LC.P
<ERROR <CONDITIONS: ^SEE <PRINT <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^WRITE DA\\
.INDEX ^^WRITE DA\\
.P-8
<DEFINITION: ^THIS ROUTINE WRITES OUT THE DATA FROM A GIVEN AREA INTO
A SPECIFIED FILE, STARTING AT A SPECIFIED BLOCK.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^WRITE DA\\(%<INTEGER N, %<INTEGER<NAME BLOCK, %<<NAME BEGIN,END)
.P
<CALL:	^^WRITE DA\\(N,BLOCK,BEGIN,END)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING THE CHANNEL NUMBER
.I-8
BLOCK	IS THE NAME OF AN INTEGER VARIABLE WHICH ON ENTRY GIVES THE
STARTING BLOCK NUMBER AND, ON EXIT CONTAINS THE NUMBER OF THE
LAST BLOCK WRITTEN TO. ^A VALUE OF -1 CAUSES THE FILE TO BE APPENDED TO.
.I-8
BEGIN	IS THE NAME OF THE FIRST DATA ITEM OF AN AREA TO BE OUTPUT
.I-8
END	IS THE NAME OF THE LAST DATA ITEM OF AN AREA TO BE OUTPUT
.LM 8;.S 1
^THE DATA CONTAINED WITHIN THE AREA BEGIN TO END INCLUSIVELY
IS WRITTEN OUT TO THE DIRECT ACCESS FILE ON CHANNEL 'N' STARTING
AT BLOCK 'BLOCK'.
^THE DATA ITEMS MAY BE OF ANY TYPE INCLUDING RECORDS AND ARE WRITTEN
OUT STARTING AT THE BEGINNING OF THE SPECIFIED BLOCK AND ANY INCOMPLETE
BLOCKS ARE FILLED WITH WORDS CONTAINING ZERO.
.UC.F.P
<ASSOCIATED <PROCEDURES: (X) OPEN DA, READ DA, CLOSE DA
.LC.P
<ERROR <CONDITIONS: ^THE FOLLOWING EVENTS MAY OCCUR:-
.NF.S
%<SIGNAL 20, 23, CHAN, "^READ/WRITE TO ILLEGAL <DA/SQ CHANNEL"
%<SIGNAL 20, 23, CHAN, "^READ/WRITE TO <DA/SQ CHANNEL BEFORE ^^OPEN\\ING IT"
%<SIGNAL 20, 24, CHAN, "^ACCESSING <DA CHANNEL BY <SQ ROUTINE OR VICE VERSA"
%<SIGNAL 20, 25, 0, "^STORAGE AREA FOR <DA/SQ ROUTINE INSIDE OUT"
%<SIGNAL 20, 26, BLOCK, "^ILLEGAL BLOCK NUMBER FOR <DA READ/WRITE ROUTINE"
%<SIGNAL 9, 0, CHAN, "<EOF ON <DA OR <SQ CHANNEL"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^WRITE FS\\
.INDEX ^^WRITE FS\\
.P-8
<DEFINITION: ^THIS ROUTINE PRINTS OUT THE GIVEN FILE SPECIFICATION RECORD
IN THE STANDARD ^^DEC\\SYSTEM-10 FORMAT TO THE CURRENTLY SELECTED OUTPUT
STREAM.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^WRITE FS\\(%<RECORD(FILESPEC)%<NAME FS)
.P
<CALL:	^^WRITE FS\\(FS)
.LM 16;.F;.S 1

.I-8
FS	IS THE NAME OF A FILE SPECIFICATION RECORD TO BE OUTPUT
.LM 8;.S 1
^THE GIVEN FILE SPECIFICATION IS SENT IN THE ^^DEC\\SYSTEM-10 FILE
SPECIFICATION  FORMAT TO THE CURRENT OUTPUT STREAM.
.UC.F.P
<ASSOCIATED <PROCEDURES: READFS, FSTOSTR, STRTOFS
.LC.P
<ERROR <CONDITIONS: ^SEE <PRINT <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^WRITE HEX\\
.INDEX ^^WRITE HEX\\
.P-8
<DEFINITION: ^THIS ROUTINE PRINTS THE SPECIFIED INTEGER AS A SIGNED HEXIDECIMAL
NUMBER ON THE CURRENTLY SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^WRITE HEX\\(%<INTEGER N,M)
.P
<CALL:	^^WRITE HEX\\(N,M)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING THE HEXIDECIMAL NUMBER TO BE PRINTED
.I-8
M	IS AN INTEGER EXPRESSION GIVING THE NUMBER OF PRINTING
POSITIONS THAT THE NUMBER IS TO OCCUPY
.LM 8;.S 1
^AN HEXIDECIMAL INTEGER IS OUTPUT ON THE CURRENT OUTPUT STREAM
WITH 'M' PRINTING POSITIONS INCLUDING THE SIGN.
^NON-SIGNIFICANT LEADING ZEROS ARE REPLACED WITH SPACES AND A POSITIVE
SIGN IS INDICATED BY A SPACE. ^IF THE NUMBER IS HAS MORE THAN
'M' SIGNIFICANT DIGITS, THESE WILL ALL BE OUTPUT AND THE SUBSEQUENT ALLIGNMENT
OF THE OUTPUT WILL BE RIGHT SHIFTED.
.S
^IF 'M' HAS THE VALUE ZERO ALL LEADING SPACES AND POSITIVE SIGN ARE SUPPRESSED.
.UC.F.P
<ASSOCIATED <PROCEDURES: READ HEX, HEXTOSTR
.LC.P
<ERROR <CONDITIONS: ^SEE <PRINT <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^WRITE OCTAL\\
.INDEX ^^WRITE OCTAL\\
.P-8
<DEFINITION: ^THIS ROUTINE PRINTS THE SPECIFIED INTEGER AS A SIGNED OCTAL
NUMBER ON THE CURRENTLY SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^WRITE OCTAL\\(%<INTEGER N,M)
.P
<CALL:	^^WRITE OCTAL\\(N,M)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING THE OCTAL NUMBER TO BE PRINTED
.I-8
M	IS AN INTEGER EXPRESSION GIVING THE NUMBER OF PRINTING
POSITIONS THAT THE NUMBER IS TO OCCUPY
.LM 8;.S 1
^AN OCTAL INTEGER IS OUTPUT ON THE CURRENT OUTPUT STREAM
WITH 'M' PRINTING POSITIONS INCLUDING A SIGN.
^NON-SIGNIFICANT LEADING ZEROS ARE REPLACED WITH SPACES AND A POSITIVE
SIGN IS INDICATED BY A SPACE. ^IF THE NUMBER IS HAS MORE THAN
'M' SIGNIFICANT DIGITS, THESE WILL ALL BE OUTPUT AND THE SUBSEQUENT ALLIGNMENT
OF THE OUTPUT WILL BE RIGHT SHIFTED.
.S
^IF 'M' HAS THE VALUE ZERO ALL LEADING SPACES AND POSITIVE SIGN ARE SUPPRESSED.
.UC.F.P
<ASSOCIATED <PROCEDURES: READ OCTAL, OCTTOSTR
.LC.P
<ERROR <CONDITIONS: ^SEE <PRINT <SYMBOL.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^WRITE PPN\\
.INDEX ^^WRITE PPN\\
.P-8
<DEFINITION: ^THIS ROUTINE PRINTS A NUMBER AS A PROJECT-PROGRAMMER PAIR
ENCLOSED WITHIN SQUARE BRACKETS ON THE CURRENTLY SELECTED OUTPUT STREAM.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^WRITE PPN\\(%<INTEGER PPN)
.P
<CALL:	^^WRITE PPN\\(PPN)
.LM 16;.F;.S 1

.I-8
PPN	IS AN INTEGER EXPRESSION BEING A WORD CONTAINING THE OCTAL
REPRESENTATIONS OF THE PROJECT NUMBER IN OCTAL IN THE LEFT HALF AND THE
PROGRAMMER NUMBER IN OCTAL IN THE RIGHT HALF
.LM 8;.S 1
^THE INTEGER PPN IS SENT TO THE CURRENT OUTPUT STREAM IN THE FORM OF A
PROJECT-PROGRAMMER PAIR ENCLOSED IN SQUARE BRACKETS.
.UC.F.P
<ASSOCIATED <PROCEDURES: READ PPN, READ OCTAL, WRITE OCTAL
.LC.P
<ERROR <CONDITIONS: ^SEE <PRINT <SYMBOL.


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^WRITE SQ\\
.INDEX ^^WRITE SQ\\
.P-8
<DEFINITION: ^THIS ROUTINE WRITES OUT THE DATA FROM A GIVEN AREA INTO A
SPECIFIED FILE.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^WRITE SQ\\(%<INTEGER N, %<<NAME BEGIN,END)
.P
<CALL:	^^WRITE SQ\\(N,BEGIN,END)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING THE CHANNEL NUMBER AND LYING
IN THE RANGE 1 TO 15
.I-8
BEGIN	IS THE NAME OF THE FIRST DATA ITEM OF AN AREA TO BE OUTPUT
.I-8
END	IS THE NAME OF THE LAST DATA ITEM OF AN AREA TO BE OUTPUT
.LM 8;.S 1
^THE DATA CONTAINED WITHIN THE AREA BEGIN TO END INCLUSIVELY
IS WRITTEN OUT TO THE SEQUENTIAL FILE ON CHANNEL 'N'.
^THE DATA ITEMS MAY BE OF ANY TYPE INCLUDING RECORDS.
^THE FIRST CALL OF THIS ROUTINE AFTER A SEQUENTIAL CHANNEL HAS BEEN
OPENED DETERMINES THAT ALL SUBSEQUENT ACCESS ON THAT CHANNEL MUST BE
FOR WRITING UNLESS THE CHANNEL IS RE-OPENED.
.S 1
^DATA IS STORED ON THE EXTERNAL MEDIUM AS AN UNSTRUCTURED SEQUENCE
OF WORDS. ^IT IS THE USERS RESPONSIBILITY TO REMEMBER THE FORM OF THE
DATA STORED FOR SUBSEQUENT READING.
^THE FINAL RECORD OF A FILE MAY BE FOLLOWED BY A NUMBER OF WORDS
CONTAINING ZERO WHICH ARE USED TO FILL OUT THE LST BLOCK OF THE FILE.
.UC.F.P
<ASSOCIATED <PROCEDURES: (X)OPEN SQ, READ SQ, CLOSE SQ
.LC.P
<ERROR <CONDITIONS: ^THE FOLLOWING EVENTS MAY OCCUR:-
.NF.S
%<SIGNAL 20, 23, CHAN, "^READ/WRITE TO ILLEGAL <DA/SQ CHANNEL"
%<SIGNAL 20, 23, CHAN, "^READ/WRITE TO <DA/SQ CHANNEL BEFORE ^^OPEN\\ING IT"
%<SIGNAL 20, 24, CHAN, "^ACCESSING <DA CHANNEL BY <SQ ROUTINE OR VICE VERSA"
%<SIGNAL 20, 25, 0, "^STORAGE AREA FOR <DA/SQ ROUTINE INSIDE OUT"
%<SIGNAL 20, 26, BLOCK, "^ILLEGAL BLOCK NUMBER FOR <DA READ/WRITE ROUTINE"
%<SIGNAL 20, 27, CHAN, "^OUTPUTTING TO AN <SQ CHANNEL SET FOR INPUT"
%<SIGNAL 9, 0, CHAN, "<EOF ON <DA OR <SQ CHANNEL"


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^XCOPY\\
.INDEX ^^XCOPY\\
.P-8
<DEFINITION: ^THIS ROUTINE COPIES ONE FILE INTO ANOTHER.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^XCOPY\\(%<RECORD(FILESPEC)%<NAME FS, NEW FS)
.P
<CALL:	^^XCOPY\\(FS, NEW FS)
.LM 16;.F;.S 1

.I-8
FS	IS THE NAME OF A RECORD CONTAINING THE SPECIFICATION OF THE FILE
TO BE COPIED
.I-8
NEW FS	IS THE NAME OF A RECORD CONTAINING THE FILE SPECIFICATION FOR THE COPIED FILE.
.LM 8;.S 1
THE FILE SPECIFIED IN 'FS' IS COPIED TO ANOTHER FILE WHOSE
NAME IS SPECIFIED IN 'NEW FS'.
.F.P
<ASSOCIATED <PROCEDURES: ^SEE <COPY
.LC.P
<ERROR <CONDITIONS: SEE <XOPEN <DA AND ALSO, WHEN THE <I/O CHANNEL CAPACITY IS FULL:-
.NF.S
%<SIGNAL 2, 5, 0, "^NO FREE CHANNELS FOR ^^COPY\\ING 'FILESPEC'"

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^XDEFINE INPUT\\
.INDEX ^^XDEFINE INPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE OPENS THE DEVICE OR FILE GIVEN IN THE FILE
SPECIFICATION RECORD AND ASSOCIATES IT WITH THE LOGICAL INPUT STREAM NUMBER GIVEN.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^XDEFINE INPUT\\(%<INTEGER N, %<RECORD(FILESPEC)%<NAME FS)
.P
<CALL:	^^XDEFINE INPUT\\(N,FS)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION SPECIFYING THE LOGICAL INPUT
STREAM NUMBER IN THE RANGE 1 TO 15
.I-8
FS	IS THE NAME OF A FILE SPECIFICATION RECORD CONTAINING THE
FILE OR DEVICE TO BE OPENED
.LM 8;.S 1
^THE DEVICE OR FILE SPECIFIED IS OPENED AND ASSOCIATED WITH
THE GIVEN LOGICAL INPUT STREAM NUMBER.
.F.P
<ASSOCIATED <PROCEDURES: ^SEE <DEFINE <INPUT
.LC.P
<ERROR <CONDITIONS: ^SEE <DEFINE <INPUT

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^XDEFINE OUTPUT\\
.INDEX ^^XDEFINE OUTPUT\\
.P-8
<DEFINITION: ^THIS ROUTINE OPENS THE DEVICE OR FILE GIVEN IN THE FILE
SPECIFICATION RECORD AND ASSOCIATES IT WITH THE LOGICAL OUTPUT STREAM NUMBER GIVEN.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^XDEFINE OUTPUT\\(%<INTEGER N, %<RECORD(FILESPEC)%<NAME FS)
.P
<CALL:	^^XDEFINE OUTPUT\\(N,FS)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION SPECIFYING THE LOGICAL OUTPUT
STREAM NUMBER IN THE RANGE 1 TO 15
.I-8
FS	IS THE NAME OF A FILE SPECIFICATION RECORD CONTAINING THE
FILE OR DEVICE TO BE OPENED
.LM 8;.S 1
^THE DEVICE OR FILE SPECIFIED IS OPENED AND ASSOCIATED WITH
THE GIVEN LOGICAL OUTPUT STREAM NUMBER.
.F.P
<ASSOCIATED <PROCEDURES: ^SEE <DEFINE <OUTPUT
.LC.P
<ERROR <CONDITIONS: ^SEE <DEFINE <OUTPUT.

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^XDELETE\\
.INDEX ^^XDELETE\\
.P-8
<DEFINITION: ^THIS ROUTINE DELETES THE FILE GIVEN IN THE FILE SPECIFICATION
RECORD.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^XDELETE\\(%<RECORD(FILESPEC)%<NAME FS)
.P
<CALL:	^^XDELETE\\(FS)
.LM 16;.F;.S 1

.I-8
FS	IS THE NAME OF A FILE SPECIFICATION RECORD INDICATING A
FILE TO BE DELETED
.LM 8;.S 1
^THE FILE SPECIFIED IN THE RECORD 'FS' IS DELETED.
.F.P
<ASSOCIATED <PROCEDURES: ^SEE <DELETE
.LC.LC.P
<ERROR <CONDITIONS: ^SEE <DELETE


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^XIS FILE\\
.INDEX ^^XIS FILE\\
.P-8
<DEFINITION: ^THIS PREDICATE TESTS TO SEE WHETHER THE SPECIFIED FILE EXISTS
OR NOT.
.NF;.P
<SPEC:	%<EXTERNALPREDICATE ^^XIS FILE\\(%<RECORD(FILESPEC)%<NAME FS)
.P
<CALL:	<%IF ^^XIS FILE\\(FS) <%THEN . . .
.LM 16;.F;.S 1

.I-8
FS	IS THE NAME OF A FILE SPECIFICATION RECORD CONTAINING THE NAME
OF THE FILE TO BE TESTED
.LM 8;.S 1
^THE PREDICATE HAS THE VALUE %<TRUE IF THE FILE EXISTS AND
%<FALSE IF IT DOES NOT, OR CANNOT BE ACCESSED FOR SOME REASON.
.F.P
<ASSOCIATED <PROCEDURES: ^SEE <IS <FILE
.LC.LC.P
<ERROR <CONDITIONS: ^SEE <IS <FILE
.NF.S
   (WHEN THE FULL <I/O CAPACITY IS BEING USED)
%<SIGNAL 2, 5, 0, "^ALL <I/O CHANNELS IN USE"
   OR (USUALLY WHEN A BAD DEVICE IS GIVEN)
%<SIGNAL 10, 6, 0, "^CANNOT OPEN DEVICE 'DEVICE'"


.S 4;.TEST PAGE 20;.NAP;.F;.C
^^XOPEN DA\\
.INDEX ^^XOPEN DA\\
.P-8
<DEFINITION: ^THIS ROUTINE HAS THE SAME EFFECT AS ^^OPEN DA\\ EXCEPT THAT
IT TAKES A FILE SPECIFICATION RECORD NAME AS ITS SECOND PARAMETER AND NOT
A STRING.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^XOPEN DA\\(%<INTEGER N, %<RECORD(FILESPEC)%<NAME FS)
.P
<CALL:	^^XOPEN DA\\(N,FS)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING THE LOGICAL CHANNEL NUMBER TO BE
ASSOCIATED WITH THE SPECIFIED FILE. ^IT MUST LIE IN THE RANGE 1 TO 15.
.I-8
FS	IS THE NAME OF A FILE SPECIFICATION RECORD CONTAINING THE NAME
OF THE FILE TO BE OPENED
.LM 8;.S 1
^THE SPECIFIED FILE IS OPENED FOR BOTH READING OR WRITING AND
IS ASSOCIATED WITH THE GIVEN LOGICAL CHANNEL NUMBER.
.F.P
<ASSOCIATED <PROCEDURES: ^SEE <OPEN <DA
.LC.P
<ERROR <CONDITIONS: ^SEE ^^OPEN DA\\

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^XOPEN SQ\\
.INDEX ^^XOPEN SQ\\
.P-8
<DEFINITION: ^THIS ROUTINE HAS THE SAME EFFECT AS ^^OPEN SQ\\ EXCEPT THAT
IT TAKES A FILE SPECIFICATION RECORD NAME AS ITS SECOND PARAMETER AND NOT
A STRING.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^XOPEN SQ\\(%<INTEGER N, %<RECORD(FILESPEC)%<NAME FS)
.P
<CALL:	^^XOPEN SQ\\(N,FS)
.LM 16;.F;.S 1

.I-8
N	IS AN INTEGER EXPRESSION BEING THE LOGICAL CHANNEL NUMBER TO BE
ASSOCIATED WITH THE SPECIFIED FILE. ^IT MUST LIE IN THE RANGE 1 TO 15.
.I-8
FS	IS THE NAME OF A FILE SPECIFICATION RECORD CONTAINING THE NAME OF
THE FILE TO BE OPENED
.LM 8;.S 1
^THE SPECIFIED FILE IS OPENED FOR EITHER READING OR WRITING AND
IS ASSOCIATED WITH THE GIVEN LOGICAL CHANNEL NUMBER.
^BUT NOTE THAT BOTH OPTIONS OF READING AND WRITING MAY NOT BE EXERCISED
AND THAT THE FIRST CALL OF EITHER <READ <SQ OR <WRITE <SQ
DETERMINES THE SUBSEQUENT TYPE OF ACCESS.
.F.P
<ASSOCIATED <PROCEDURES: ^SEE <OPEN <SQ
.LC.P
<ERROR <CONDITIONS: ^SEE ^^OPEN SQ\\

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^XRENAME\\
.INDEX ^^XRENAME\\
.P-8
<DEFINITION: ^THIS ROUTINE ALLOWS A SPECIFIED DISK FILE TO BE RENAMED.
.NF;.P
<SPEC:	%<EXTERNALROUTINE ^^XRENAME\\(%<RECORD(FILESPEC)%<NAME FS1,FS2)
.P
<CALL:	^^XRENAME\\(FS1,FS2)
.LM 16;.F;.S 1

.I-8
FS1	IS THE NAME OF A FILE SPECIFICATION RECORD CONTAINING THE NAME OF
THE FILE TO BE RENAMED
.I-8
FS2	IS THE NAME OF A FILE SPECIFICATION RECORD CONTAINING THE NAME
WHICH THE FILE IS TO BE GIVEN
.LM 8;.S 1
^A SPECIFIED FILE IS GIVEN A NEW NAME.
.F.P
<ASSOCIATED <PROCEDURES: ^SEE <RENAME
.LC.P
<ERROR <CONDITIONS: ^SEE <RENAME

.S 4;.TEST PAGE 20;.NAP;.F;.C
^^ZERO\\
.INDEX ^^ZERO\\
.P-8
<DEFINITION: ^THIS ROUTINE SETS A BLOCK OF STORE TO ZERO.
.NF;.P
<SPEC:	%<SYSTEMROUTINE ^^ZERO\\(%<<NAME FROM, TO)
.P
<CALL:	^^ZERO\\(FROM,TO)
.LM 16;.F;.S 1

.I-8
FROM	IS THE NAME OF A VARIABLE FROM WHICH TO START ZEROING STORE
.I-8
TO	IS THE NAME OF A VARIABLE WHICH WILL BE THE LAST ITEM TO BE ZEROED.
.LM 8;.S 1
THE BLOCK OF STORE BETWEEN AND INCLUDING THE TWO PARAMETERS GIVEN IS SET TO ZERO.
^IF THE VARIABLE GIVEN IS A RECORD, STRING OR ARRAY, THE
WHOLE RECORD, STRING OR ARRAY WILL BE ZEROED.
.UC.F.P
<ASSOCIATED <PROCEDURES: BLT
.F.LC.P
<ERROR <CONDITIONS: ^THE USER SHOULD BE SURE THAT THEY UNDERSTAND HOW
VARIABLES ARE STORED, WHEN DOING COMPLEX ZEROING OPERATIONS, AS
INCAUTIOUS USE OF THIS ROUTINE, MAY ZERO AREAS OF STORE AND
VARIABLES WHICH MAY CAUSE ERRORS OF MANY TYPES.

.LM 0.PAGE;.NAP;.NF
2. ^^DATE-TIME FORMATS\\
.lm 4
.s2
.F
2.1 ^INTERNAL <DEC FORMAT.
.AP.P 0
 ^THE DATE IS REPRESENTED AS A FIFTEEN BIT INTEGER, WHICH IS CALCULATED
BY INCREMENTING IT BY 1 EACH DAY, 31 EACH MONTH (REGARDLESS OF THE ACTUAL
NUMBER OF DAYS IN THE MONTH), AND BY 12*31 EACH YEAR (REGARDLESS OF THE
NUMBER OF DAYS IN THE YEAR).
THE DATE IN THIS FORM IS EASILY TRANSFORMED INTO THE DAY, MONTH AND YEAR.
.NAP.NF.S
         DATE = DAY + (MONTH*31 + (YEAR*12))
.AP.F
 ^THE TIME IS REPRESENTED AS THE NUMBER OF MILLISECONDS PAST MIDNIGHT.
.NAP.NF.S
2.2 ^UNIVERSAL DATE-TIME FORMAT.
.AP.F.S
 ^THIS COMPRISES A SINGLE 36-BIT WORD WHOSE LEFT HALF IS THE NUMBER OF DAYS
SINCE ^WEDNESDAY ^NOVEMBER 18TH. 1858 (DAY 1) AND WHOSE RIGHT HALF
IS IN FRACTIONS OF A DAY, WITH A RESOLUTION OF ABOUT ONE-THIRD OF A
SECOND. ^FROM IT THE DAY OF THE WEEK AND THE NUMBER OF DAYS BETWEEN
TWO DATES IS EASILY CALCULATED.
.NAP.NF.S
2.3 ^ACCOUNTING PERIODS.
.AP.S.F
 ^THIS IS A SYSTEM OF REPRESENTATION BASED ON FOUR WEEK PERIODS. ^THE ACCOUNTING PERIOD IS
REPRESENTED AS A FOUR DIGIT NUMBER, WHERE THE FIRST PAIR OF DIGITS ARE THE
LAST TWO DIGITS OF THE YEAR, AND THE SECOND PAIR OF DIGITS IS THE MONTH
IN THE YEAR FROM 00 TO 13 WHERE THE WEEKS ARE COUNTED FROM ^MONDAY
TO ^SUNDAY INCLUSIVE.  ^E.G. 7802 IS THE SECOND PERIOD IN 1978.
.PAGE.NAP.NF
.i-4
3. ^^DEFINITION OF THE FILE SPECIFICATION RECORD\\
.s2;.nf
.NAP
.FLAG CAP
^THE FILE RECORD IS DEFINED AS FOLLOWS:
.lm0
.S
<%RECORDFORMAT <FILESPEC( %^C
   <%STRING(6) <DEV,      - ^DEVICE NAME
   <%STRING(6) <FILE,     - ^FILE NAME
   <%STRING(3) <EXT,      - ^FILE EXTENSION
   <%INTEGER <PPN,        - ^PROJECT-PROGRAMMER PAIR
   <%STRING(6)%ARRAY <SFDS(1:MAX <SFDS),
                        - ^LIST OF SUB-FILE DIRECTORIES
   <%INTEGER <PROT,       - 3 OCTAL DIGIT PROTECTION CODE
   <%STRING(20) <SWITCHES)- ^STRING OF SWITCHES
.S 1
^SWITCHES RECOGNISED BY THE <DEC-10 SYSTEM LIBRARY ARE:-
.F
.LM19.TS 19.S.I-15
   </ALLOCATE: N	^ALLOCATE 'N' CONTIGUOUS BLOCKS WHEN CREATING A FILE
.I-15
   </BLOCKSIZE:#N	^SET BLOCKSIZE FOR A DEVICE
.I-15
   </BUFFNUM: #N	^USE 'N' BUFFERS IN THE BUFFER RING
.I-15
   </BYTE: ####N	^SET THE BYTE SIZE FOR READING/WRITING
.I-15
   </DENSITY: #N	^SET DENSITY FOR MAGNETIC TAPE
( 200, 556, 800 OR 1600 BPI )
.I-15
   </ESTIMATE: N	^SET ASIDE 'N' BLOCKS WHEN CREATING A FILE
.I-15
   </EXTEND: ##N	^USE AN EXTENDED ^LOOKUP/^ENTER BLOCK
WHERE 'N' IS OMMITTED 35 OCTAL IS ASSUMED
.I-15
   </FUNCTION: N	^THE APPROPRIATE <FILOP FUNCTION IS USED
.I-15
   </MODE: ####N	^SET THE MODE TO BE THIS (THE STATUS WORD)
.I-15
   </PARITY: ##N	^SET PARITY FOR MAGNETIC TAPES: 0 = EVEN, 1 = ODD
.I-15
   </VERSION: #N	^VERSION NUMBER INTERPRETED IN <DEC <.JBVER FORMAT
(SEE ^^DEC\\SYSTEM 10 ^MONITOR ^CALLS ^MANUAL)
.LM 0.F
^SWITCHES CAN BE ABREVIATED TO THE SHORTEST UNIQUE STRING.
^NUMBERS CAN BE SPECIFIED AS OCTAL IF PRECEDED BY A HASH SIGN.
.NF.S
E.G.    </BL:_#203   - SET THE BLOCKSIZE TO OCTAL 203

.FLAGS CAP.PAGE
.LC.NAP.NOFILL;.TS 13,33
4. ^^SYSTEM LIBRARY PROCEDURES SUMMARY\\
.s2
^^NAME	CLASS TYPE	PARAMETERS\\
.S
<ACCPER	EXT %INTEGERFN	%INTEGER UDT
<ADDR	    %INTEGERFN	%NAME X
<ASCTOSTR	EXT %STRING(255)%FN	%NAME ADR
<BINTOSTR	EXT %STRING(36)%FN	%INTEGER NUM
<BLT	SYS %ROUTINE	%NAME FROM,TO %INTEGER LEN
<BYTEINTEGER	    %BYTEINTEGERMAP	%INTEGER ADR
<CALL(0-9)	EXT %ROUTINE	%NAME RTN, ...
<CALLI1	EXT %ROUTINE	%INTEGER N %INTEGERNAME AC
<CALLI2	EXT %PREDICATE	%INTEGER N %INTEGERNAME AC
<CALLI3	EXT %PREDICATE	%INTEGER N %INTEGERNAME AC
<CHARNO	    %BYTEINTEGERFN	%STRINGNAME S %INTEGER N
<CHECKPOINT	EXT %ROUTINE
<CLOSE	SYS %ROUTINE	%INTEGER CHAN
<CLOSE <DA	EXT %ROUTINE	%INTEGER CHAN
<CLOSE <INPUT	    %ROUTINE
<CLOSE <OUTPUT	    %ROUTINE
<CLOSE <SQ	EXT %ROUTINE	%INTEGER CHAN
<COPY	EXT %ROUTINE	%STRING(255) ORIG,NEW
<CPUTIME	EXT %INTEGERFN
<CUSP <FILES	EXT %ROUTINE	%RECORD(FILESPEC)%NAME R,S,
	    	T,U %INTEGER CHAN,
	    	%INTEGERNAME FOUND
<DATE	EXT %STRING(9)%FN
<DATETIME	EXT %STRING(18)%FN
<DATETOSTR	EXT %STRING(9)%FN	%INTEGER DATE
<DAY	EXT %STRING(9)%FN
<DAYTOSTR	EXT %STRING(9)%FN	%INTEGER UDT
<DDT	SYS %ROUTINE	%NAME X
<DECODE	EXT %ROUTINE	%INTEGER INST,ADR
<DEFAULT	EXT %ROUTINE	%RECORD(FILESPEC)%NAME F,F1
<DEFINE <INPUT	    %ROUTINE	%INTEGER N %STRING(255) S
^^DEFINE OUTPUT\\    %ROUTINE	%INTEGER N %STRING(255) S
<DELETE	EXT %ROUTINE	%STRING(255) SPEC
<ECHO	EXT %ROUTINE
<ENDOFPERIOD	EXT %INTEGERFN	%INTEGER PERIOD
<ESC	    %CONSTINTEGER
<EVENT	    %INTERGERFN
<EVENT <INFO	    %INTEGERFN
<FF	    %CONSTINTEGER
<FILOP	SYS %PREDICATE	%RECORD(SCB)%NAME R,
	    	%INTEGERNAME ERR
<FINIT	SYS %ROUTINE
<FLOAT	    %REALFN	%INTEGER N
<FRAC <PT	    %LONGREALFN	%LONGREAL A
<FREEVEC	SYS %ROUTINE	%INTEGER ADR,LEN
<FROMDATE	EXT %ROUTINE	%INTEGER DATE,
	    	%INTEGERNAME D,M,Y
<FROMTIME	EXT %ROUTINE	%INTEGER TIME,
	    	%INTEGERNAME H,M,S
<FROMUDT	EXT %ROUTINE	%INTEGER UDT,
	    	%INTEGERNAME DATE,TIME
<FSTOSTR	EXT %STRING(255)%FN	%RECORD(FILESPEC)%NAME FS
<GET <CHANNEL	SYS %INTEGERFN
<GETDATE	EXT %INTEGERFN
<GETNOW	EXT %INTEGERFN
<GETPAGES	SYS %ROUTINE	%INTEGER FIRST,LAST
<GETSEG	EXT %ROUTINE	%STRING(6) DEV,FILE,
	    	%STRING(3) EXT %INTEGER PPN
<GETSTS	SYS %INTEGERFN	%INTEGER CHAN
<GETTAB	SYS %PREDICATE	%INTEGER TABLE,INDEX,
	    	%INTEGERNAME RESULT
<GETTIME	EXT %INTEGERFN
<GETVEC	SYS %INTEGERFN	%INTEGER SIZE
<HEXTOSTR	EXT %STRING(9)%FN	%INTEGER N
<ICALL(0-9)	EXT %INTEGERFN	%NAME FN, ...
<IMOD	    %INTEGERFN	%INTEGER N
<INDEV	EXT %INTEGERFN
<INITFOR	SYS %ROUTINE
<INITHEAP	SYS %ROUTINE
<INITIO	SYS %ROUTINE
<INITSTACK	SYS %ROUTINE
<INPUT	SYS %ROUTINE
^^INPUT PENDING\\    %PREDICATE
<INSTATUS	EXT %INTEGERFN
<INSTREAM	    %INTEGERFN
<INT	    %INTEGERFN	%LONGREAL A
<INTEGER	    %INTEGERMAP	%INTEGER ADR
<INT <PT	    %INTEGERFN	%LONGREAL A
<INTTOSTR	EXT %STRING(12)%FN	%INTEGER N
<IOUUO	SYS %PREDICATE	%INTEGER FN,CHAN,
	    	%NAME ADR
<IOWD	SYS %INTEGERFN	%INTEGER LEN,
	    	%INTEGERNAME ADR
<ISFILE	EXT %PREDICATE	%STRING(255) SPEC
<JOBFILE	EXT %STRING(6)%FN	%STRING(3) S
<JOBNUM	EXT %INTEGERFN
<JSYS(0-4)	EXT %ROUTINE	%INTEGER N %INTEGERNAME ...
<LENGTH	    %BYTEINTEGERFN	%STRINGNAME S
<MATCH	EXT %INTEGERFN	%STRINGNAME SRC,
	    	%STRING(255) TARGET
<MOD	    %LONGREALFN	%LONGREAL A
<NEWLINE	    %ROUTINE
<NEWLINES	    %ROUTINE	%INTEGER N
<NEWPAGE	    %ROUTINE
<NEXT <ITEM	    %STRING(1)%FN
<NEXT <SYMBOL	    %INTEGERFN
<NL	    %INTEGERFN
<NOECHO	EXT %ROUTINE
<OCTTOSTR	EXT %STRING(12)%FN	%INTEGER N
<OPEN <DA	EXT %ROUTINE	%INTEGER CHAN,
	    	%STRING(255) SPEC
<OPEN <SQ	EXT %ROUTINE	%INTEGER CHAN,
	    	%STRING(255) SPEC
<OUTDEV	EXT %INTEGERFN
<OUTPUT	SYS %ROUTINE
<OUTSTATUS	EXT %INTEGERFN
<OUTSTREAM	    %INTEGERFN
<PI	    %CONSTLONGREAL
<PPN	EXT %INTEGERFN
<PRINT	    %ROUTINE	%LONGREAL A %INTEGER N,M
<PRINT <FL	    %ROUTINE	%LONGREAL A %INTEGER N
<PRINT <STRING	    %ROUTINE	%STRING(255) S
<PRINT <SYMBOL	    %ROUTINE	%INTEGER N
<PROMPT	EXT %ROUTINE	%STRING(255) S
<RAD50	EXT %INTEGERFN	%STRING(6) S
<RCALL(0-9)	EXT %REALFN	%NAME FN, ...
<READ	    %ROUTINE	%NAME A
<READ <DA	EXT %ROUTINE	%INTEGER CHAN,
	    	%INTEGERNAME BLOCK,
	    	%NAME START,END
<READ <FS	EXT %ROUTINE	%RECORD(FILESPEC)%NAME FS
<READ <HEX	EXT %ROUTINE	%INTEGERNAME N
<READ <ITEM	    %ROUTINE	%STRINGNAME S
<READ <OCTAL	EXT %ROUTINE	%INTEGERNAME N
<READ <PPN	EXT %ROUTINE	%INTEGERNAME PPN
<READ <SQ	EXT %ROUTINE	%INTEGER CHAN,
	    	%NAME START,END
<READ <STRING	    %ROUTINE	%STRINGNAME S
<READ <SYMBOL	    %ROUTINE	%NAME N
<READ <TEXT	    %ROUTINE	%STRINGNAME S,
	    	%INTEGER DELIM
<REAL	    %REALMAP	%INTEGER ADR
<RECORD	    %RECORDMAP	%INTEGER ADR
<RELEASE	SYS %ROUTINE	%INTEGER CHAN
<REM	    %INTEGERFN	%INTEGER N,M
<RENAME	EXT %ROUTINE	%STRING(255) ORIG,NEW
<REPORT	EXT %ROUTINE	%STRING(255) S
<RESET <INPUT	EXT %ROUTINE
<RESET <OUTPUT	EXT %ROUTINE
<RESTORE	EXT %ROUTINE
<RUN	EXT %ROUTINE	%STRING(6) DEV,FILE,
	    	%STRING(3) EXT,
	    	%INTEGER PPN,OFFSET
<SAVE <ACS	EXT %ROUTINE
<SDEF <INPUT	EXT %ROUTINE	%INTEGER N %STRINGNAME S
<SDEF <OUTPUT	EXT %ROUTINE	%INTEGER N %STRINGNAME S
<SELECT <INPUT	    %ROUTINE	%INTEGER N
<SELECT <OUTPUT    %ROUTINE	%INTEGER N
<SET <STREAMS	EXT %ROUTINE
<SETSTS	SYS %ROUTINE	%INTEGER CHAN,BITS
<SHIFTC	EXT %INTEGERFN	%INTEGER NUM,TIMES
<SHORTINTEGER	    %SHORTINTEGERMAP	%INTEGER ADR
<SKIP <SYMBOL	    %ROUTINE
<SLEEP	EXT %ROUTINE	%INTEGER N
<SP	    %CONSTINTEGER
<SPACE	    %ROUTINE
<SPACES	    %ROUTINE	%INTEGER N
^^STARTOFPERIOD\\EXT %INTEGERFN	%INTEGER PERIOD
<STRING	    %STRINGMAP	%INTEGER ADR
<STRTOASC	EXT %ROUTINE	%STRINGNAME S,
	    	%NAME ADR
<STRTOFS	EXT %RECORD(FILESPEC)%FN	%STRING(255) SPEC
<STRTOHEX	EXT %INTEGERFN	%STRINGNAME S
<STRTOINT	EXT %INTEGERFN	%STRINGNAME S
<STRTOOCT	EXT %INTEGERFN	%STRINGNAME S
<STRTOSIX	EXT %INTEGERFN	%STRING(6) S
<SUBEVENT	    %INTEGERFN
<SUB <STRING	    %STRING(255)%FN	%STRINGNAME S %INTEGER N,M
<SWITCH <ARG	EXT %PREDICATE	%STRING(255)%NAME S,
	    	%STRING(11) TARGET,
	    	%NAME ARG
<TAB	    %CONSTINTEGER
<TAPOP	SYS %PREDICATE	%INTEGER FUNCT,CHAN,NARGS,
	    	%INTEGERARRAYNAME ARGS,
	    	%INTEGERNAME RESULT
<TIME	EXT %STRING(8)%FN
<TIMETOSTR	EXT %STRING(8)%FN	%INTEGER TIME
<TMPCOR	SYS %ROUTINE	%INTEGER N,IOWD,FILE
<TODATE	EXT %INTEGERFN	%INTEGER D,M,Y
<TOSTRING	    %STRING(1)%FN	%INTEGER N
<TOTIME	EXT %INTEGERFN	%INTEGER H,M,S
<TOUDT	EXT %INTEGERFN	%INTEGER DATE,TIME
<UDTTOSTR	EXT %STRING(18)%FN	%INTEGER UDT
<USET <INPUT	EXT %ROUTINE	%INTEGER BLOCK
<USET <OUTPUT	EXT %ROUTINE	%INTEGER BLOCK
<WRITE	    %ROUTINE	%INTEGER N,M
<WRITE <DA	EXT %ROUTINE	%INTEGER CHAN,
	    	%INTEGERNAME BLOCK,
	    	%NAME START,END
<WRITE <FS	EXT %ROUTINE	%RECORD(FILESPEC)%NAME FS
<WRITE <HEX	EXT %ROUTINE	%INTEGER N,M
<WRITE <OCTAL	EXT %ROUTINE	%INTEGER N,M
<WRITE <PPN	EXT %ROUTINE	%INTEGER PPN
<WRITE <SQ	EXT %ROUTINE	%INTEGER CHAN,
	    	%NAME START,END
<XCOPY	EXT %ROUTINE	%RECORD(FILESPEC)%NAME F,F1
^^XDEFINE INPUT\\    %ROUTINE	    %INTEGER N,
		%RECORD(FILESPEC)%NAME FS
^^XDEFINE OUTPUT\\   %ROUTINE	    %INTEGER N,
		%RECORD(FILESPEC)%NAME FS
<XDELETE	EXT %ROUTINE	%RECORD(FILESPEC)%NAME FS
<XISFILE	EXT %PREDICATE	%RECORD(FILESPEC)%NAME FS
<XOPEN <DA	EXT %ROUTINE	%INTEGER CHAN,
	    	%RECORD(FILESPEC)%NAME FS
<XOPEN <SQ	EXT %ROUTINE	%INTEGER CHAN,
	    	RECORD(FILESPEC)%NAME FS
<XRENAME	EXT %ROUTINE	%RECORD(FILESPEC)%NAME F,F1
<ZERO	SYS %ROUTINE	%NAME FROM,TO

.page
.c;^INDEX OF ^LIBRARY ^PROCEDURES
.DO INDEX
$$$$$$$$$$$$
