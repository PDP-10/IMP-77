!FTXSPL.IMP
!   COPYRIGHT K.FARVIS ERCC.
!This is the main module of the spooler it contains the main program
!loop comprising the console command processor, the processing of P and
!Q type requests and 'read file' and 'send file' routines
!it handles the protocol at levels 0, 1 and 2 using routines in separate modules.

%BEGIN

!THE FOLLOWING ROUTINES ARE CONCERNED WITH THE TRANSPORT MECHANISM
%EXTERNALSTRING(12)%SPEC TASK NAME
%EXTERNALROUTINESPEC INIT TRANSPORT
%EXTERNALPREDICATESPEC P OPEN TRANSPORT(%STRING(1)%NAME OTHER NODE)
%EXTERNALPREDICATESPEC Q OPEN TRANSPORT
%EXTERNALROUTINESPEC CLOSE TRANSPORT
%EXTERNALROUTINESPEC RESET TRANSPORT
%EXTERNALPREDICATESPEC FTP STATE(%INTEGERNAME VALUE, %STRING(1)%NAME MESS)

!QUEUE SEARCHING ROUTINE
%EXTERNALPREDICATESPEC ANY REQUESTS(%STRING(1)%NAME NEXT)
%EXTERNALROUTINESPEC END REQUEST

!FILE STORE ROUTINES
%EXTERNALSTRING(6)%FNSPEC JOBFILE(%STRING(3) NAM)
%EXTERNALROUTINESPEC OPEN LOG
%EXTERNALROUTINESPEC CLOSE LOG
%EXTERNALROUTINESPEC LOGIT(%STRING(255) STR)
%EXTERNALROUTINESPEC PSSLOG(%STRING(1)%NAME WHAT STRING,%INTEGER STIME,GSEGS,PSEGS)
%EXTERNALROUTINESPEC OPEN INPUT(%INTEGER STREAM %STRING(1)%NAME FILENAME)
%EXTERNALROUTINESPEC OPEN OUTPUT(%INTEGER STREAM, %STRING(1)%NAME FILENAME)
%EXTERNALROUTINESPEC ABORT OUTPUT
%EXTERNALROUTINESPEC READFILES(%STRING(1)%NAME FILENAME)
%EXTERNALROUTINESPEC DISPOSE(%STRING(1)%NAME FILE,DISPOSE MESSAGE)

!NODE ROUTINES
%EXTERNALROUTINESPEC INIT NODES
%EXTERNALROUTINESPEC UPD NODES
%EXTERNALROUTINESPEC LIST SPOOL NODES
%EXTERNALPREDICATESPEC NODEOFFLINE(%STRING(1)%NAME NODE)
%EXTERNALPREDICATESPEC NODEONLINE(%STRING(1)%NAME NODE)
%EXTERNALSTRING(12)%FNSPEC OURNODE;  !RETURNS OUR NODE NUMBER
%EXTERNALROUTINESPEC SET NODE DOWN(%STRING(12)%NAME NODE,%INTEGER SECS)
%EXTERNALPREDICATESPEC GET REQUEST(%STRING(1)%NAME FILE)

%EXTERNALROUTINESPEC TELL USER(%STRING(1)%NAME USER,FIL %STRING(255) MESS)
%EXTERNALROUTINESPEC GET12(%INTEGERNAME N)

%EXTERNALROUTINESPEC MACINIT;  !SET UP CONTROL C INTERRUPTS
%EXTERNALROUTINESPEC INIT0
%EXTERNALROUTINESPEC GET0(%INTEGERNAME N)
%EXTERNALROUTINESPEC PUT0(%INTEGER N)
%EXTERNALROUTINESPEC READ0
%EXTERNALROUTINESPEC SEND0
!LEVEL 0 PARAMETER ROUTINES
%EXTERNALROUTINESPEC INIT PARAMS
%EXTERNALROUTINESPEC DEF PARAMS
%EXTERNALROUTINESPEC SET P PARAMS
%EXTERNALROUTINESPEC SKIP PARAMS
%EXTERNALPREDICATESPEC P PARAMS OK
%EXTERNALROUTINESPEC PUT0 PARAMS
%EXTERNALPREDICATESPEC GET Q PARAMS
%EXTERNALROUTINESPEC PRIVATE CODES
!LEVEL 1 AND 2
%EXTERNALROUTINESPEC READ1(%INTEGERNAME RECEIVED,RECEIVED ARG)
%EXTERNALROUTINESPEC SEND1(%INTEGER COMMAND,ARG)
%EXTERNALROUTINESPEC INIT2
%EXTERNALROUTINESPEC READ2(%INTEGER HEADER)
%EXTERNALROUTINESPEC DATA2(%INTEGERNAME LENGTH,LAST RECORD)
%EXTERNALPREDICATESPEC SEND2
%EXTERNALROUTINESPEC SKIP RECORD(%INTEGER HEADER)
%EXTERNALROUTINESPEC PRINT2(%INTEGER HEADER)
%EXTERNALROUTINESPEC IDLE(%INTEGER SECS)
%EXTERNALPREDICATESPEC FTP RECEIVE
%EXTERNALPREDICATESPEC ANY GOT

%EXTERNALROUTINESPEC CHECKPOINT
%EXTERNALSTRING(12)%FNSPEC OCTTOSTR(%INTEGER N)
%EXTERNALSTRING(12)%FNSPEC INTTOSTR(%INTEGER N)
%EXTERNALROUTINESPEC UPPERCASE(%STRING(1)%NAME STR)
%EXTERNALSTRING(9)%FNSPEC HEXTOSTR(%INTEGER N)
%EXTERNALPREDICATESPEC CALLI2(%INTEGER N,%INTEGERNAME M)
%EXTERNALROUTINESPEC REPRT(%STRING(255) STR)
%EXTERNALROUTINESPEC READLINE(%STRING(1)%NAME LINE)
%EXTERNALROUTINESPEC PROMPT(%STRING(255) STR)
%EXTERNALINTEGERFNSPEC GETTIME
%EXTERNALINTEGERFNSPEC PPN
%EXTERNALPREDICATESPEC SETSRC(%INTEGER PPN)
%EXTERNALPREDICATESPEC INPUT PENDING
%INTEGER RECEIVED, RECEIVED ARG;  !GLOBAL LEVEL 1 RECEIVED CHARS
%EXTERNALINTEGER SENT, SENT ARG;  !GLOBAL LEVEL 1 SENT CHARS
%CONSTINTEGER MAX DATA RECORD=1024;  !ALSO DEFINED IN FTP12 AND PARAM
%EXTERNALINTEGERARRAYSPEC DATA(0:MAX DATA RECORD);  !THE LEVEL 2 DATA ARRAY
%EXTERNALINTEGER PSS OUTPUT;     !FOR LOGGING TRANSFERS OVER PSS
%EXTERNALINTEGER XOURPPN
%EXTERNALSTRING(20) XOURACCOUNT;  !THE ACCOUNT NUMBER FOR THIS USER
%EXTERNALSTRING(20) XOUR NODE;     !GLOBAL CURRENT NODE NUMBER
%EXTERNALSTRING(255) XOTHER NODE;    !THE OTHER NODE WE ARE TALKING TO
%OWNSTRING(1) NUL=""
%STRING(12) COMMAND,PORQ,NODE,NEXT FILE

!THESE ARE THE GLOBAL SETTINGS FROM THE PARAMETER MODULE
%EXTERNALSTRING(96)%SPEC XFILENAME
%EXTERNALSTRING(96)%SPEC XOPMESS
%EXTERNALSTRING(96)%SPEC XMONMESS
%EXTERNALSTRING(20)%SPEC XACCOUNT
%EXTERNALSTRING(20)%SPEC XUSERNAME
%EXTERNALSTRING(20)%SPEC XOUTDEV
%EXTERNALINTEGERNAMESPEC XCODE
%EXTERNALINTEGERNAMESPEC XMODE
%EXTERNALINTEGERNAMESPEC XRSIZE
%EXTERNALINTEGERNAMESPEC XFSIZE
%EXTERNALINTEGERNAMESPEC XFACILITIES
%EXTERNALSTRING(25)%SPEC XPRIV TCODE
%EXTERNALINTEGERSPEC FTP81;  !NEW OR OLD STYLE FTP INDICATOR
%EXTERNALINTEGER I AM P;    !'P' OR 'Q' FLAG WORD
%INTEGER VALUE
%EXTERNALINTEGER LOGLEVEL
!LOGLEVEL PROVIDES THE DEGREE OF LOGGING OF MESSAGES (SEE HELP FILE BELOW)
%EXTERNALSTRING(96) LOGFILE;  !THE NAME OF THE CURRENT LOGFILE
%EXTERNALSTRING(6)%SPEC QDEV
%STRING(1) PROMPT STRING
%EXTERNALINTEGER QUFD=8_3 000003
%INTEGER BYTES;  !FOR THE NUMBER OF DATA BYTES WHICH HAVE BEEN TRANSFERRED
%INTEGER STIME;   !THE TIME AT THE START OF A TRANSFER
%EXTERNALINTEGER GSEGS,PSEGS;  !NUMBER OF SEGMENTS SENT AND RECIEVED ALTOGETHER
%INTEGER KILL;   !FLAG FOR JOB TO BE KILLED
%INTEGER PAUSING;  !FLAG FOR JOB TO PAUSE
%INTEGER STOPPING;   !FLAG FOR JOB TO STOP AFTER THIS FILE
%INTEGER TRANSFERRING;   !FLAG FOR A TRANSFER IN PROGRESS
%INTEGER STARTED;    !FLAG FOR 'START' HAVING BEEN TYPED
%INTEGER PSTARTED,QSTARTED;  !FLAGS FOR BEING EITHER P OR Q 
%INTEGER SUCCESS;    !FLAG FOR SUCCESSFUL FILE TRANSFER
%INTEGER SETUP TIME;  !TIME SINCE LAST TRANSPORT RESET
%INTEGER START TIME;  !THE TIME IN MILLISECS SINCE FILE TRANSFER STARTED
%INTEGER NUM TIMEOUTS;   !THE NUMBER OF CONSECUTIVE TIMEOUTS

%STRING(96) FILE1
%STRING(72) FILEMSG;   !SET BY READ FILE AND SEND FILE ON AN ERROR
%STRING(120) DISP MSG;    !SET BY 'DISPOSE' ROUTINE TO SAY WHAT IT DID
%STRING(255) WHAT STRING
%EXTERNALSTRING(255)%SPEC ERRMSG
%ROUTINESPEC SETUP
%ROUTINESPEC PROCESS COMMAND
   !LEVEL 0 COMMANDS
%CONSTINTEGER STOP=0, GO=1, RPOS=2, RNEG=3, SFT=4, STOPACK=5
   !LEVEL 1 COMMANDS
%CONSTINTEGER SS=16_40, MS=16_41, CS=16_42, ES=16_43, RR=16_44, MR=16_45, QR=16_46, ER=16_47
   !HEADER BIT DEFNITIONS
%CONSTINTEGER COMPRESSION BIT=16_40, BYTE COUNT=16_3F
%CONSTINTEGER TRUE=-1, FALSE=0;   !LOGIC SETTINGS
%CONSTINTEGER TTY=1, FILE=2, LOG=3
%EXTERNALINTEGER DEBUG=FALSE
%EXTERNALINTEGER OPRPRV;  !TRUE ALLOWS OPR[1,2] PRIVILIGES - DO NOT CHECK ACCESS
%CONSTINTEGER OPR PPN=8_1 000002
%CONSTINTEGER QUARTER HOUR=15*60000;  !MILLISECS
!
!******************************************************************************
!FOR TESTING PURPOSES, SET 'DEBUG' AND RUN BOTH FTP AND FTXSPL ON A DISK OTHER
!THAN THE SYSTEM DISK.  THIS WILL GIVE THE QUEUES ON [3,3] BUT INVISIBLE TO 
!THE PRODUCTION FTP.
!ALSO THE LOG FILE WILL BE DSK:nnnFTP.LOG  WHERE nnn IS THE JOB NUMBER
!
!FOR BACK TO BACK TESTING,
! START ONE VERSION AS Q ONLY AND  THEN START ANOTHER VERSION AS P ONLY
!********************************************************************************


!THE FOLLOWING PROCEDURES ARE FOR COMMAND DECODING

   %PREDICATE ALPHANUM(%INTEGERNAME S)
   !==================================
      %IF 'A'<=S<='Z' %THEN %TRUE
      %IF 'a'<=S<='z' %THEN S=S-SP %AND %TRUE
      %IF '0'<=S<='9' %THEN %TRUE
      %FALSE
   %END

   %ROUTINE IGNORE SPACES
   !======================
      %INTEGER S
      S=NEXTSYMBOL
      %WHILE S=SP %OR S=TAB %THEN SKIPSYMBOL %AND S=NEXTSYMBOL
   %END


   %ROUTINE IGNORE REST OF LINE
   !===========================
   %INTEGER I
      %CYCLE
         READSYMBOL(I)
         %IF I=ESC %THEN NEWLINE %AND %EXIT
         %EXIT %IF I=NL
      %REPEAT
   %END


   %PREDICATE COMMAND TEST(%STRING(1)%NAME COMMAND,%STRING(12) TEXT)
   !=================================================================
   !Check if a given string is a substring of a valis command
      %INTEGER I
      %FALSE %IF LENGTH(COMMAND) > LENGTH(TEXT)
      %FOR I=1,1,LENGTH(COMMAND) %CYCLE
         %FALSE %IF CHARNO(COMMAND,I) # CHARNO(TEXT,I)
      %REPEAT
      %TRUE
   %END


   %ROUTINE READ WORD(%STRING(12)%NAME STR)
   !========================================
   !Read a word up to the next terminator
      %INTEGER I
      IGNORE SPACES
      STR=""
      I=NEXTSYMBOL
      %IF I=NL %OR I=ESC %THEN %RETURN
      %CYCLE
         %UNLESS ALPHANUM(I) %START
            %IF STR="" %THEN STR=TOSTRING(I)
            %EXIT
         %FINISH
         STR=STR.TOSTRING(I)
         SKIPSYMBOL
         I=NEXTSYMBOL
      %REPEAT
   %END

   %ROUTINE READ NEXT(%STRING(1)%NAME STR)
   !========================================
   !Read a number up to the next terminator
      %INTEGER I
      IGNORE SPACES
      STR=""
      I=NEXTSYMBOL
      %IF I=NL %OR I=ESC %THEN %RETURN
      %CYCLE
         %UNLESS '0'<=I<='9' %START
            %EXIT
         %FINISH
         STR=STR.TOSTRING(I)
         SKIPSYMBOL
         I=NEXTSYMBOL
      %REPEAT
   %END



!REPORTING ROUTINES

%ROUTINE REPORT FINISH(%STRING(1)%NAME USER,FIL)
!================================================
!When a read or send has completed this informs those who wish to know
   %STRING(150) SUCC STR
   %IF SUCCESS %THEN SUCCSTR="Success ".DISP MSG %ELSE SUCCSTR="Unsuccessful - ".FILEMSG
   REPRT(SUCCSTR) %IF REM(LOGLEVEL,10)>0
   LOGIT(SUCCSTR)
   TELL USER(USER,FIL,WHAT STRING."
 ".SUCCSTR)
%END

%ROUTINE ERR REPORT(%STRING(255) STRING)
!=======================================
   REPRT("
?".STRING)
   PROMPT(PROMPT STRING)
%END

%ROUTINE WARN REPORT(%STRING(255) STRING)
!========================================
   REPRT("%".STRING)
   PROMPT(PROMPT STRING)
%END


%ROUTINE INITIALISE VARIABLES
!============================
!Sets up the variables in the various modules to their initial state
   DEF PARAMS
   INIT0; INIT2
   PSS OUTPUT=FALSE;   !FOR LOGGING A TRANSFER OVER PSS
   GSEGS=0; PSEGS=0; STIME=GET TIME
%END

%ROUTINE INIT WHAT STRING(%STRING(1)%NAME FILE)
!============================================================
   %IF (I AM P %AND XMODE&16_8000=0) %OR (XMODE&16_8000#0 %AND I AM P=FALSE) %START
      WHAT STRING=">>SENDING>> ".FILE." to ".XOTHER NODE
   %ELSE
      WHAT STRING="<<RECEIVING<< ".FILE." from ".XOTHER NODE
   %FINISH
%END
%ROUTINE READ FILE(%STRING(1)%NAME FILE1)
!=========================================
!Handles the reading of the file using the levels 1 and 2 of the protocol
!It returns when the transfer has been completed with 'SUCCESS' set to
!true or false and with a message in 'FILEMSG'
   %INTEGER HEADER
   %EXTERNALRECORD(FILESPEC)%FNSPEC STRTOFS(%STRING(255) STR)
   %RECORD(FILESPEC) FS
   %ON %EVENT 10 %START
      SUCCESS=FALSE; FILEMSG=ERRMSG." (".OCTTOSTR(EVENTINFO).")"
      ->RETURN
   %FINISH

   SUCCESS=FALSE; FILEMSG=""
   SENT=0; SENT ARG=0
   OPEN OUTPUT(FILE,FILE1)
   SELECT OUTPUT(FILE)
! HERE TO AWAIT A 'SS'
   GET12(HEADER)
   %IF HEADER#0 %START
      SEND1(QR,16_22)
      SKIP RECORD(HEADER)
   %ELSE
      READ1(RECEIVED,RECEIVED ARG)
      %UNLESS RECEIVED=SS %AND RECEIVED ARG=0 %START
         SEND1(QR,16_22)
      %FINISH
   %FINISH
! GOT AN 'SS' OR AN ERROR BY NOW, SO INTO MAIN LOOP
   START TIME=GETTIME
   %CYCLE
      %IF INPUT PENDING %START;   !CHECK THE CONSOLE FOR INPUT
         SELECT OUTPUT(TTY)
         PROCESS COMMAND
         SELECT OUTPUT(FILE)
         %IF KILL %START
            SEND1(QR,16_36)
            FILEMSG=" File transfer KILLed by operator"; ->RETURN
         %FINISH
      %FINISH
      GET12(HEADER)
      %IF HEADER=0 %START;  !A LEVEL 1 COMMAND
         READ1(RECEIVED,RECEIVED ARG)
         %CONTINUE %IF RECEIVED=MS;  !DO NOTHING ON A MARK
         %IF RECEIVED=ES %START
            %IF RECEIVED ARG=0 %START;  !ES(OK)
               %IF SENT=0 %START;  !WE HAVE NOT COMPLAINED
                  SUCCESS=TRUE; FILEMSG="";   !ON SUCCESSFUL COMLETION
                  PRINT2(16_80) %IF DATA(0)>0;  !FLUSH LAST BUFFER
                  SEND1(ER,0)
                 ->RETURN
               %ELSE
                  SEND1(ER,16_22)
               %FINISH
            %ELSE
               %IF SENT=0 %START
                  SEND1(ER,RECEIVED ARG) %UNLESS RECEIVED ARG>16_30;   !AN ES ABORT
                  FILEMSG=" File transfer aborted by sender"
               %ELSE
                  FILEMSG=" File transfer aborted by reciever:- error code ".HEXTOSTR(SENT ARG)
               %FINISH
               ->RETURN
            %FINISH
        %ELSE%IF RECEIVED=CS %START
            %IF RECEIVED ARG=0 %START
               XCODE=1
            %ELSEIF RECEIVED ARG=1 %START
               XCODE=2
            %ELSEIF RECEIVED ARG=3 %START
               private codes;   !SET UP PRIVATE CODES
            %ELSE SEND1(QR,16_22)
            %CONTINUE
         %ELSE;   !AN ILLEGAL COMMAND
            SEND1(QR,16_22)
            %CONTINUE
         %FINISH
      %ELSE;   !LEVEL 2 DATA
         %IF (XFACILITIES&1=0 %AND HEADER&COMPRESSION BIT # 0) %OR HEADER&BYTE COUNT>XRSIZE %OR SENT=QR %START
            SEND1(QR,16_22)
            SKIP RECORD(HEADER)
            %CONTINUE
         %FINISH
         BYTES=BYTES+HEADER&BYTE COUNT
         READ2(HEADER)
         PRINT2(HEADER)
      %FINISH
   %REPEAT
RETURN:
   SELECT OUTPUT(FILE)
   %IF SUCCESS=TRUE %THEN CLOSE OUTPUT %ELSE ABORT OUTPUT
   SELECT OUTPUT(TTY)
%END


%ROUTINE SEND FILE(%STRING(1)%NAME FILE1)
!========================================
!Handles the writing of the file using the levels 1 and 2 of the protocol
!It returns when the transfer has been completed with 'SUCCESS' set to
!true or false and with a message in 'FILEMSG'
   %INTEGER LAST RECORD,LENGTH
   %ON %EVENT 9,10 %START
      ->SEND END %IF EVENT=9;   !ER RECEIVED TRAP
      SUCCESS=FALSE; FILEMSG=ERRMSG." (".OCTTOSTR(EVENTINFO).")"
      SELECT INPUT(FILE); CLOSE INPUT
      SELECT INPUT(TTY); SELECT OUTPUT(TTY); NEWLINE
      %RETURN
   %FINISH

   %ROUTINE CHECK RECEIVER
   !---------------------
  !Look at the messages coming back
   %INTEGER HEADER
      %CYCLE
         GET12(HEADER)
         %IF HEADER#0 %START;  !NOT A LEVEL 1 COMMAND
            SEND1(ES,16_2A)
            SKIP RECORD(HEADER)
            %CONTINUE
         %ELSE READ1(RECEIVED,RECEIVED ARG);  !LEVEL 1 COMMAND
         %IF RECEIVED=QR %START
            SEND1(ES,RECEIVED ARG); %CONTINUE
         %FINISH
         %IF RECEIVED=ER %START
            %SIGNAL 9,99;  !TRAP IN SEND FILE ROUTINE
         %ELSE;    !NOT A MESSAGE WE ARE EXPECTING OR WANTING
            SEND1(ES,16_2A)
         %FINISH
      %REPEAT
   %END

   SUCCESS=FALSE; FILEMSG=""
   OPEN INPUT(FILE,FILE1)
   SELECT INPUT(FILE)
   RECEIVED=0; RECEIVED ARG=0
   START TIME=GETTIME
   SEND1(SS,0);  !SAY WE ARE STARTING
   %IF XPRIV TCODE#"" %START;  !PRIVATE CODE
         SEND1(CS,3)
   %ELSEIF XCODE&16_F=2 %START;  !BINARY
         SEND1(CS,1)
   %FINISH; !ELSE ASCII - DON'T SEND CS
   DATA2(BYTES,LAST RECORD);   !GET FIRST RECORD OF FILE
   %CYCLE
      SELECT INPUT(TTY)
      %IF INPUT PENDING %START;    !CHECK CONSOLE FOR INPUT
         PROCESS COMMAND
         %IF KILL %THEN SEND1(ES,16_36) %AND ->SEND END
      %FINISH
      SELECT INPUT(FILE)
      CHECK RECEIVER %IF ANY GOT
!SEND DATA
      %CONTINUE %UNLESS SEND2;   !IF ONLY SUB-RECORD OUTPUT, CONTINUE
      %EXIT %IF LAST RECORD;    !DONE IT ALL
      DATA2(LENGTH,LAST RECORD)
      BYTES=BYTES+LENGTH
   %REPEAT
!HERE AFTER LAST RECORD
   SEND1(ES,0);  !FINISH OFF
   CHECK RECEIVER
SEND END:
   SELECT INPUT(FILE); CLOSE INPUT
   SELECT INPUT(TTY); SELECT OUTPUT(TTY)
   %IF SENT=ES %START
      %IF SENT ARG=16_36 %START
         FILEMSG=" File transfer KILLed by operator"
      %ELSE
         %IF RECEIVED ARG#0 %START
            FILEMSG=" File transfer terminated by receiver"
         %ELSE
            SUCCESS=TRUE; FILEMSG="";   !SUCCESSFUL COMPLETION
         %FINISH
      %FINISH
   %ELSE
      FILEMSG=" File transfer aborted by receiver"
   %FINISH
   NEWLINE
%END


%ROUTINE P PROCESS(%STRING(1)%NAME FIL)
!=======================================
!Handles the level 0 of the protocol for the P process after the transport
!mechanism has been set up, it returns only when complete or with
!signal 14 (transport error)
   %SWITCH S(0:SFT)
   %INTEGER COMMAND,TAKE,STOP SENT

   %ON %EVENT 4,14 %START
      ->TOUT %IF STOP SENT=TRUE;  !TIMEOUT WAITING FOR AN STOPACK
      %SIGNAL 14,SUBEVENT,EVENTINFO %IF EVENT=14
      %SIGNAL 4,SUBEVENT,EVENTINFO
   %FINISH

   %IF XMODE&16_8000=0 %THEN TAKE=TRUE %ELSE TAKE=FALSE
   STOP SENT=FALSE;  !FLAG FOR STOP SENT
   SET P PARAMS;    !ADD FILE PARAMETER
   INIT WHAT STRING(FIL)
   WHAT STRING=WHAT STRING."_".XFILENAME." for user ".XOUR NODE."_".XOURACCOUNT
   START TIME=0
   REPRT(WHAT STRING) %IF REM(LOGLEVEL,10)>0
   LOGIT(WHAT STRING)
   PUT0(SFT)
   PUT0 PARAMS;   !ADD PARAMETERS
   SEND0;   !SEND IT
   READ0;   !GET REPLY
   GET0(COMMAND)
   ->S(COMMAND) %IF COMMAND<=SFT
!AN ILLEGAL MESSAGE
S(STOP): S(GO): S(SFT):
   %IF P PARAMS OK %START; %FINISH;  !JUST GET PARAMS
   PUT0(STOP); PUT0(0); !STOP ABORT SHOULD SAY WHY*****
   SEND0
   %IF COMMAND=SFT %THEN ERRMSG="Contention for sending files - waiting" %ELSE %C
      ERRMSG="Illegal message from Q - aborting"
   %SIGNAL 14,1
S(RNEG):
   %IF P PARAMS OK %START; %FINISH;   !JUST GET PARAMS
   %IF XOPMESS#"" %THEN FILEMSG=XOPMESS %ELSE FILEMSG=XMONMESS
   PUT0(STOP); PUT0(0);  !SHOULD SAY WHY****
   SEND0
   ->PEXIT
S(RPOS):
   %UNLESS P PARAMS OK %START;   !CHECK THAT THE ACKNOWLEDGEMENT IS OK
      PUT0(STOP); PUT0 PARAMS;   !ADD PARAMS
      SEND0
      FILEMSG=XMONMESS
      ->P EXIT
   %FINISH
   PUT0(GO); PUT0(0)
   SEND0
   PRIVATE CODES;  !ENABLE PRIVATE CODES
   %IF TAKE %START
      SEND FILE(FIL)
   %ELSE
      READ FILE(FIL)
   %FINISH
   PUT0(STOP); PUT0(0)
   SEND0
   STOP SENT=TRUE
   READ0;  !WAIT FOR LINE DOWN OR A STOPACK
   GET0(COMMAND)
   %IF COMMAND=STOPACK %START; !FTP80
      %IF P PARAMS OK %START; %FINISH;  !AND SKIP PARAMS
   %FINISH
TOUT:
   DISPOSE(FIL,DISP MSG) %IF SUCCESS=TRUE;  !IF TRANSFER OK
PEXIT:
   REPORT FINISH(XOURACCOUNT,FIL)
%END

%ROUTINE Q PROCESS
!=======================================
!Handles the level 0 of the protocol for the Q process after the transport
!mechanism has been set up, it returns only when complete or with
!signal 14 (transport error)
   %INTEGER COMMAND,TAKE,RESP

   %ON %EVENT 4,14 %START
      %RETURN %IF RESP=STOPACK;  !TIMEOUT WAITING FOR AN SFT
      %SIGNAL 14,SUBEVENT,EVENTINFO %IF EVENT=14
      %SIGNAL 4,SUBEVENT,EVENTINFO
   %FINISH

RESTART:
   SUCCESS=FALSE;  !DEFAULT STATE OF FILE TRANSFER
   READ0
   GET0(COMMAND)
   %UNLESS COMMAND=SFT %START
      ERRMSG=" did not get SFT"
      %SIGNAL 14,1
   %FINISH
   %UNLESS GET Q PARAMS %START
      PUT0(RNEG); RESP=RNEG
   %ELSE
      PUT0(RPOS); RESP=RPOS
   %FINISH
   %IF XMODE&16_8000=0 %THEN TAKE=TRUE %ELSE TAKE=FALSE
   INIT WHAT STRING(XFILENAME)
   START TIME=0
   REPRT(WHAT STRING) %IF REM(LOGLEVEL,10)>0
   LOGIT(WHAT STRING)
   PUT0 PARAMS;   !ASSEMBLE REPLY
   SEND0
   %IF RESP=RNEG %THEN FILEMSG=XMONMESS
   READ0
   GET0(COMMAND)
   %IF GET Q PARAMS %START; %FINISH;  !JUST GET PARAMS
   %IF COMMAND=STOP %START
      FILEMSG=XMONMESS %IF RESP=RPOS;  !ONLY CHANGE MESSAGE IF WE THOUGHT IT WAS OK
      ->QEXIT
   %FINISH
   %UNLESS COMMAND=GO %START
      ERRMSG="Did not get GO"
      %SIGNAL 14,1
   %FINISH
   PRIVATE CODES;  !ENABLE PRIVATE CODES
   %IF TAKE %START
      READ FILE(XFILENAME)
   %ELSE
      SEND FILE(XFILENAME)
   %FINISH
   READ0
   GET0(COMMAND)
   SKIP PARAMS;  !JUST GET PARAMS
   %UNLESS COMMAND=STOP %START
      LOGIT("Did not get STOP but continuing")
   %FINISH
  DISPOSE(XFILENAME,DISPMSG) %IF SUCCESS=TRUE;   !IF TRANSFER OK
QEXIT:
   %UNLESS DEBUG=TRUE %THEN REPORT FINISH(NUL,XFILENAME)
   %IF FTP81=TRUE %START
      PUT0(STOPACK); PUT0(0); RESP=STOPACK
      SEND0
      INITIALISE VARIABLES
      ->RESTART;  !WAIT FOR ANOTHER SFT OR TIMEOUT
   %FINISH
%END
!NOW ALL THE COMMANDS

%ROUTINE HELP
!=============
   PRINTSTRING("The commands are:-
CURRENT    types out current settings
DEBUG      run a test version of the spooler
DETACH     run the spooler detached
EXIT       exit to monitor leve
"); PRINTSTRING("GO         continue spooling after a PAUSE
HELP       type this text
KILL       abort current file transfer
LOG file   open a log file
"); PRINTSTRING("MSGLEVEL n n=0  - log files being transferred
                  and do not type anything
           n=1  - type files being transferred(default)"); PRINTSTRING("
           n=10 - log level 0 message headers
           n=20 - log parameters being passed
           n=30 - log level 1 messages
           n=40 - log level 2 message headers"); PRINTSTRING("
           n=50 - log level 2 data
           n=100- type transport level start-up
           n=200- type each byte received
           n=400- type each byte transmitted
"); PRINTSTRING("
NEXT nnnnnn process the given request out of sequence
NODES      list the known nodes and their status
PAUSE      stop spooling jobs after this current transfer is finished"); PRINTSTRING("
RESET      reset spooler to initial state
SET NODE <name> OFFLINE disable transfers to the named node
SET NODE <name> ONLINE  enable transfers to the named node (default)
START  (P or Q)  start transferring jobs in the queue"); PRINTSTRING("
STOP       stop transferring files after this current one and exit
           to monitor level.
TASK <name> change name of listening task (default is FTX*)
WHAT       type the state of the spooler and of any current transfer")
PRINTSTRING("
All these commands may be abbreviated to their shortest unique form.
")
%END

%ROUTINE DETACH
!==============
   %INTEGER N
   REPRT("DETACHING")
   N=8_177777 000000; !DETACH JOB AND LEAVE IN USER MODE
   %UNLESS CALLI2(8_104,N) %START
      ERR REPORT("Could not DETACH job")
   %FINISH
%END

%ROUTINE EXIT
!============
!RETURN TO MONITOR
   SELECT OUTPUT(LOG); CLOSE OUTPUT
   CLOSE TRANSPORT
   SELECT OUTPUT(TTY)
   %IF TRANSFERRING %START
      WARN REPORT("Aborting current transfer")
      REPRT(WHAT STRING)
   %FINISH
   *8_047000 000012;   !EXIT 0,
%END

%ROUTINE STOP IT
!===============
   REPRT("[FTP is stopping]")
   EXIT
%END

%ROUTINE PAUSE IT
!================
   REPRT("[FTP is pausing]")
   PROMPT STRING="/"
   CLOSE TRANSPORT
%END

%ROUTINE RESET IT
!================
!RESET VARIABLES
   BYTES=0; WHAT STRING=""; PROMPT STRING="/"
   KILL=FALSE; PAUSING=FALSE; STOPPING=FALSE; STARTED=FALSE; TRANSFERRING=FALSE
   UPD NODES
%END


%ROUTINE WHAT
!==============
!TO TYPE OUT THE CURRENT STATE OF A TRANSFER
   %IF WHAT STRING="" %START
      %IF PAUSING %THEN PAUSE IT %ELSE PRINTSTRING("[FTP is idle]")
   %ELSE
      PRINTSTRING(WHAT STRING); NEWLINE
      WRITE(BYTES//1024,1)
      %IF XFSIZE>0 %START
         PRINTSTRING(" of"); WRITE(XFSIZE,1)
         %IF BYTES#0 %START
            PRINTSTRING(" ("); WRITE((BYTES*100)//(XFSIZE*1024),0)
            PRINTSTRING("%)")
         %FINISH
      %FINISH
      PRINTSTRING(" Kbytes transferred")
      %IF START TIME#0#BYTES %START
         PRINTSTRING(" = ")
         PRINT((BYTES*8)/(GETTIME-STARTTIME),0,3)
         PRINTSTRING(" Kbaud")
      %FINISH
   %FINISH
   NEWLINE
%END

%ROUTINE CURRENT
!===============
!Prints out the current settings
   PRINTSTRING("Logfile = "); PRINTSTRING(LOGFILE);
   PRINTSTRING("   Message level ="); WRITE(LOGLEVEL,1); NEWLINE
   PRINTSTRING("Listening task name is "); PRINTSTRING(TASK NAME); NEWLINE
   %IF STARTED=TRUE %START
      PRINTSTRING("Operating as "); %IF PSTARTED=TRUE %THEN PRINTSYMBOL('P')
      %IF PSTARTED=TRUE=QSTARTED %THEN PRINTSTRING(" and ")
      %IF QSTARTED=TRUE %THEN PRINTSYMBOL('Q')
      NEWLINE
   %FINISH
   %IF NEXTFILE#"" %START
      PRINTSTRING("NEXT request to process is "); PRINTSTRING(NEXTFILE)
      NEWLINE
   %FINISH
   %IF STOPPING=TRUE %START
      %IF TRANSFERRING=TRUE %START
         PRINTSTRING("[FTP will STOP]")
      %else PRINTSTRING("[FTP is STOPped]")
      NEWLINE
   %ELSEIF PAUSING=TRUE %START
      %IF TRANSFERRING=TRUE %START
         PRINTSTRING("[FTP will PAUSE]")
      %else PRINTSTRING("[FTP is PAUSEing]")
      NEWLINE
   %ELSE%IF TRANSFERRING=FALSE %START
      PRINTSTRING("[FTP is idle]")
      NEWLINE
   %FINISH
%END

%ROUTINE PROCESS P REQUEST
!=========================
   %ON %EVENT 10 %START
      WARN REPORT(ERRMSG)
      %IF PSS OUTPUT=TRUE %START;   !CALL WAS SET UP
         WHAT STRING=WHAT STRING."
".ERRMSG
         PSSLOG(WHAT STRING,STIME,GSEGS,PSEGS)
      %FINISH
      ->1
   %FINISH

   INITIALISE VARIABLES
   OPEN LOG
   I AM P=TRUE; SUCCESS=FALSE
   %IF GET REQUEST(FILE1) %START
      %UNLESS P OPEN TRANSPORT(XOTHER NODE) %START
         WARN REPORT(ERRMSG)
         ->1
      %ELSE
         TRANSFERRING=TRUE
         P PROCESS(FILE1)
         %IF PSS OUTPUT=TRUE %START;   !CALL WAS SET UP
            PSSLOG(WHAT STRING,STIME,GSEGS,PSEGS)
         %FINISH
         NUM TIMEOUTS=0;  !RESET TIMOUT COUNT FOR SUCCESSFUL TRANSFER
      %FINISH
   %ELSE
      INIT WHAT STRING(FILE1)
      WHAT STRING=WHAT STRING."_".XFILENAME." for user".XOUR NODE."_".XOURACCOUNT
      FILEMSG=XMONMESS
      REPORT FINISH(XACCOUNT,FILE1)
   %FINISH
2: END REQUEST
   NEXTFILE=""
1:
   SETUP
   CLOSE LOG
%END


%ROUTINE PROCESS Q REQUEST
!=========================
   INITIALISE VARIABLES
   OPEN LOG
   I AM P=FALSE
   %UNLESS Q OPEN TRANSPORT %START
      WARN REPORT(ERRMSG)
   %ELSE
      TRANSFERRING=TRUE
      Q PROCESS
      NUM TIMEOUTS=0;  !RESET TIMOUT COUNT FOR SUCCESSFUL TRANSFER
   %FINISH
   SETUP
   CLOSE LOG
%END


%ROUTINE PROCESS COMMAND
!=======================
!HERE WHEN A COMMAND HAS BEEN TYPED ON THE CONSOLE
   READ WORD(COMMAND)
   ->CONTINUE %IF COMMAND=""; !A BLANK LINE
   IGNORE SPACES
   %IF COMMAND TEST(COMMAND,"KILL") %START
      KILL=TRUE %IF TRANSFERRING; IGNORE REST OF LINE
      %RETURN
   %FINISH
   %IF COMMAND TEST(COMMAND,"WHAT") %THEN WHAT %AND ->CONTINUE
   %IF COMMAND TEST(COMMAND,"CURRENT") %THEN CURRENT %AND ->CONTINUE
   %IF COMMAND TEST(COMMAND,"PAUSE") %START
      PAUSING=TRUE; STARTED=FALSE
      %IF TRANSFERRING=FALSE %THEN PAUSE IT
      ->CONTINUE
   %FINISH
   %IF COMMAND TEST(COMMAND,"START") %OR COMMAND TEST(COMMAND,"GO") %START
      %IF STARTED=TRUE %START
         WARN REPORT("FTP already started")
         ->CONTINUE
      %FINISH
      %IF COMMAND TEST(COMMAND,"START") %START;  !SEE IF MODIFIER PRESENT
         READ WORD(PORQ)
         %IF PORQ="" %START
            PSTARTED=TRUE; QSTARTED=TRUE
         %ELSEIF PORQ="P" %START
            PSTARTED=TRUE; QSTARTED=FALSE
         %ELSEIF PORQ="Q" %START
            PSTARTED=FALSE; QSTARTED=TRUE
         %ELSE
           WARN REPORT("Unknown modifier for START command ".PORQ)
            ->CONTINUE
         %FINISH
      %FINISH
      %IF TRANSFERRING=FALSE %START
         RESET IT; STARTED=TRUE; PROMPT STRING="!"
         %IF STARTED=TRUE=QSTARTED %THEN RESET TRANSPORT
      %FINISH
      ->CONTINUE
   %FINISH
   %IF COMMAND TEST(COMMAND,"STOP") %START
      STOPPING=TRUE; STARTED=FALSE
      %IF TRANSFERRING=FALSE %THEN STOP IT
      ->CONTINUE
   %FINISH
   %IF COMMAND TEST(COMMAND,"RESET") %START
      RESET IT; INIT NODES; LOGLEVEL=1
      ->CONTINUE
   %FINISH
   %IF COMMAND TEST(COMMAND,"EXIT")   %THEN EXIT
   %IF COMMAND TEST(COMMAND,"HELP")   %THEN HELP   %AND ->CONTINUE
   %IF COMMAND TEST(COMMAND,"LOG")     %START
      READFILES(LOGFILE)
      ->CONTINUE
   %FINISH
   %IF COMMAND TEST(COMMAND,"NEXT") %START
      READNEXT(NEXTFILE)
      ->CONTINUE
   %FINISH
   %IF COMMAND TEST(COMMAND,"MSGLEVEL") %START
      SKIP SYMBOL %IF NEXTSYMBOL=':'
      IGNORE SPACES; %IF ESC#NEXT SYMBOL#NL %THEN READ(LOGLEVEL)
      ->CONTINUE
   %FINISH
   %IF COMMAND TEST(COMMAND,"DETACH")   %THEN DETACH %AND ->CONTINUE
   %IF COMMAND TEST(COMMAND,"NODES") %THEN LIST SPOOL NODES %AND ->CONTINUE
   %IF COMMAND TEST(COMMAND,"SET") %START
      READ WORD(NODE); %IF COMMAND TEST(NODE,"NODE") %THEN READ WORD(NODE);  !A NOISE WORD
!      %IF  NODE="*" %THEN READ WORD(NODE) %AND NODE="*".NODE;   !A LOCAL NODE
      READ WORD(COMMAND)
      %IF COMMAND TEST(COMMAND,"ONLINE") %START
         %UNLESS NODE ONLINE(NODE) %START
            WARN REPORT("Unknown node - ".NODE)
         %FINISH
      %ELSEIF COMMAND TEST(COMMAND,"OFFLINE") %START
         %UNLESS NODE OFFLINE(NODE) %START
            WARN REPORT("Unknown node - ".NODE)
         %FINISH
      %ELSE
         WARN REPORT("Unknown command in SET NODE command - ".COMMAND)
      %FINISH
      ->CONTINUE
   %FINISH
   %IF COMMAND TEST(COMMAND,"DEBUG") %THEN DEBUG=TRUE %AND %SIGNAL 15,0,0
   %IF COMMAND TEST(COMMAND,"TASK") %START
      IGNORE SPACES; %IF ESC#NEXT SYMBOL#NL %THEN READLINE(TASK NAME) %AND UPPER CASE(TASK NAME)
      ->CONT1
   %FINISH
   PRINTSTRING("?Unrecognised command """)
   PRINTSTRING(COMMAND); PRINTSTRING(""" type HELP")
   NEWLINE
CONTINUE:
   IGNORE REST OF LINE
CONT1:
   PROMPT(PROMPT STRING)
%END


%ROUTINE SETUP
!=============
   %IF XOURPPN =OPR PPN %START
      %UNLESS SETSRC(XOURPPN) %START; %FINISH
   %FINISH
   SELECT INPUT(TTY); SELECT OUTPUT(TTY)
   WHAT STRING=""; FILEMSG=""
   BYTES=0; KILL=FALSE; TRANSFERRING=FALSE
   %IF PAUSING=TRUE %THEN PAUSE IT
   %IF STOPPING=TRUE %THEN STOP IT
   FTP81=FALSE
   I AM P=FALSE
   %IF STARTED=TRUE %START
     %IF QSTARTED=TRUE %THEN RESET TRANSPORT %ELSE CLOSE TRANSPORT
   %FINISH
   SETUP TIME=GETTIME
%END

!MAIN PROGRAM
!=============

%ON %EVENT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 %START;   !HERE WHEN OTHER SIDE BOMBS OUT AND AS A CHATCH ALL
   ->RESTART %IF EVENT=15;   !FROM THE DEBUG COMMAND
   SELECT INPUT(FILE); SELECT OUTPUT(FILE)
   CLOSE INPUT; ABORT OUTPUT;   !SO THAT FILE DOES NOT GET WRITTEN
   SELECT OUTPUT(TTY)
   %IF EVENT=10 %AND SUBEVENT=5 %START
      ERR REPORT(ERRMSG)
      %IF EVENTINFO=3 %THEN REPRT("Probably another FTXSPL running")
      %stop
   %FINISH
   %IF EVENT=4 %AND EVENTINFO=5 %START
      %IF GSEGS=0 %START;  !Host has not replied
         ERRMSG="No response from host"
      %ELSE ERRMSG="Transport ".ERRMSG
   %FINISH
   %IF EVENT=4 %OR EVENT=14 %START
      ERRMSG=ERRMSG." on call to ".XOTHERNODE
   %FINISH
   REPRT(ERRMSG)
   LOGIT(ERRMSG)
   SETUP
   SELECT OUTPUT(LOG)
   WHAT
   CURRENT
   %IF PSS OUTPUT=TRUE %START;   !THE CALL GOT SET UP
      WHAT STRING=WHAT STRING."
".ERRMSG
      PSSLOG(WHAT STRING,STIME,GSEGS,PSEGS)
   %FINISH
   %IF NUM TIMEOUTS>=1 %START
      SET NODE DOWN(XOTHER NODE,15*60)
      NEXTFILE="";  !CLEAR NEXT INDICATOR
      NUM TIMEOUTS=0
   %ELSE
      %IF XOTHER NODE="UCL" %OR XOTHER NODE="ZUXA" %START
         SET NODE DOWN(XOTHERNODE,3*60)
      %FINISH
      NUM TIMEOUTS=NUM TIMEOUTS+1
  %FINISH
  CLOSE OUTPUT
   ->MAIN
%FINISH


DEFINE OUTPUT(TTY,"TTY:/TRMOP"); DEFINE INPUT(TTY,"TTY:/TRMOP")
SELECT INPUT(TTY); SELECT OUTPUT(TTY)
XOURPPN=PPN
%IF XOURPPN#8_1000002 %START
   PRINTSTRING("
?MUST BE LOGGED IN AS [1,2]"); %STOP
%FINISH
XOUR NODE=OUR NODE
TASK NAME="FTX*";   !DEFAULT TASK NAME FOR INCOMING TASKS

RESTART:

MACINIT
INIT NODES
INIT TRANSPORT
INIT PARAMS
%IF DEBUG=TRUE %START
   LOGFILE=JOBFILE("FTP").".LOG"; LOGLEVEL=31
%ELSE
   LOGFILE=QDEV.":FTPOPR.LOG[3,3]"; LOGLEVEL=1
%FINISH
RESET IT
SETUP
PROMPT(PROMPTSTRING)

!MAIN PROGRAM LOOP
MAIN:
SELECT INPUT(TTY); SELECT OUTPUT(TTY)
%CYCLE
   %IF INPUT PENDING %THEN PROCESS COMMAND %AND %CONTINUE;  !CONSOLE INPUT
   %IF STARTED=TRUE=QSTARTED %START
      %IF FTP RECEIVE %THEN PROCESS Q REQUEST %AND %CONTINUE;  !ANYONE TRYING TO TALK TO US
   %FINISH
   %IF STARTED=TRUE=PSTARTED %START
      %IF ANY REQUESTS(NEXTFILE) %THEN PROCESS P REQUEST %AND %CONTINUE;  !ANYTHING SPOOLED
   %FINISH
   IDLE(60)
!   %IF TRANSFERRING=FALSE %AND GETTIME-SETUP TIME>=QUARTER HOUR %THEN SETUP
%REPEAT

%ENDOFPROGRAM
