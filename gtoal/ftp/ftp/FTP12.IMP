!FTP12.IMP
!   COPYRIGHT K.FARVIS ERCC.
!THIS IS LEVEL 1 AND 2 OF THE FTP PROTOCOL
!THE INPUT/OUTPT STREAM ASSIGNMENTS ARE KEPT ACROSS ROUTIE CALLS

%EXTERNALSTRING(255)%SPEC ERRMSG
%EXTERNALINTEGERSPEC XOTHER NODE;   !THE OTHER NODE FROM US
%EXTERNALINTEGERSPEC MAX SUB RECORD;  !FOR OUTPUTTING - SPECIAL FOR UMIST
%EXTERNALINTEGERSPEC LOGLEVEL
%EXTERNALINTEGERSPEC SENT, SENT ARG;  !GLOBAL LEVEL 1 SENT CHARS
%CONSTINTEGER MAX DATA RECORD=1024;  !ALSO DEFINED IN PARAM AND FTPSPL
%CONSTINTEGER CR=13, LF=10;  !CARRIAGE RETURN AND LINE FEED
%CONSTINTEGER TRUE=-1, FALSE=0;   !LOGIC SETTINGS
%CONSTINTEGER LOG=3, FTP=5

%EXTERNALSTRING(8)%FNSPEC TIME
%EXTERNALROUTINESPEC LOGIT(%STRING(255) STR)
%EXTERNALROUTINESPEC ABORT OUTPUT
%EXTERNALSTRING(12)%FNSPEC INTTOSTR(%INTEGER N)
%EXTERNALROUTINESPEC WRITEHEX(%INTEGER N,M)
%EXTERNALROUTINESPEC WRITEOCTAL(%INTEGER N,M)
%EXTERNALROUTINESPEC GOT
%EXTERNALROUTINESPEC GET(%INTEGERNAME N)
%EXTERNALROUTINESPEC PUT(%INTEGER N)
%EXTERNALROUTINESPEC PUT OUT
%EXTERNALINTEGERNAMESPEC XCODE
%EXTERNALINTEGERNAMESPEC XFORMAT
%EXTERNALINTEGERNAMESPEC XFACILITIES
%EXTERNALINTEGERNAMESPEC XRSIZE
%EXTERNALINTEGERSPEC BINARY FILE
%EXTERNALINTEGERARRAY DATA(0:MAX DATA RECORD);    !DATA BUFFER FOR LEVEL 2
%OWNINTEGER DATA PTR;   !POINTER TO ABOVE ARRAY
%OWNINTEGER MON LINE LENGTH;   !FOR MONITOR2 ROUTINE
%OWNINTEGER PR2NUM,PR2SYM;  !OWNS FOR PRINT2 ROUTINE
%OWNINTEGER PENDING;    !FOR FORTRAN CARRIAGE CONTROL CHARACTERS
   !LEVEL 1 COMMANDS
%CONSTINTEGER SS=16_40, MS=16_41, CS=16_42, ES=16_43, RR=16_44, MR=16_45, QR=16_46, ER=16_47
%CONSTSTRING(2)%ARRAY COMMANDS1(16_40:16_47) = "SS", "MS", "CS", "ES", "RR",
     "MR", "QR", "ER"
   !HEADER BIT DEFNITIONS
%CONSTINTEGER EOR BIT=16_80, COMPRESSION BIT=16_40, BYTE COUNT=16_3F

!LEVEL 1 AND 2 ROUTINES


%EXTERNALROUTINE GET12(%INTEGERNAME N)
!=====================================
!Get a byte from the transport system, it is used to get a level 1 or 2 header word
   %INTEGER IN
   IN=INSTREAM; SELECT INPUT(FTP)
   GET(N)
   SELECT INPUT(IN)
%END



%ROUTINE MONITOR1(%INTEGER SENDING,COM,ARG)
!==========================================
!output monitoring info to the log file
   %INTEGER N
   N=OUTSTREAM
   SELECT OUTPUT(LOG)
   PRINTSTRING(TIME)
   %IF SENDING=TRUE %THEN PRINTSTRING("  <<-1-<< ") %ELSE PRINTSTRING("  >>-1->> ")
   %IF SS<=COM<=ER %THEN PRINTSTRING(COMMANDS1(COM)) %ELSE WRITEHEX(COM,3)
   WRITEHEX(ARG,3); PRINTSYMBOL(NL)
   SELECT OUTPUT(N)
%END

%EXTERNALROUTINE READ1(%INTEGERNAME RECEIVED,RECEIVED ARG)
!=========================================================
!read a level 1 command
   %INTEGER IN
   IN=INSTREAM; SELECT INPUT(FTP)
   GET(RECEIVED)
   GET(RECEIVED ARG)
   GOT
   SELECT INPUT(IN)
   %IF LOGLEVEL>=30 %THEN MONITOR1(FALSE,RECEIVED,RECEIVED ARG)
%END


%EXTERNALROUTINE SEND1(%INTEGER COMMAND,ARG)
!===========================================
!send a level 1 command
   %INTEGER OUT
   OUT=OUTSTREAM; SELECT OUTPUT(FTP)
   PUT(0);  !HEADER
   PUT(COMMAND); SENT=COMMAND
   PUT(ARG); SENT ARG=ARG
   PUT OUT
   SELECT OUTPUT(OUT)
   %IF LOGLEVEL>=30 %THEN MONITOR1(TRUE,SENT,SENT ARG)
%END


%EXTERNALROUTINE INIT2
!=====================
!initialise the level 2 variables
   PENDING=SP
   PR2NUM=0; PR2SYM=0
   DATA(0)=0
   DATA PTR=1
%END

%ROUTINE MONITOR2 HEADER(%INTEGER HEADER)
!========================================
!log monitoring info for level 2 header word
   %STRING(15) STR
   STR=INTTOSTR(HEADER&BYTE COUNT)
   %IF HEADER&COMPRESSION BIT#0 %THEN STR=STR." CMPRS "
   %IF HEADER&EOR BIT#0 %THEN STR=STR." EOR "
   LOGIT("Header=".STR)
   MON LINE LENGTH=0
%END


%ROUTINE MONITOR2 ITEM(%INTEGER N)
!=================================
!log monitoring info for level 2 items in record
   %INTEGER M
   MON LINE LENGTH=MON LINE LENGTH+1
   %IF XCODE=1 %START;  !ASCII
      PRINTSYMBOL(N)
      M=72
   %ELSE
      WRITEOCTAL(N&16_FF,4)
      M=20
   %FINISH
   %IF MON LINE LENGTH>M %THEN PRINTSYMBOL(NL) %AND MON LINE LENGTH=0
%END
!THE FOLLOWING ROUTINES ARE CALLED FROM 'READ FILE' ROUTINE

%EXTERNALROUTINE READ2(%INTEGER HEADER)
!======================================
!gets a level 2 data record into the internal data array, from the info given in HEADER as
!read by a previous GET12 call
   %INTEGER N,M,SYM,OUT,IN
   IN=INSTREAM; SELECT INPUT(FTP)
   OUT=OUTSTREAM
   %IF LOGLEVEL>=50 %START
      SELECT OUTPUT(LOG)
   %FINISH
   MONITOR2 HEADER(HEADER) %IF LOGLEVEL>=40
   M=HEADER&BYTE COUNT
   %IF M>0 %START
      M=DATA(0)+M
      %IF M>MAX DATA RECORD %START
         SELECT OUTPUT(OUT); SELECT INPUT(IN)
         ABORT OUTPUT
         ERRMSG="Receiving level 2 data larger than the maximum record size"
         %SIGNAL 10,0,0;    !RETURN FATAL ERROR TO READ FILE
      %FINISH
      %IF HEADER&COMPRESSION BIT %START
         GET(SYM)
         DATA(N)=SYM %FOR N=DATA(0)+1,1,M
         MONITOR2 ITEM(SYM) %IF LOGLEVEL>=50
      %ELSE
         GET(DATA(N)) %FOR N=DATA(0)+1,1,M
         %IF LOGLEVEL>=50 %START
            MONITOR2 ITEM(DATA(N)) %FOR N=DATA(0)+1,1,M
         %FINISH
      %FINISH
      DATA(0)=M
   %FINISH
   LOGIT("") %AND SELECT OUTPUT(OUT) %IF LOGLEVEL>=50
   SELECT INPUT(IN)
%END

%ROUTINE PRSYM(%INTEGER DATA)
!============================
!ROUTINE FOR OUTPUTING 8-BIT BYTES TO 36-BIT WORDS
   PR2NUM=PR2NUM+1
   %IF PR2NUM=9 %START
      PRINTSYMBOL(PR2SYM<<8!DATA)
      PR2SYM=0; PR2NUM=0
      %RETURN
   %FINISH
   %IF PR2NUM=5 %START
      PRINTSYMBOL(PR2SYM<<4!DATA>>4)
      PR2SYM=DATA
      %RETURN
   %FINISH
   PR2SYM=PR2SYM<<8!DATA
%END

%EXTERNALROUTINE PRINT2(%INTEGER HEADER)
!=======================================
!TO OUTPUT THE DATA READ BY READ2, TO A FILE
   %INTEGER N,M
   %IF BINARY FILE=TRUE %START;   !BINARY
      %IF DATA(0)>0 %START
         PRSYM(DATA(N)) %FOR N=1,1,DATA(0)
      %FINISH
      DATA(0)=0
      %RETURN
   %FINISH
!HERE FOR TEXT
   %IF HEADER&EOR BIT # 0 %START;  !EOR
      %IF XFORMAT&16_2#0 %START; !CARRIAGE CONTROL FEATURE
         %IF DATA(1)='1' %THEN NEWPAGE %ELSE%IF DATA(1)='+' %THEN PRINTSYMBOL(CR) %ELSE NEWLINE
         %IF DATA(1)='0' %THEN NEWLINE;  !I.E. TWO NEWLINES
         M=2
      %ELSE M=1
      %IF DATA(0)>=M %START
         %FOR N=M,1,DATA(0) %CYCLE
            %IF DATA(N)=LF %AND XFORMAT&16_2000#0 %THEN PRINTSYMBOL(CR)
            PRINTSYMBOL(DATA(N))
            %IF DATA(N)=CR %AND XFORMAT&16_1000#0 %THEN PRINTSYMBOL(LF)
         %REPEAT
      %FINISH
      %IF XFORMAT&3=1 %THEN NEWLINE;   !END OF RECORD=END OF LINE BUT NOT IF FORMATTING
      DATA(0)=0
   %FINISH
%END



!THE FOLLOWING ROUTINES ARE CALLED FROM 'SEND FILE' ROUTINE

%EXTERNALPREDICATE SEND2
!=======================
!SEND OUT THE DATA IN THE ARRAY 'DATA' IN SUB RECORDS IF NECESSARY
!RETURNS TRUE IF THE LAST SUB-RECORD HAS BEEN OUTPUT AND FALSE OTHERWISE
   %INTEGER N,M,END,LEN,SYM,HEADER,START,FINISH,OUT
   OUT=OUTSTREAM
   START=DATA PTR; FINISH=DATA(0)
   %IF START+MAX SUBRECORD > FINISH %THEN END=FINISH %ELSE END=START+MAX SUBRECORD-1
   LEN=END-START+1
   %IF XFACILITIES&1#0 %AND START+2<=END %START;   !COMPRESSION
      %FOR N=START,1,END-2 %CYCLE
         %IF DATA(N)=DATA(N+1)=DATA(N+2) %START;  !FOUND SOMETHING WORTH COMPRESSING
            %IF N=START %START;    !A SUBRECORD FOR COMPRESSION
               SYM=DATA(N)
               %FOR M=START+1,1,END %CYCLE
                  %IF DATA(M)#SYM %THEN LEN=M-START %AND %EXIT
               %REPEAT
               END=START+LEN-1
               HEADER=COMPRESSION BIT!LEN
               %IF END>=FINISH %THEN HEADER=HEADER!EOR BIT
               SELECT OUTPUT(FTP)
               PUT(HEADER); PUT(SYM)
               %IF LOGLEVEL>=40 %START
                  SELECT OUTPUT(LOG)
                  MONITOR2 HEADER(HEADER)
                  MONITOR2 ITEM(SYM) %IF LOGLEVEL>=50
                  NEWLINE
               %FINISH
               ->RETURN
            %ELSE;   !FOUND SOME COMPRESSION TO DO, SO OUTPUT FIRST BIT FIRST
               LEN=N-START
               END=N-1
               %EXIT
            %FINISH
         %FINISH
       %REPEAT
   %FINISH
   HEADER=LEN
   %IF END>=FINISH %THEN HEADER=HEADER!EOR BIT
   SELECT OUTPUT(FTP)
   PUT(HEADER)
   %UNLESS LEN=0 %START
      PUT(DATA(N)) %FOR N=START,1,END
   %FINISH
   %IF LOGLEVEL>=40 %START
      SELECT OUTPUT(LOG)
      MONITOR2 HEADER(HEADER)
      %IF LOGLEVEL>=50 %START
         MONITOR2 ITEM(DATA(N)) %FOR N=START,1,END
         NEWLINE
      %FINISH
   %FINISH
RETURN:
   SELECT OUTPUT(OUT)
   %IF END>=FINISH %START
      DATA(0)=0; DATA PTR=1
      %TRUE
   %FINISH
   DATA PTR=END+1;   !MOVE POINTER UP
   %FALSE;    !MORE TO BE OUTPUT
%END


%EXTERNALROUTINE DATA2(%INTEGERNAME LENGTH,LAST)
!===============================================
!ROUTINE TO FILL THE DATA ARRAY FROM A FILE, SETS LAST TO TRUE WHEN THE LAST RECORD HAS BEEN READ
   %INTEGER LEN,M,N,SYM
   %ON %EVENT 9 %START
      LENGTH=DATA(0)
      LAST=TRUE
      %RETURN
   %FINISH

   %IF BINARY FILE=TRUE %START;     !BINARY MODE
      N=1
      %CYCLE
         %EXIT %IF N+9>XRSIZE;   !ON A FULL BUFFER
         READSYMBOL(SYM)
         DATA(N)=SYM>>28
         DATA(N+1)=SYM>>20
         DATA(N+2)=SYM>>12
         DATA(N+3)=SYM>>4
         DATA(N+4)=SYM<<4;  !SO THAT IF NEXT READ BOMBS OUT, THE LAST
!                  PART OF THE LAST WORD WILL STILL BE TRANSMITTED
         N=N+4
         DATA(0)=N
         READSYMBOL(SYM)
         DATA(N)=DATA(N)!SYM>>32
         DATA(N+1)=SYM>>24
         DATA(N+2)=SYM>>16
         DATA(N+3)=SYM>>8
         DATA(N+4)=SYM
         DATA(0)=N+4
         N=N+5
      %REPEAT
      N=NEXTSYMBOL;  !TEST FOR EOF
   %ELSE;     !TEXT MODE
      %IF XFORMAT&16_2#0 %START
         DATA(1)=PENDING; M=2; PENDING=SP; DATA(0)=DATA(0)+1
      %ELSE M=1
      %FOR LEN=M,1,XRSIZE %CYCLE
         READ SYMBOL(N) %UNTIL N#0;  !IGNORE NULLS
         %IF 0#XFORMAT#16_80 %START;  !FOR APPLICATION OF FORMATTING
            %IF XFORMAT&2#0 %START;  !FORTRAN FORMATTING
1:             %IF N=CR %START
                  %IF NEXTSYMBOL=LF %START
                      SKIPSYMBOL; PENDING=SP
                  %ELSEIF NEXTSYMBOL=FF %START
                     SKIPSYMBOL; PENDING='1'
                  %ELSE PENDING='+'
                  %EXIT
               %ELSE%IF N=FF %START
                  PENDING='1'; %EXIT
               %ELSEIF N=LF %START
                  PENDING=SP; %EXIT
               %FINISH
            %ELSEIF N=CR %AND NEXTSYMBOL=LF %START;    !IF EOR IS SIGNIFICANT
               %IF XFORMAT&16_3001#0 %THEN SKIPSYMBOL
               %IF XFORMAT&16_2000#0 %THEN N=LF;  !LF IMPLIES CR OR ELSE CR IMPLIES LF
               %EXIT %IF XFORMAT&16_1#0
            %ELSEIF N=NL %AND XFORMAT&1#0 %START
               %EXIT;    !IF A NEWLINE CHARACTER
            %FINISH
         %FINISH
         DATA(0)=DATA(0)+1
         DATA(DATA(0))=N
         %IF LEN=XRSIZE  %AND XFORMAT&2#0 %START;  !FOR END OF RECORD ON FORTRAN FORMATTING
            N=NEXTSYMBOL
            %IF N=CR %OR N=LF %OR N=FF %START
               SKIPSYMBOL; ->1
            %FINISH
         %FINISH
      %REPEAT
      %CYCLE
         N=NEXTSYMBOL;   !TEST FOR EOF
         %EXIT %IF N#0
         SKIPSYMBOL;     !IGNORE NULLS ESP AT EOF
      %REPEAT
   %FINISH
   LENGTH=DATA(0)
   LAST=FALSE;   !NOT THE LAST RECORD
%END


%EXTERNALROUTINE SKIP RECORD(%INTEGER HEADER)
!============================================
!Skips a record at level 2 given the header word.
   LOGIT("Ignoring record")
   READ2(HEADER)
   DATA(0)=DATA(0)-HEADER&BYTE COUNT
%END



%ENDOFFILE
