!VECLIB.IMP
!LIBRARY OF ROUTINES USING KNUTH'S DOUBLY LINKED DYNAMIC STORAGE ALLOCATION
!ROUTINES

%SYSTEMROUTINESPEC GET PAGES(%INTEGER FIRST,LAST)
%SYSTEMROUTINESPEC ZERO(%NAME FROM,TO)
%EXTERNALINTEGERARRAYSPEC HEAP(0:1);   !FREE SPACE VECTOR WITH DUMMY SIZE
%EXTERNALINTEGER HEAPBASE,HEAPTOP
%EXTERNALINTEGERSPEC HEAPSIZE
%EXTERNALSTRING(255)%SPEC ERRMSG
%OWNINTEGER AVAIL,ROVER
%CONSTINTEGER TAG=8_400000 000000
%CONSTINTEGER UNDEF=8_777777
%CONSTINTEGER DEFLT HEAPSIZE=9
%CONSTINTEGERNAME JBFF=8_121,JBREL=8_44

!%ROUTINESPEC PRFREELIST
%ROUTINESPEC FREEVEC(%INTEGER SIZE)

%ROUTINE GET SPACE(%INTEGER N)
!===============================
   %INTEGER SIZE,OLDTOP
   %ON %EVENT 2 %START
      ->FAIL
   %FINISH

   OLDTOP=HEAPTOP
   HEAPTOP=(HEAPTOP+N)!8_777;   !TOP OF PAGE
   %IF HEAPSIZE=-1 %START
      %IF HEAPTOP>INTEGER(JBREL) %START;  !GET MORE CORE IF DYNAMIC
         GET PAGES((OLDTOP>>9)+1,HEAPTOP>>9)
!NOW MAKE AREA INTO A FREE VECTOR AND THEN ADD IT TO LIST
         INTEGER(JBFF)=HEAPTOP+1
         INTEGER(OLDTOP)=TAG!(HEAPTOP-OLDTOP)<<18;  !HEAD OF NEW VECTOR = '-' SIZE,,0
         INTEGER(HEAPTOP-1)=TAG;                      ! END OF NEW VECTOR
         INTEGER(HEAPTOP)=TAG;                        ! END OF LIST
         FREEVEC(OLDTOP+1)
         %RETURN
      %FINISH
   %FINISH
FAIL:
   HEAPTOP=OLDTOP
   ERRMSG=ERRMSG." for heap"
   %SIGNAL 2,4,N-2
%END

%INTEGERFN SIZE OF(%INTEGER X)
   %RESULT=INTEGER(X)>>18&8_377777
%END

%INTEGERFN LINK OF(%INTEGER X)
   %RESULT=INTEGER(X)&8_777777
%END

%PREDICATE FREE(%INTEGER X)
   %TRUE %IF INTEGER(X)>=0
   %FALSE
%END

%ROUTINE SET LINK(%INTEGER N,M)
   INTEGER(N)=(INTEGER(N)&8_777777000000)!M
%END

%ROUTINE SET SIZE(%INTEGER N,M)
   INTEGER(N)=(INTEGER(N)&8_400000777777)!M<<18
%END

%ROUTINE SET TAG(%INTEGER X)
   INTEGER(X)=INTEGER(X)!8_400000000000
%END

%ROUTINE CLEAR TAG(%INTEGER X)
   INTEGER(X)=INTEGER(X)&8_377777777777
%END

%SYSTEMROUTINE INITHEAP
   %INTEGER AC,HEAPSIZ,SIZE
   %OWNINTEGER HEAPRESTART=0
! SET UP THE HEAP
   %IF HEAPRESTART=0 %START
      %IF HEAPSIZE=-1 %THEN HEAPSIZ=DEFLT HEAPSIZE %ELSE HEAPSIZ=HEAPSIZE; !DEFAULT SIZE
      %IF ADDR(HEAP(0))=UNDEF %START;  !IS IT DUMMY
         HEAPBASE=INTEGER(JBFF)
         AC=HEAPBASE+HEAPSIZ
         %IF AC>INTEGER(JBREL) %START
            GET PAGES((INTEGER(JBREL)>>9)+1,AC>>9)
         %FINISH
         HEAPTOP=INTEGER(JBREL)
         HEAPSIZ=HEAPTOP-HEAPBASE
        INTEGER(JBFF)=INTEGER(JBREL)+1
      %ELSE
         HEAPBASE=ADDR(HEAP(0))
         HEAPTOP=HEAPBASE+HEAPSIZ
      %FINISH
      HEAP RESTART=-1
   %ELSE ZERO(INTEGER(HEAPBASE),INTEGER(HEAPTOP))
!NOW SET UP THE HEAP AS A FREE SPACE LIST
   SIZE=HEAPTOP-HEAPBASE-3
   INTEGER(HEAPBASE)=HEAPBASE+3;         !  DUMMY HEADER -> FIRST
   INTEGER(HEAPBASE+1)=HEAPBASE+3;       !  DUMMY HEADER -> PREVIOUS
   INTEGER(HEAPBASE+2)=TAG;              !  DUMMY TAIL = NOT FREE
!
   INTEGER(HEAPBASE+3)=SIZE<<18!HEAPBASE;! HEADER   SIZE,, -> NEXT
   INTEGER(HEAPBASE+4)=HEAPBASE;         ! HEADER   ->PREVIOUS
!                                        ! FREE VECTOR AREA
   INTEGER(HEAPTOP-1)=SIZE<<18;          !  TAIL  SIZE,,0
   INTEGER(HEAPTOP)=TAG;                 !OFF TOP OF VECTOR AREA
   AVAIL=HEAPBASE
   ROVER=AVAIL
%END

%SYSTEMINTEGERFN GETVEC(%INTEGER N)
   %INTEGER P,K,L,PREVIOUS
   P=ROVER; N=N+2;!ADJUST N FOR HEAD AND TAIL WORDS
   %WHILE SIZE OF(P)<N %CYCLE
      P=LINK OF(P)
      %IF P=ROVER %START
         GETSPACE(N)
         P=ROVER;   !START AGAIN
      %FINISH
   %REPEAT
!HERE WHEN SPACE FOUND
   ROVER=LINK OF(P)
   K=SIZE OF(P)-N
   %IF K<9 %START
      PREVIOUS=LINK OF(P+1)
      SET LINK(PREVIOUS,ROVER)
      SET LINK(ROVER+1,PREVIOUS)
      L=P
   %ELSE
      L=P+K
      SET SIZE(P,K)
      SET SIZE(L-1,K)
      CLEAR TAG(L-1)
      SET SIZE(L,N)
   %FINISH
   SET TAG(L); INTEGER(L+SIZE OF(L)-1)=TAG
   L=L+1
   ZERO(INTEGER(L),INTEGER(L+N-3))
   %RESULT=L
%END


%SYSTEMROUTINE FREEVEC(%INTEGER P0)
!PARAMETER P IS A FRIG BECAUSE IT IS DEFINED AS A NAME PARAMEER
   %INTEGER N,F,B,P1,PREVIOUS SIZE
   P0=P0-1;  !SET TO POINT TO HEAD WORD
   N=SIZE OF(P0)
   P1=P0+N
   %UNLESS HEAPBASE<=P0<HEAPTOP %AND P1<=HEAPTOP %AND INTEGER(P0)<0 %AND INTEGER(P1-1)<0 %START
      ERRMSG="Vector being returned in FREEVEC looks wrong"; %SIGNAL 5,11,P0+1
   %FINISH
   %IF FREE(P1) %START;  !ADD IN HIGHER FREE SPACE
      N=N+SIZE OF(P1)
      F=LINK OF(P1)
      B=LINK OF(P1+1)
      %IF P1=ROVER %THEN ROVER =AVAIL
      P1=P1+SIZE OF(P1)
      %IF FREE(P0-1) %START
         SET LINK(B,F)
         SET LINK(F+1,B)
         ->7
      %FINISH
   %ELSE
      ->7 %IF FREE(P0-1)
      F=LINK OF(AVAIL)
      B=AVAIL
   %FINISH
   SET LINK(P0,F)
   SET LINK(P0+1,B)
   SET LINK(F+1,P0)
   SET LINK(B,P0)
   ->8
7: PREVIOUS SIZE=SIZE OF(P0-1)
   N=N+PREVIOUS SIZE
   P0=P0-PREVIOUS SIZE
8: SET SIZE(P0,N); CLEAR TAG(P0)
   SET SIZE(P1-1,N); CLEAR TAG(P1-1)
%END
%ENDOFFILE

!HEREAFTER ARE DEBUGGING ROUTINES FOR PRINTING OUT VECTOR LIST VALUES

%EXTERNALROUTINESPEC WRITEOCTAL(%INTEGER N,M)
%EXTERNALINTEGERFNSPEC OUTSTREAM


%ROUTINE PRINT WORD 1(%INTEGER N)
   %IF INTEGER(N)<0 %THEN PRINTSYMBOL('+') %ELSE PRINTSYMBOL('-')
   WRITE(INTEGER(N)>>18&8_377777,7); WRITEOCTAL(INTEGER(N)&8_777777,7);NEWLINE
%END

%ROUTINE PRINT WORD 2(%INTEGER N)
    WRITE OCTAL(INTEGER(N)&8_777777,15); NEWLINE
%END

%EXTERNALROUTINE PRVEC(%INTEGER N)
   %INTEGER SIZE
   SIZE=INTEGER(N)>>18&8_377777
   NEWLINE
   PRINT WORD 1(N)
   PRINT WORD 2(N+1) %IF INTEGER(N)>0
   PRINTSTRING("VECTOR AREA"); NEWLINE
   PRINT WORD 1(N+SIZE-1)
%END

%EXTERNALROUTINE PRFREELIST
!PRINT OUT THE WHOLE FREE LIST
   %INTEGER P,OUT
   OUT=OUTSTREAM
   SELECT OUTPUT(0)
   P=AVAIL
   PRINTSTRING("FREE LIST:- "); NEWLINE
   %CYCLE
      PRVEC(P)
      NEWLINE
      P=LINK OF(P)
   %REPEAT %UNTIL P=AVAIL
   SELECT OUTPUT(OUT)
%END

%ENDOFFILE
