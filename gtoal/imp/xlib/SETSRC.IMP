%INCLUDE "IMP:IOLIB.INC"
%EXTERNALRECORD(SCB)%NAME%SPEC INSCB
%EXTERNALSTRING(6)%FNSPEC SIXTOSTR(%INTEGER I)
%EXTERNALROUTINESPEC RESET INPUT
%EXTERNALROUTINESPEC USET INPUT(%INTEGER N)
%OWNINTEGER N,F,C,CC,I,I1,I2,J,NENTRY
%CONSTINTEGER MAX ENTRIES=5500
%OWNINTEGERARRAY PPNS(1:MAX ENTRIES)
%OWNINTEGERARRAY LOCATION(1:MAX ENTRIES)
%CONSTINTEGER UUPHS=8_400000000000;          !Physical lookup
%CONSTINTEGER IODMP=8_17;                     !Dump mode I/O
%CONSTINTEGER OPEN=8_050;                     !Open UUO
%CONSTINTEGER LOOKUP=8_076
%CONSTINTEGER ENTER=8_077
%CONSTINTEGER USETO=8_075
%CONSTINTEGER UFD=8_654644000000;              !SIXBIT/UFD/
%CONSTINTEGER RBDIR=8_400000;            !This is a directory bit
%CONSTINTEGER STRUUO=8_50;                    !STRUUO code

%OWNINTEGERARRAY STR ARG(1:50);                !Where STRUUO args get built
!
!Standard library ROUTINE  s
!
%EXTERNALSTRING(255)%SPEC ERRMSG
%EXTERNALROUTINESPEC SLEEP(%INTEGER TIME)
%EXTERNALPREDICATESPEC CALLI2(%INTEGER N,%INTEGERNAME AC)
%SYSTEMROUTINESPEC CLOSE(%INTEGER CHAN)
%SYSTEMINTEGERFNSPEC GET CHANNEL
%SYSTEMPREDICATESPEC IO UUO(%INTEGER UUO,CHAN,%NAME ARG)
%SYSTEMROUTINESPEC RELEASE(%INTEGER CHAN)
!
!
%OWNINTEGER NSTRUCS;                           !No of structures
%OWNINTEGER CREATION=0;             !Creation date/time of AUXACC.SYS
%OWNINTEGER CHAN=0;              !I/O channel

%CONSTINTEGER TEMP STREAM=13;          !TEMP STREAM NUMBER


%ROUTINE READ AUXACC(%INTEGERNAME NO)
!=============================================

!
!Reads AUXACC.SYS putting PPN's into array PPN, and Location of the
!first word (-1) of an entry into Location
!
  %ON %EVENT 9 %START
    NO=N
    %RETURN
  %FINISH

  %INTEGERFN NEXT
    READ SYMBOL(C)
    F=F+1
    %RESULT=C
  %END

  F=0
  CC=NEXT;        !Throw away first entry
  N=0
  %CYCLE
     %SIGNAL %EVENT 15,1,1 %UNLESS NEXT=-1
     N=N+1
     %IF N>MAX ENTRIES %THEN %SIGNAL 15,1,6
     NO=NEXT;         !No of words to follow
     PPNS(N)=NEXT;    !PPN
     LOCATION(N)=F-3
     CC=NEXT %FOR I=1,1,NO-1
  %REPEAT
 %END
%INTEGERFN FIND(%INTEGER PPN)
!=====================================
     N=0
     %FOR I=1,1,NENTRY %CYCLE
      %IF PPN=PPNS(I) %THEN %RESULT=LOCATION(I)
     %IF PPN<PPNS(I) %THEN %EXIT;    !PPN's are in ascending order, so we can stop when we exceed the bound
     %REPEAT
     PPN=PPN!8_777777;              !Now try for wildcard programmer - will be after the one we stopped at.
       %FOR I=I,1,NENTRY %CYCLE
         %IF PPN=PPNS(I) %THEN %RESULT=LOCATION(I)
         %IF PPN<PPNS(I) %THEN %RESULT=0
       %REPEAT
     %RESULT=0
   %END



%ROUTINE ZERO SEARCH LIST
!==================================
!
!Zap my current search list
!
%INTEGER AC
%INTEGERARRAY ARG(1:4)

  ARG(1)=1;     !FSDSL
  ARG(2)=-1;    !Me
  ARG(3)=-1;    !My PPN
  ARG(4)=1;     !Zap search list rather than just place behind FENCE

  AC=4<<18+ADDR(ARG(1))&8_777777
  %UNLESS CALLI2(STRUUO,AC) %THEN %SIGNAL %EVENT 15,1,2
%END

%ROUTINE   SET SEARCH LIST
!=================================
!
!Set up my search list. Uses global NSTRUCS and STRARG
!
%INTEGER AC

  STRARG(1)=1;  !FSDSL
  STRARG(2)=-1; !Me
  STRARG(3)=-1; !My PPN
  AC=(4+3*NSTRUCS)<<18+ADDR(STRARG(1))&8_777777
  %UNLESS CALLI2(STRUUO,AC) %THEN %SIGNAL %EVENT 15,1,3
%END

%ROUTINE   LOCKUFD(%INTEGER STRUCTURE,PPN)
!=================================================
!
!Puts on UFD interlock
!
  %INTEGERARRAY ARGS(1:3)
  %INTEGER AC,AC1,COUNT

  ARGS(1)=6;    !.FSULK
  ARGS(2)=STRUCTURE
  ARGS(3)=PPN

  AC=3<<18+ADDR(ARGS(1))&8_777777
  %FOR COUNT=1,1,10 %CYCLE
    AC1=AC
    %IF CALLI2(STRUUO,AC) %THEN %RETURN
    %IF AC#AC1 %THEN %SIGNAL %EVENT 15,1,4 %ELSE SLEEP(6000)
  %REPEAT
  %SIGNAL %EVENT 15,1,5
%END


%ROUTINE   UNLOCK UFD(%INTEGER NAME,PPN)
!==================================================
%INTEGER %ARRAY ARGS(1:3)
%INTEGER AC
  ARGS(1)=7;     !.FSUCL
  ARGS(2)=NAME
  ARGS(3)=PPN
  AC=3<<18+ADDR(ARGS(1))&8_777777

  %UNLESS CALLI2(STRUUO,AC) %THEN %SIGNAL %EVENT 15,1,5
%END

%ROUTINE   DOUFD(%INTEGER PPN)
!=======================
%RECORD (OPENBLOCK) OBLOCK
%RECORD (LOOKUPBLOCK) LBLOCK
%INTEGER STR,I
   %ON %EVENT 9 %START
      ERRMSG="IN DOUFD "; %SIGNAL 9,0,EVENTINFO
   %FINISH

  READ SYMBOL(STR)
  OBLOCK_STATUS=UUPHS+IODMP
  OBLOCK_DEVNAM=STR
  OBLOCK_BUFHEDS=0

  %UNLESS IOUUO(OPEN,CHAN,OBLOCK) %START
    SKIP SYMBOL %FOR I=1,1,4;     !skip rest of this entry in UFD
    %%RETURN
  %FINISH

  SKIP SYMBOL;       !Skip reserved quota
  LBLOCK=0     
  LBLOCK_CNT=29
  LBLOCK_PPN=8_1000001
  LBLOCK_NAM=PPN
  LBLOCK_EXT=UFD
  READ SYMBOL(LBLOCK_QTF)
  READ SYMBOL(LBLOCK_QTO)
  LBLOCK_STS=RBDIR

  LOCK UFD(STR,PPN)
  %IF IOUUO(LOOKUP,CHAN,LBLOCK) %START
  %ELSE %IF IOUUO(ENTER,CHAN,LBLOCK) %START
    %UNLESS IOUUO(USETO,CHAN,AC(2)) %THEN CHAN=CHAN
  %ELSE %START
    SKIP SYMBOL
    CLOSE (CHAN)
    UNLOCK UFD(STR,PPN)
    %RETURN
  %FINISH

  CLOSE (CHAN)
  UNLOCK UFD(STR,PPN)
  STRARG(3*NSTRUCS+5)=STR
  STRARG(3*NSTRUCS+6)=0
  READ SYMBOL(STRARG(3*NSTRUCS+7))
  NSTRUCS=NSTRUCS+1
%END

%EXTERNAL %PREDICATE SETSRC(%INTEGER PPN)
!========================================
   %OWNINTEGER PREVIOUS PPN=0
%EXTERNALSTRING(12)%FNSPEC INTTOSTR(%INTEGER N)
%EXTERNALSTRING(12)%FNSPEC OCTTOSTR(%INTEGER N)
   %INTEGER IN

   %ON %EVENT 9,15 %START
      %IF EVENT=9 %START
         ERRMSG="IN SETSRC"; %SIGNAL 9,0,EVENTINFO
      %FINISH
      ->FALSE
   %FINISH

  %TRUE %IF PPN=PREVIOUS PPN
  CHAN=-1
  IN=INSTREAM
  DEFINE INPUT(TEMP STREAM,"SYS:AUXACC.SYS/MODE:#400000000014/EXTEND:#35/BUFF:1")
  SELECT INPUT(TEMP STREAM)
  %IF CREATION#INSCB_LKENT_TIM %START
    READ AUXACC(NENTRY)
    CREATION=INSCB_LKENT_TIM
    RESET INPUT
  %FINISH

  I1=FIND(PPN)
  %IF I1=0 %THEN ->FALSE
  I2=I1>>7
  I1=I1&8_177
  USET INPUT(I2+1)
  %IF I1>0 %START
    SKIP SYMBOL %FOR I=1,1,I1
  %FINISH
  READ SYMBOL(C)
  READ SYMBOL(N)
  READ SYMBOL(CC)
  %SIGNAL %EVENT 15,1,1 %UNLESS C=-1 %AND (CC=PPN %OR CC=PPN!8_777777)

  CHAN=GET CHANNEL
  N=N//5
  NSTRUCS=0
  ZERO SEARCH LIST
  DO UFD(PPN) %FOR I=1,1,N
  SET SEARCH LIST
  RELEASE(CHAN)
  CLOSE INPUT; SELECT INPUT(IN)
  PREVIOUS PPN=PPN
  %TRUE
FALSE:
  RELEASE(CHAN) %IF CHAN>=0;     !IF ONE IN USE
  CLOSE INPUT
  SELECT INPUT(IN)
  PREVIOUS PPN=0
  %FALSE
%END
%ENDOFFILE
