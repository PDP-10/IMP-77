.FLAG CAP.LC
.TITLE <IMP ON THE ^^DEC\\SYSTEM-10/20: ^USER ^GUIDE
.FIG 20
.NF.CENTRE
^&^^IMP ON THE ^^DEC\\SYSTEM-10/20\&
.S.C
^&^^USERS GUIDE\\\&
.S.C
SECOND EDITION: ^JUNE 1978
.S26
^KEITH ^M. ^FARVIS,
^EDINBURGH ^REGIONAL ^COMPUTING ^CENTRE.
.FLAGS ALL;.FLAG CAP
.number 1.LC
.PAG
.C
<CONTENTS.
.TS 11,15,18,50;.NF;.NAP;.S 2
				^PAGE
^FORWARD				2
^SECTION 1.	^USING THE COMPILER	3
		^USE OF <COMPIL	4
		^COMPILER MESSAGES	4
^SECTION 2.	^EXTERNAL PROCEDURES	5
		^THE SYSTEM LIBRARY	5
		<%INCLUDE FILES	6
^SECTION 3.	^INPUT AND OUTPUT	7
		^STREAM INPUT/OUTPUT	7
		^THE STREAM INPUT/OUTPUT PROCEDURES	7-9
			^SYMBOL I/O	8
			^STRING I/O	8
			^NUMBER I/O	8-9
		^STREAM INPUT/OUTPUT CONVENTIONS	9
		^EXAMPLE USING BASIC I/O PROCEDURES	9
		^STRINGS AS STREAMS	10
		^DIRECT ^ACCESS AND ^SEQUENTIAL ^FILES	11-12
		^FILE DEFINITION EFFICIENCY	13
		^EXAMPLE USING <FILESPEC RECORDS	14
		^INTERNAL HANDLING OF INPUT/OUTPUT	15
^SECTION 4.	^MEMORY ^MANAGEMENT	16-17
^SECTION 5.	^CALLING OTHER LANGUAGES	18-20
	^CALLING <FORTRAN FROM <IMP	18
	<COMMOM BLOCKS	18-19
	^CALLING <IMP FROM <FORTRAN	19
	^CALLING <MACRO FROM <IMP	20
	^CALLING <IMP FROM <MACRO	20
^SECTION 6.	^PROGRAM DEBUGGING	21-25
		<DDT	21
		</CROSS	22
		<ALIST	23-24
		<RECODE	23-25
.S 1;.C
<APPENDICES
.S
^A   ^USEFUL CONSTANTS AND VARIABLES	26
^B   ^DEFINITION OF THE FILE SPECIFICATION RECORD	27
^C   ^DEFINITION OF INTERNAL INPUT/OUTPUT RECORDS	28-30
^D   ^DATA STORAGE		31
    ^CODE CONVENTIONS	32-36
        ^REGISTER ALLOCATION	32
        ^PROCEDURE ENTRY AND EXITS	32-33
        ^PARAMETERS TO PROCEDURES	33-35
        ^PROCEDURE PARAMETERS	35
        ^USE OF MACHINE CODE	36
^E   <ASCII CHARACTER SET	37
^F   ^RELATED LIBRARY PROCEDURES	38-39
^G   ^SYSTEM LIBRARY PROCEDURES	40-43
^H   ^RUNTIME ERROR CODES	44-46
.S
^INDEX				47-48
.F.P 0.AP.PAGE
^&^FORWARD\&
 ^THIS MANUAL DESCRIBES THE OPERATION OF THE PORTABLE <IMP LANGUAGE
COMPILER ON THE ^D^E^CSYSTEM-10, TOGETHER WITH THE SYSTEM DEPENDENT
FEATURES OF THIS IMPLEMENTATION.
 ^IT IS NOT A DESCRIPTION OF THE <IMP LANGUAGE AND IT ASSUMES THE READER
HAS PREVIOUS KNOWLEDGE OF THE  <TOPS-10 OPERATING SYSTEM AS DESCRIBED
IN:-
.NAP.NF.S
   ^D^E^CSYSTEM-10 ^OPERATING ^SYSTEM ^COMMANDS MANUAL.
   (<AA-0916A-TB)
.S
COMPANION MANUALS ARE:-
.S
   ^THE <IMP-77 ^LANGUAGE: ^REFERENCE MANUAL.
   ^PETER ^S. ^ROBERTSON, ^DEPARTMENT OF ^COMPUTER ^SCIENCE,
   ^UNIVERSITY OF ^EDINBURGH.
.S
   <IMP ON THE <DEC-10: ^LIBRARY MANUAL.
   ^KEITH ^M. ^FARVIS, ^EDINBURGH ^REGIONAL ^COMPUTING ^CENTRE,
   ^EDINBURGH.
.S
OTHER MANUALS REFERRED TO IN THIS DOCUMENT ARE:-
.S
   ^D^E^CSYSTEM-10 ^MONITOR ^CALLS ^MANUAL. (<AA-0974C-TB)
   ^D^E^CSYSTEM-10 ^HARDWARE ^REFERENCE ^MANUAL. (<AA-1023A-TB)
.S.F
^IMPLEMENTATIONS OF THE PORTABLE <IMP COMPILER ARE ALSO AVAILABLE FOR:-
.NF.S
   <PDP-11
   <PDP-15
   ^INTERDATA 7/16 AND 7/32
   ^NOVA (IN A RESTRICTED FORM)
   <CIL-70
   ^NORD-10
   <ICL ^SYSTEM 4 (UNDER <EMAS OPERATING SYSTEM)
VERSIONS ARE PLANNED FOR
   ^ARGUS 700
   <VAX 11/780
.AP.F
 ^BECAUSE AN INTERMEDIATE CODE IS USED IN <IMP-77, IT ALLOWS THE
COMPILER'S FIRST PASS, WHICH DOES THE SYNTAX ANALYSIS, TO BE REPLACED BY
ONE FOR ANOTHER LANGUAGE. ^SUCH A PORTABLE VERSION OF ^ALGOL-60 IS
AVAILABLE AND A VERSION OF ^PASCAL IS BEING WRITTEN.
.PAGE
.SUBTITLE ^SECTION 1: ^&^USING THE COMPILER\&
.INDEX COMPILER
.INDEX SWITCHES
.INDEX </LIST
.INDEX </CROSS
.INDEX </NOCODE
.P 0;.AP;.F;.TS 6
.S
 ^THE <IMP COMPILER IS RUN BY THE MONITOR COMMAND
.NAP;.NF.S
	<_.R <IMP
TO WHICH THE COMPILER RESPONDS WITH THE PROMPT
.S
	*
THE COMMAND STRING IT REQUIRES IS
.S
	* _<REL-FILESPEC_> , _<LIST-FILESPEC_> = _<INPUT-FILESPEC_>
OR	* _<REL-FILESPEC_> = _<INPUT-FILESPEC_>
OR	* _<INPUT-FILESPEC_>
.S.F
 ^THE _<FILESPEC_>S REFER TO THE STANDARD <DEC-10
FILE SPECIFICATIONS NAMELY:-
.S;.NF
^DEVICE: FILENAME . EXTENSION [DIRECTORY LIST]
.AP;.F
 ^THE DIRECTORY LIST SPECIFICATION CAN INCLUDE SUB-FILE-DIRECTORIES.
^THE FOLLOWING SWITCHES TO THE COMPILER MAY ALSO BE INCLUDED AFTER ANY
OF THE FILE SPECIFICATIONS:-
.NAP.S.NF
	</CROSS  - INCLUDE A CROSS REFERENCED LISTING
	          (IMPLIES A </LIST)
	</LIST   - INCLUDE A LISTING FILE
	</NOCODE - SYNTAX CHECK ONLY
	</NOLIST - DO NOT INCLUDE A LISTING FILE
.S
^THUS 
	.<R <IMP
	* <FRED/CROSS/NOLIST/NOCODE
.S.F
WILL PRODUCE A LISTING FILE CALLED <FRED.LST CONTAINING ONLY THE CROSS
REFERENCE TABLES AND WILL ONLY DO SYNTAX CHECKING WITHOUT
GENERATING ANY CODE.
.F.AP
 ^THE DEFAULTS APPLIED TO INCOMPLETE FILE SPECIFICATIONS ARE:-
.NAP.NF
      INPUT-FILESPEC - <DSK: FILENAME . <IMP [USER]
      REL-FILESPEC   - <DSK: FILENAME . <REL [USER]
      LIST-FILESPEC  - <DSK: FILENAME . <LST [USER]
.AP;.F
 ^A <.REL FILE IS ALWAYS PRODUCED UNLESS SUPPRESSED BY THE </NOCODE SWITCH AND
A LISTING FILE IS ONLY PRODUCED IF ASKED FOR BY THE </LIST OR </CROSS
SWITCHES OR IF A LISTING FILE SPECIFICATION IS GIVEN.
.PG
.INDEX <COMPIL
.INDEX <COMPILE
.INDEX <LOAD
.INDEX <DEBUG
.INDEX <EXECUTE
.INDEX COMPILATION
.INDEX CODE
.INDEX GLA
.INDEX DIAGS
    ^&^USE OF <COMPIL\&
 ^THE COMPILER IS NORMALLY RUN BY USING THE <COMPIL CLASS OF COMMANDS, NAMELY:-
.NF;.S;.NAP
	<_.COMPILE . . .
	<_.LOAD . . .
	<_.EXECUTE . . .
	<_.DEBUG . . .
.AP;.F
 ^THE EXTENSION .<IMP IS RECOGNISED BY <COMPIL TO IMPLY THE <IMP 
COMPILER AND THE APPROPRIATE COMMAND STRING IS GENERATED AND SENT
TO THE COMPILER. ^FOR A FULL DESCRIPTION OF ^^<COMPIL\\'S FACILITIES INCLUDING
THE PASSING OF SWITCHES TO THE COMPILER SEE THE <DEC-10 <COMMANDS <MANUAL.
.S 2;.AP;.F
    ^&^COMPILER MESSAGES\&
 ^THE COMPILER RUNS IN 3 PASSES, THE FIRST DOING THE SYNTAX ANALYSIS AND
THE SECOND AND THIRD PRODUCING THE CODE.
 ^DURING THE FIRST PASS, SYNTAX ERROR MESSAGES ARE OUTPUT TO THE TELETYPE
AND THE LISTING FILE, IF ONE IS TO BE PRODUCED. ^AT THE END OF THE
FIRST PASS EITHER THE MESSAGE
.NF;.NAP;.S;.TS 6
"^PROGRAM CONTAINS    N FAULTS"
.S;.F;.AP
IS OUTPUT AND THE COMPILATION TERMINATES, OR ELSE
.NF;.NAP;.S
"   N ^STATEMENTS COMPILED"
.S;.F;.AP
IS OUTPUT AND COMPILATION CONTINUES INTO THE SECOND AND THIRD PASSES.
^ON COMPLETION, THE COMPILER OUTPUTS A MESSAGE GIVING THE
SIZES OF THE OBJECT FILE COMPONENTS. E.G.
.NAP;.NF;.S
^CODE 78 + ^GLA 23 + ^DIAGS 0 = 101 ^WORDS
.AP.F.S
WHERE '^CODE' IS THE AMOUNT OF CODE PRODUCED, '^GLA' IS THE GENERAL LINKAGE AREA
AND 'OWN' VARIABLES, '^DIAGS' THE DIAGNOSTIC INFORMATION AND
THEN THEIR SUM.
.PAGE;.AP.F
.SUBTITLE ^SECTION 2: ^&^EXTERNAL PROCEDURES\&
.INDEX LIBRARY
.INDEX SYSTEM LIBRARY
.INDEX IMPLICIT PROCEDURES
.INDEX EXTERNAL PROCEDURES
.INDEX SYSTEM PROCEDURES
.INDEX PROCEDURES
^&^THE ^SYSTEM ^LIBRARY\&
.S
 ^MOST <IMP PROGRAMS REQUIRE TO USE PROCEDURES TO DO INPUT/OUTPUT OR
PERFORM MATHEMATICAL FUNCTIONS. ^A SET OF SUCH PROCEDURES IS COLLECTED
TOGETHER IN THE SYSTEM LIBRARY. ^THIS LIBRARY IS AUTOMATICALLY SEARCHED
WHENEVER AN <IMP PROGRAM IS LOADED IN ORDER TO LINK IN ANY ROUTINES
WHICH THE PROGRAM MAY HAVE CALLED.
^THE LIBRARY CONTAINS THREE CLASSES OF PROCEDURE; IMPLICIT, EXTERNAL
AND SYSTEM PROCEDURES.
.LM 5
 1) ^THE IMPLICIT CLASS ARE THOSE WHICH DO NOT REQUIRE TO BE DECLARED
BEFORE BEING CALLED AND COMPRISE ALL THE COMMONLY USED PROCEDURES LIKE
<READSYMBOL, <WRITE AND <FRAC <PT. ^IT ALSO INCLUDES PRIMITIVE PROCEDURES
SUCH AS <ADDR AND <REM.
 2) ^THE EXTERNAL CLASS DO REQUIRE DECLARATIONS BEFORE BEING USED AND
COMPRISE THE LESS FREQUENTLY USED ROUTINES LIKE <RESET <INPUT AND <PROMPT.
 3) ^THE SYSTEM CLASS ARE SIMILAR TO THE EXTERNAL CLASS BUT COMPRISE PROCEDURES
THAT ARE EITHER VERY SYSTEM DEPENDENT OR REQUIRE SOME DETAILED KNOWLEDGE
OF THE <DEC-10 MONITOR, FOR EXAMPLE <DDT AND <GETTAB.
^IN THE DECLARATION OF SYSTEM ROUTINES, THE WORD %<SYSTEM IS USED WHERE
%<EXTERNAL IS USED IN THE EXTERNAL CLASS.
.NAP.NF.B
E.G.    <%EXTERNALROUTINESPEC <PROMPT(%STRING(255) <STR)
        <%SYSTEMROUTINESPEC <DDT(%NAME <X)
.AP.F.S
WOULD BE THE DECLARATIONS REQUIRED FOR THE ROUTINES <PROMPT AND <DDT.
.LM 0
.PAGE;.AP.F
.INDEX <%INCLUDE FILES
.INDEX EXTERNAL PROCEDURES
.INDEX SYSTEM PROCEDURES
.INDEX <IMP:
.INDEX <FORTRAN
^&<%INCLUDE ^FILES\&
.S
 ^IN THIS IMPLEMENTATION THERE ARE NO RESTRICTIONS ON WHAT STATEMENTS
MAY BE PUT IN %<INCLUDE FILES. ^HOWEVER A COMMON USE FOR THEM IS TO CONTAIN
THE DECLARATIONS OF COMMONLY USED EXTERNAL OR SYSTEM PROCEDURES, OR TO
CONTAIN GLOBAL DATA DECLARATIONS TO BE USED BY A NUMBER OF PROGRAM MODULES.
 ^TO HELP THE USER WHO REQUIRES TO USE A SET OF RELATED PROCEDURES
OF THE EXTERNAL OR SYSTEM TYPE, A NUMBER OF %<INCLUDE FILES HAVE BEEN
ASSEMBLED WHICH CONTAIN THE DECLARATIONS FOR THOSE PROCEDURES. ^THE USER
SIMPLY USES AN %<INCLUDE STATEMENT FOR THAT FILE BEFORE THEY
CALL THE PROCEDURES. ^IT SHOULD BE NOTED THAT PROCEDURES WHICH ARE DECLARED
BUT NOT USED ARE NOT LOADED UNLESS THEY WERE COMPILED IN THE SAME
FILE AS ONE WHICH NEEDS TO BE LOADED.
 ^THERE ARE ALSO A NUMBER OF INCLUDE FILES PROVIDED WHICH REFER TO
PROCEDURES WHICH ARE NOT IN THE SYSTEM LIBRARY BUT WHICH REQUIRE OTHER FILES TO BE
LOADED, BUT ALL THE  %<INCLUDE FILES HAVE THE NECESSARY DOCUMENTATION IN THEM.
 ^FOR A FULL LIST OF THE FACILITIES OFFERED LOOK AT THE INCLUDE FILES
ON THE <IMP: AREA ON DISK.
.S.NF
E.G.     %<INCLUDE "<IMP:DASQ.INC"
.F
WILL INCLUDE THE DECLARATIONS FOR ALL THE PROCEDURES CONCERNED WITH
^DIRECT ^ACCESS AND ^SEQUENTIAL ^FILES.
 ^THE FOLLOWING ARE SOME OF THE AVAILABLE FILES:-
.NAP.NF.S
	<DASQ.INC   - ^DIRECT ^ACCESS AND ^SEQUENTIAL FILES ROUTINES
	<TIME.INC   - ^DATE AND ^TIME PROCEDURES
	<FORTRA.INC - ^CALLING <FORTRAN  ROUTINES AND FUNCTIONS
	<IOLIB.INC  - ^INPUT/^OUTPUT INTERNAL RECORD DEFINITIONS
.PAGE;.AP;.F
.SUBTITLE ^SECTION 3: ^&^INPUT AND OUTPUT\&
.INDEX INPUT/OUTPUT
.INDEX STREAMS
.INDEX SWITCHES
.INDEX FILE SPECIFICATIONS
^&^STREAM INPUT/OUTPUT\&
 ^THE NORMAL MODE OF INPUT/OUTPUT IS VIA CHARACTER OR BINARY STREAMS.
^THERE ARE SIXTEEN STREAMS FOR INPUT AND SIXTEEN INDEPENDENT STREAMS FOR OUTPUT, NUMBERED
0 TO 15, HOWEVER A MAXIMUM OF 15 STREAMS OR <DA/SQ CHANNELS (EXCLUDING
STREAM 0) MAY BE OPEN AT ANY ONE TIME. ^BEFORE ONE CAN DO EITHER INPUT
OR OUTPUT A STREAM HAS TO BE
ASSOCIATED WITH A FILE AND THEN SELECTED TO BE THE CURRENT INPUT OR
OUTPUT STREAM; ALL SUBSEQUENT INPUT OR OUTPUT IS DIRECTED TO OR FROM
THAT STREAM UNTIL ANOTHER ONE IS SELECTED.
 ^WHEN ALL THE DESIRED INPUT OR OUTPUT HAS BEEN DONE, THE STREAM MAY BE
CLOSED, AN ACTION WHICH IS TAKEN AUTOMATICALLY FOR ALL OPEN STREAMS WHEN A PROGRAM
COMPLETES EXECUTION NORMALLY (I.E. WHEN A %<STOP OR %<END %<OF %<PROGRAM
STATEMENT IS EXECUTED).
 ^WHEN A PROGRAM BEGINS EXECUTION BOTH INPUT AND OUTPUT STREAM 0
ARE AUTOMATICALLY ASSOCIATED WITH THE USERS CONSOLE AND SELECTED AS THE
CURRENT STREAMS. ^THE REST OF THE STREAMS ARE ASSOCIATED WITH THE 'NUL:'
DEVICE, I.E. ANY INPUT RESULTS IN AN 'END-OF-FILE' CONDITION (%<SIGNAL %<EVENT 9)
AND ANY OUTPUT IS THROWN AWAY. ^STREAM 0 CANNOT BE REDEFINED AND WHEN
ANY OTHER STREAM IS CLOSED IT DEFAULTS BACK TO BEING ASSOCIATED WITH
THE 'NUL:' DEVICE.
.S
^&^THE STREAM INPUT/OUTPUT PROCEDURES\&
.S
^BELOW ARE THE BASIC PROCEDURES FOR INPUT AND OUTPUT, ALL OF WHICH
ARE IMPLICITLY DEFINED.
.NAP.S.NF
   ^^%ROUTINE DEFINE INPUT (%INTEGER STREAM %STRING(255) FILE)
   %ROUTINE DEFINE OUTPUT(%INTEGER STREAM %STRING(255) FILE)\\
.AP.F
^THESE ROUTINES ASSOCIATE FILES WITH STREAMS. ^THE FIRST PARAMETER IS A STREAM NUMBER
IN THE RANGE 1-15, ^THE SECOND IS A STRING WHICH CONTAINS A
<DEC-10 STYLE FILE SPECIFICATION ALLOWING FOR FULL SUB-FILE-DIRECTORY
AND SWITCH SPECIFICATIONS.
^CHARACTER STREAMS ARE THE DEFAULT, BINARY STREAMS ARE DEFINED USING THE
</MODE:_#10 SWITCH IN THE FILE SPECIFICATION.
(^SEE ^APPENDIX ^B FOR A LIST OF PERMITTED SWITCHES.)
.NAP;.NF.TS 6,15
E.G.	<DEFINE <INPUT(1,"<FRED.BIN[110,110,DATA]/MODE:_#10")
	<DEFINE <OUTPUT(12,"<JOE.LST")
.AP;.F
 ^WHEN A DEVICE NAME IS OMITTED <'DSK' IS ASSUMED AND WHEN A DIRECTORY
IS OMITTED THE USERS OWN AREA IS ASSUMED.
.NAP.S.NF
   ^^%ROUTINE SELECT INPUT (%INTEGER STREAM)
   %ROUTINE SELECT OUTPUT(%INTEGER STREAM)\\
.AP.F
^THESE ARE USED TO SELECT THE CURRENT INPUT AND OUTPUT STREAMS TO BE USED FROM THEN ON.
.NAP.NF.S.TP 4
   ^^%ROUTINE CLOSE INPUT
   %ROUTINE CLOSE OUTPUT\\
.F
^THESE ROUTINES CLOSE THE CURRENTLY SELECTED INPUT OR OUTPUT STREAMS
WHICH BECOME ATTACHED AGAIN TO THE <NUL STREAM.
.S
.INDEX SYMBOL I/O
.INDEX STRING I/O
.INDEX NUMBER I/O
.INDEX STREAMS
^&SYMBOL <I/O\&
.S
^THE FOUR PROCEDURES BELOW OPERATE ON <ASCII OR BINARY SYMBOLS, DEPENDING ON THE
MODE OF THE CURRENTLY SELECTED STREAM.
.NF.S
   ^^%ROUTINE READ SYMBOL(%INTEGER SYM)\\
.F
INPUTS THE NEXT SYMBOL ON THE CURRENT INPUT STREAM.
.NF.S
   ^^%INTEGERFN NEXT SYMBOL\\
.F
RETURNS THE NEXT SYMBOL BUT DOES NOT ADVANCE THE BUFFER POINTER, SO
THAT A SUBSEQUENT CALL OF ANY OF THE INPUT ROUTINES WILL READ IT AGAIN.
.NF.S
   ^^%ROUTINE SKIP SYMBOL\\
.F
THROWS AWAY THE NEXT SYMBOL ON THE CURRENT INPUT STREAM.
.NF.S
   ^^%ROUTINE PRINT SYMBOL(%INTEGER SYM)\\
.F
OUTPUTS THE GIVEN SYMBOL ON THE CURRENT OUTPUT STREAM.
.NF.S
^&^STRING <I/O\&
.S
   ^^%ROUTINE READ ITEM(%STRING(1)%NAME STR)\\
.F
READS THE NEXT SYMBOL FROM THE CURRENT INPUT STREAM AND RETURNS IT AS
A STRING OF LENGTH ONE IN THE GIVEN VARIABLE.
.NF.S
   ^^%STRING(1)%FN NEXT ITEM\\
.F
RETURNS THE NEXT SYMBOL FROM THE CURRENT INPUT STREAM, AS A STRING OF
LENGTH ONE, BUT DOES NOT ADVANCE THE BUFFER POINTER, SO THAT A SUBSEQUENT
CALL OF ANY INPUT ROUTINE WILL READ IT AGAIN.
.NF.S
   ^^%ROUTINE READ STRING(%STRING%NAME STR)\\
.F
READS A SERIES OF <ASCII CHARACTERS ENCLOSED WITHIN DOUBLE QUOTES, INTO
AN <IMP STRING VARIABLE.
.NF.S
   ^^%ROUTINE READ TEXT(%STRING%NAME STR, %INTEGER TERMIN)\\
.F
READS A SERIES OF <ASCII CHARACTERS UP TILL A GIVEN TERMINATOR, INTO
AN <IMP STRING VARIABLE.
.NF.S
   ^^%ROUTINE PRINT STRING(%STRING(255) STR)\\
.F
WRITES OUT THE GIVEN <IMP STRING.
.NF.S
^&^NUMBER <I/O\&
.S
   ^^%ROUTINE READ(%NAME X)\\
.F
READS A NUMBER INTO THE GIVEN VARIABLE, THE TYPE
OF NUMBER READ DEPENDS ON THE TYPE OF VARIABLE GIVEN (%<INTEGER OR %<REAL - OR ALSO %<STRING).
.NF.S
   ^^%ROUTINE WRITE(%INTEGER N,PLACES)\\
.F
OUTPUTS AN INTEGER IN A GIVEN NUMBER OF PRINTING POSITIONS.
.NF.S.TP 3
   ^^%ROUTINE PRINT(%REAL R, %INTEGER B,A)\\
.F
OUTPUTS A REAL NUMBER WITH A GIVEN NUMBER OF PRINTING
POSITIONS BEFORE AND AFTER THE DECIMAL POINT.
.NF.S
   ^^%ROUTINE PRINT FL(%REAL R, %INTEGER A)\\
.F
OUTPUTS A REAL NUMBER IN FLOATING POINT FORMAT WITH THE GIVEN NUMBER OF
DIGITS AFTER THE DECIMAL POINT.
.s 2
.F.S.AP
.INDEX STREAMS
.INDEX STREAM CONVENTIONS
^&^STREAM INPUT/OUTPUT CONVENTIONS\&
 ^IN NORMAL <ASCII MODE THE END OF A LINE IS TERMINATED BY A NEWLINE
CHARACTER, WHICH IS DEFINED AS <ASCII <LF, CARRIAGE
RETURN CHARACTERS BEING IGNORED ON INPUT AND INSERTED ON OUTPUT.
^NULL CHARACTERS ARE ALSO IGNORED. ^IF ONE WISHES TO SEE EVERY
CHARACTER AND NOT HAVE THEM EDITED IN THIS WAY, THE STREAMS SHOULD
BE SET UP WITH THE SWITCHES "</MODE:_#10/BYTE:7" IN THE
FILE SPECIFICATION.
.S
^&^EXAMPLE PROGRAM USING BASIC <I/O PROCEDURES\&
.S
^BELOW IS A SAMPLE PROGRAM USING THE BASIC INPUT/OUTPUT ROUTINES DESCRIBED ABOVE.
.S 2
.LIT
%BEGIN;   !A PROGRAM TO COPY A FILE ONTO THE TERMINAL
          !AND ONTO A LINE-PRINTER

   %CONSTINTEGER IN=1, OUT=1;     !STREAM NUMBERS
   %INTEGER SYM;          !AN INTEGER TO READ CHARACTERS INTO

   %ON %EVENT 9 %START;   !TRAP WHEN END-OF-FILE ENCOUNTERED ON INPUT
      CLOSE INPUT;        !CLOSE THE INPUT FILE
      SELECT OUTPUT(OUT); !SELECT THE LINE-PRINTER
      CLOSE OUTPUT;       !AND CLOSE IT
      %STOP;              !AND FINISH PROGRAM EXECUTION
   %FINISH

   DEFINE INPUT(IN,"MESSAG.TXT"); !OPEN INPUT FILE
   DEFINE OUTPUT(OUT,"LPT:");     !OPEN LINE-PRINTER
   SELECT INPUT(IN);              !SET TO READ FROM FILE

   %CYCLE;                 !MAIN PROGRAM LOOP
      READ SYMBOL(SYM);    !READ A CHARACTER FROM THE FILE
      PRINT SYMBOL(SYM);   !OUTPUT CHARACTER TO TERMINAL
      SELECT OUTPUT(OUT);  !SELECT LINE-PRINTER
      PRINT SYMBOL(SYM);   !AND OUTPUT CHARACTER TO THAT AS WELL
      SELECT OUTPUT(0);    !RE-SELECT TERMINAL
   %REPEAT;                !CONTINUE UNTIL END-OF-FILE EVENT 
%ENDOFPROGRAM
.END LITERAL
.PAGE.AP.F
.INDEX ^STRINGS
.INDEX ^STREAMS
.INDEX ^STRINGS AS STREAMS
^&^STRINGS AS STREAMS\&
 ^IT IS POSSIBLE TO HAVE STRING VARIABLES AS THE SOURCE AND DESTINATION
OF THE ABOVE STREAM INPUT AND OUTPUT. ^IT IS NECESSARY
TO DEFINE STREAMS TO BE ASSOCIATED WITH STRING VARIABLES BY USING
THE TWO EXTERNAL ROUTINES
.NF.NAP.S
<%EXTERNALROUTINE <SDEF <INPUT(%<<INTEGER <N, %<STRINGNAME <STRING)
<%EXTERNALROUTINE <SDEF <OUTPUT(%<<INTEGER <N, %<STRINGNAME <STRING)
.F.AP.S
THE ROUTINES <SELECT <INPUT/OUTPUT, <CLOSE <INPUT/OUTPUT AND <RESET
<INPUT/OUTPUT  OPERATE AS FOR NORMAL INPUT/OUTPUT.
^NOTE THAT AN ^END-OF-FILE CONDITION IS SIGNALLED WHEN THE END OF A STRING
IS REACHED ON INPUT, AND AN OUTPUT STREAM NEEDS
TO BE CLOSED BEFORE THE FINAL STRING LENGTH IS WRITTEN.
.PAGE.AP.F
.INDEX DIRECT ^ACCESS FILES
.INDEX ^SEQUENTIAL ^FILES
.INDEX <DA FILES
.INDEX <SQ FILES
^&^DIRECT ^ACCESS AND ^SEQUENTIAL ^FILES\&
.S
 ^IT IS OFTEN USEFUL TO READ OR WRITE A LARGE SECTION OF DATA
OR RECORDS DIRECTLY TO OR FROM A FILE, WITHOUT HAVING TO TREAT
EACH ITEM INDIVIDUALLY. ^THIS IS ACCOMPLISHED BY ^DIRECT ^ACCESS (<DA) AND
^SEQUENTIAL (<SQ) FILES. ^THE DIFFERENCE BETWEEN THEM IS
THAT WITH ^DIRECT ^ACCESS ONE CAN READ FROM AND WRITE TO ANY DESIRED
BLOCK IN A FILE, WHEREAS WITH ^SEQUENTIAL ^FILES ONE CAN ONLY
READ OR WRITE (BUT NOT BOTH) IN A SEQUENTIAL ORDER AS THE NAME INDICATES.
 ^THE <DA/SQ SYSTEM USES DATA CHANNELS IN THE RANGE 1 TO 15 WHICH WORK
INDEPENDENTLY OF THE NORMAL INPUT/OUTPUT STREAMS DESCRIBED ABOVE.
^HOWEVER ONE CAN ONLY HAVE A COMBINED MAXIMUM OF 15 STREAMS AND
CHANNELS OPEN SIMULTANEOUSLY.
 ^CHANNELS, LIKE STREAMS, MUST BE ASSOCIATED WITH FILES, BEFORE BEING USED, BUT
THERE IS NO CONCEPT OF A CURRENT CHANNEL AND THE CHANNEL NUMBER
MUST BE GIVEN WHENEVER READING, WRITING OR CLOSING A <DA/SQ CHANNEL.
 <DA CHANNELS ALLOW BOTH READS AND WRITES TO THEM, BUT WITH <SQ
FILES, THE FIRST READ OR WRITE SETS THE TYPE OF ACCESS FROM THEN ON AND
THE FILE CAN ONLY BE READ FROM OR WRITTEN TO UNTIL THE FILE IS RE-OPENED.
 ^DATA IS STORED IN THE FILES DIFFERENTLY FOR <DA AND <SQ FILES.
^IN <DA FILES DATA IS WRITTEN STARTING AT THE BEGINNING OF A BLOCK
AND ANY SPACE LEFT AT THE END OF THAT OR SUBSEQENT BLOCKS ON A
<WRITE <DA STATEMENT IS ZERO FILLED.
^IN <SQ FILES, DATA IS READ AND WRITTEN SEQUENTIALLY, WITHOUT
INTERVENING PADDING, AND WITHOUT DATA OR RECORD SEPARATORS.
 ^IF FOR EXAMPLE ONE WERE TO WRITE 3 RECORDS OF LENGTH 150 WORDS
EACH, USING A <DA FILE AND AN <SQ FILE, THE RESULTING FILES (BLOCK SIZE 128)
WOULD LOOK AS FOLLOWS:-
.S.LIT
        ____________________________________________________
DA file | RECORD  1 |       | RECORD 2 |        | RECORD 3 |
        ____________________________________________________

disk    | BLOCK 1 | BLOCK 2 | BLOCK 3 | BLOCK 4 | BLOCK 5 |

        ____________________________________________________
SQ file | RECORD 1 | RECORD 2 | RECORD 3 |
        ____________________________________________________
.END LITERAL
.PAGE
 ^THE ROUTINES WHICH OPERATE ON <DA/SQ FILES ARE DESCRIBED BRIEFLY BELOW
.INDEX ^DIRECT ^ACCESS FILES
.INDEX <DA FILES
.INDEX <SQ FILES
.INDEX FILE SPECIFICATIONS
.NF.S
   ^^%ROUTINE OPEN DA(%INTEGER CHAN, %STRING(255) FILE)
   %ROUTINE OPEN SQ(%INTEGER CHAN, %STRING(255) FILE)\\
.S.F
^THE ROUTINES <OPEN <DA AND <OPEN <SQ ARE USED TO ASSOCIATE FILES TO CHANNEL NUMBERS.
^THE CHANNEL NUMBER MUST BE IN THE RANGE 1-15 AND THE STRING CAN
CONTAIN A FULL ^^DEC\\SYSTEM-10 FILE SPECIFICATION.
.NAP.NF.S
   ^^%ROUTINE READ DA(%INTEGER CHAN, %INTEGERNAME BLOCK,
                    %NAME FIRST, LAST)
   %ROUTINE WRITE DA(%INTEGER CHAN, %INTEGERNAME BLOCK,
                    %NAME FIRST, LAST)
   %ROUTINE READ SQ(%INTEGER CHAN, %NAME FIRST, LAST)
   %ROUTINE WRITE SQ(%INTEGER CHAN, %NAME FIRST, LAST)\\
.AP.F.S
^THE READING AND WRITING ROUTINES HAVE TO SPECIFY THE CHANNEL
NUMBER AND THE <DA ROUTINES MUST GIVE THE BLOCK NUMBER FROM WHICH
READING OR WRITING IS TO TAKE PLACE. ^THE NUMBER OF
THE LAST BLOCK READ FROM OR WRITTEN TO IS RETURNED IN THE SAME VARIABLE.
^THE TWO %<NAME TYPE PARAMETERS DEFINE THE FIRST AND LAST CONSECUTIVE ITEMS TO BE
TRANSFERED AND THESE MAY BE OF ANY TYPE, INCLUDING RECORDS.
 ^THERE EXISTS A LIMITATION, BECAUSE OF THE
FACT THAT DATA IS BEING TRANSFERRED DIRECTLY TO THE
FILE, WITHOUT BUFFERING, THAT THE DATA MUST EXIST IN THE LOW SEGMENT I.E.
EITHER IN %<OWN OR %<EXTERNAL VARIABLES, OR THE DATA STACK MUST BE
DECLARED BY THE USER (SEE ^MEMORY ^MANAGEMENT SECTION).
.NAP.NF.S
   ^^%ROUTINE CLOSE DA(%INTEGER CHAN)
   %ROUTINE CLOSE SQ(%INTEGER CHAN)\\
.AP.F.S
^THESE ROUTINES CLOSE THE FILES ASSOCIATED WITH THE GIVEN CHANNEL NUMBER
AND RELEASE THE CHANNEL FOR RE-USE.
.PAG
.INDEX FILE SPECIFICATIONS
.INDEX <FILESPEC RECORDS
.F.LC.S 2
    ^&^FILE DEFINITION EFFICIENCY\&
 ^WHILST THE ABOVE METHOD OF SPECIFYING FILES USING STRINGS GIVES THE
MOST GENERAL FILE HANDLING FACILITY,
USERS MAY REQUIRE MORE FLEXIBILITY IN MANIPULATION OF THE FILE DEFINITIONS
OR MAY WISH TO SAVE SOME OF THE OVERHEAD NECCESARILY INVOLVED IN HAVING
TO PARSE THE GIVEN STRING INTO ITS COMPONENT PARTS.
 ^TO THIS END THERE IS AN IMPLICIT <%RECORD <%FORMAT CALLED <FILESPEC.
^ALL FILE SPECIFICATION STRINGS ARE INTERNALLY PARSED INTO THESE RECORDS WHICH ARE
DESCRIBED IN ^APPENDIX ^B
TOGETHER WITH A LIST OF THE SWITCHES RECOGNISED BY THE RUNTIME SYSTEM.
^THERE ARE AN EQUIVALENT SET OF ROUTINES FOR DEFINING STREAMS AND CHANNELS
WHICH TAKE THESE RECORDS AS THE SECOND PARAMETER, NAMELY 
<XDEFINE <INPUT, <XDEFINE <OUTPUT, <XOPEN <DA AND <OPEN <SQ.
 ^THERE IS ALSO AN EXTERNAL ROUTINE CALLED <READFS WHICH WILL READ IN A <FILESPEC
FORMAT RECORD DIRECTLY FROM THE CURRENT INPUT STREAM. (^SEE THE EXAMPLE BELOW.)
 ^ALL THESE ROUTINES ARE DESCRIBED IN DETAIL IN THE <IMP <DEC-10 ^LIBRARY ^MANUAL.
.NF.S.NAP
.PAGE
^&^EXAMPLE PROGRAM USING <FILESPEC RECORDS.\&
.INDEX <FILESPEC RECORDS
.UC.S 2
.LIT
%BEGIN;   !A PROGRAM TO COPY A FILE ONTO THE USERS CONSOLE
%EXTERNALROUTINESPEC PROMPT(%STRING(255) S)
%EXTERNALROUTINESPEC READFS(%RECORD(FILESPEC)%NAME FS)

%RECORD(FILESPEC) INPUT FS
%INTEGER SYM
%CONSTINTEGER IN=1;            !INPUT STREAM NUMBER

   %ON %EVENT 9 %START;        !ON END-OF-FILE
      %STOP
   %FINISH

   PROMPT("INPUT FILE:- ");    !PROMPT USER
   READFS(INPUT FS);           !READ THE FILE NAME
   !NOW ADD AN EXTENSION IF ONE IS NOT GIVEN
   INPUT FS_EXT="IMP" %IF INPUT FS_EXT=""
   XDEFINE INPUT(IN,INPUT FS); !OPEN THE FILE
   SELECT INPUT(IN);           !SELECT IT

   !NOW COPY THE FILE UNTIL AN END-OF-FILE TRAP
   %CYCLE
      READSYMBOL(SYM)
      PRINTSYMBOL(SYM)
   %REPEAT

%ENDOFPROGRAM
.END LITERAL.LC
.S 2
.PAG.F.AP
.INDEX INTERNAL I/O RECORDS
.INDEX <SCB
.INDEX STREAMS
.INDEX I/O STREAMS
.INDEX <DA/SQ CHANNELS
^&^INTERNAL HANDLING OF INPUT/OUTPUT\&
 ^ALL STREAMS AND <DA/SQ CHANNELS USE INTERNALLY DEFINED RECORDS
CALLED ^STREAM ^CONTROL ^BLOCKS (^^SCB\\S) WHICH CONTAIN ALL THE NECESSARY
INFORMATION FOR THE RUNTIME SYSTEM FOR THAT STREAM OR CHANNEL.
^NORMALLY THESE ^^SCB\\S ARE COMPLETELY HIDDEN FROM THE USER,
BUT THEY MAY BE USED TO OBTAIN INFORMATION ABOUT FILES, OR TO ALTER
THE WAY THAT I/O IS HANDLED.
 ^STREAMS HAVE TWO RECORD ARRAYS ASSOCIATED WITH THEM, ONE ARRAY FOR
INPUT AND THE OTHER FOR OUTPUT. ^THESE CONTAIN POINTERS
TO THE ^^SCB\\S OR ^^TTSCB\\S (SPECIAL CASE FOR ^TELETYPES) FOR EACH STREAM.
.NAP.NF.S
   ^^%EXTERNALRECORD(SCBNAME)%ARRAY INVEC(-1:15)
   %EXTERNALRECORD(SCBNAME)%ARRAY OUTVEC(-1:15)\\
.F
WHERE THE <SCBNAME RECORD IS DEFINED AS:-
.NF
   ^^%RECORDFORMAT SCBNAME(%RECORD(SCB)%NAME NAME)\\
.F.P
^IN ADDITION THE CURRENTLY SELECTED STREAMS ARE POINTED TO BY
TWO %<RECORD %<NAME VARIABLES, NAMELY:-
.NF
   ^^%RECORD(SCB)%NAME INSCB
   %RECORD(SCB)%NAME OUTSCB\\
.F.P
^THUS BY PROVIDING %<SPEC STATEMENTS FOR THE ABOVE AND BY %^^INCLUDE\\ING
THE FILE <IMP:IOLIB.INC (WHERE THE <SCB IS DEFINED), THE USER HAS COMPLETE
ACCESS TO ALL THE STREAMS.
^IT SHOULD BE NOTED THAT THE USERS ^TELETYPE (E.G. STREAM 0) HAS A SPECIAL
SHORT <SCB ASSOCIATED WITH IT. ^SIMILARLY THE UNASSIGNED STREAM NUMBERS HAVE
SHORT ^^SCB\\S ASSOCIATED WITH THE 'NUL:' DEVICE.
.P
^THE <DA/SQ SYSTEM HAS A SINGLE ARRAY:-
.NF
   ^^%EXTERNALRECORD(SCBNAME)%ARRAY DASQVEC(1:15)\\
.F.AP
WHICH CONTAINS POINTERS TO THE ^^SCB\\S ASSOCIATED WITH EACH CHANNEL,
UNASSIGNED CHANNELS HAVING AN ADDRESS OF ZERO.
 ^THE <SCB RECORD AND IT'S SUB-RECORDS ARE DESCRIBED IN THE
FILE <IMP:IOLIB.INC AND IN ^APPENDIX ^C.
.PAGE.AP.F
.SUBTITLE ^SECTION 4: ^&^MEMORY ^MANAGEMENT\&
.INDEX MEMORY MANAGEMENT
.INDEX HEAP
.INDEX STACK
.INDEX INPUT/OUTPUT STORAGE AREA
.INDEX ^GLA
 ^THE RUNTIME SYSTEM FOR <IMP ON THE ^^DEC\\SYSTEM-10/20 NEEDS BOTH A
STACK AND A BUFFER AREA FOR THE <I/O SUBSYTEM.
.LM 5
 ^THE STACK CONTAINS THE RETURN ADDRESSES, FROM PROCEDURES, THE PREVIOUS
STACK BASE-ADDRESS AND STORAGE FOR ALL THE LOCAL ARRAYS AND VARIABLES
WHICH ARE DYNAMICALLY ALLOCATED UPON ENTRY TO BLOCKS AND PROCEDURES.
^IT IS A DYNAMIC STACK AND GROWS UPWARDS FROM THE TOP
OF THE USERS HIGH SEGMENT.
 ^THE HEAP IS A MANAGED DATA AREA WHICH SUPPLIES VECTORS OF ANY LENGTH
AT ANY CONTEXTUAL LEVEL IN THE USER PROGRAM. ^FOR EXAMPLE THE ^INPUT/^OUTPUT
SYSTEM USES THE HEAP TO GET SPACE FOR IT'S BUFFERS. ^IT IS ALSO
DYNAMIC AND GROWS UPWARD FROM THE TOP OF THE USERS LOW SEGMENT.
.LM
.NAP.NF
.S.LIT
             _________________
            |                 |
            |                 |
            |_ _ _ _ _ _ _ _ _|
            |             ^   |
            |             |   |
            |     STACK   |   |
            |_________________|
            |   HIGH SEGMENT  |
            |       CODE      |
            |_________________|   400000
            |                 |
            |                 |
            |                 |
            |_ _ _ _ _ _ _ _ _|
            |             ^   |
            |      HEAP   |   |
            |             |   |
            |_________________|
            |                 |
            |       GLA       |
            |_ _ _ _ _ _ _ _ _|
            |                 |
            |   LOW SEGMENT   |
            |_________________|    0
.END LITERAL
.PAGE
.INDEX MEMORY MANAGEMENT
.INDEX HEAP
.INDEX ^GLA
.INDEX STACK
.F
 ^NORMALLY THESE DATA AREAS ARE ALLOCATED AND MANAGED WITHOUT THE USER NEEDING
TO KNOW OF THEIR WHEREABOUTS. ^BUT THE USER WHO WANTS CONTROL OVER THEM
MAY ASSIGN FIXED LENGTHS FOR EITHER OR BOTH AREAS
BY DECLARING THE FOLLOWING VARIABLES, TOGETHER WITH THEIR SIZE (AT COMPILE TIME),
IN ANY OF THE PROGRAM MODULES TO BE
LOADED:-
.NF.S
     <%EXTERNALINTEGER <STACK <SIZE = N
     <%EXTERNALINTEGER <HEAP <SIZE  = M
.S.AP.F
 ^THE DATA AREAS THEMSELVES CAN ALSO BE DEFINED AND THEREBY INCLUDED IN THE GENERAL
LINKAGE AREA (<GLA) THUS:-
.S.NF.NAP
     <%EXTERNALINTEGERARRAY <STACK(0:STACKSIZE)
     <%EXTERNALINTEGERARRAY <HEAP(0:HEAPSIZE)
.AP.F.S
^IT SHOULD BE NOTED THAT WHEN ONE OF THE ABOVE DATA AREA DECLARATIONS IS USED,
THE CORRESPONDING SIZE VARIABLE MUST ALSO HAVE BEEN DECLARED, TOGETHER WITH ITS
SIZE GIVEN AT COMPILE TIME.
.PAGE
.SUBTITLE ^SECTION 5: ^&^CALLING OTHER LANGUAGES\&
.AP.LC
.INDEX <FORTRAN
.INDEX CALLING <FORTRAN FROM <IMP
.INDEX INPUT/OUTPUT
.INDEX HEAP
^&^CALLING <FORTRAN FROM <IMP\&
 ^IN ORDER TO CALL <FORTRAN FROM <IMP IT IS NECESSARY TO SIMULATE <FORTRAN<'S
CALLING CONVENTIONS. ^THIS IS DONE BY HAVING A SET OF JACKET PROCEDURES.
^THE FILE <IMP:FORTRA.INC CONTAINS THE SPECIFICATIONS FOR SUCH ROUTINES
AND INTEGER AND REAL FUNCTIONS THE NAMES OF WHICH ARE <CALL0-CALL9,
<ICALL0-ICALL9 AND <RCALL0-RCALL9 RESPECTIVELY. ^THE NUMBER IN THE NAME
REFERS TO THE NUMBER OF %<NAME TYPE PARAMETERS BEING PASSED TO <FORTRAN.
^EACH PROCEDURE ACTUALLY HAS N+1 %<NAME TYPE PARAMETERS,
THE FIRST IS THE NAME OF THE <FORTRAN PROCEDURE BEING CALLED. ^THIS HAS
TO BE DECLARED AS AN EXTERNAL AND FOR EASE OF PROCESSING, IT SHOULD BE
DECLARED AS AN %<EXTERNAL %<INTEGER. ^THE EXAMPLE BELOW SHOWS A
<FORTRAN INTEGER FUNCTION CALLED <MIXUP WITH FOUR PARAMETERS,
BEING CALLED FROM <IMP.
.S 2
.LITERAL
%INCLUDE "IMP:FORTRA.INC"
%BEGIN
   %EXTERNALINTEGERSPEC MIXUP
   %INTEGER A,B,C,D,N

   ........
   N = ICALL4(MIXUP,A,B,C,D)
   . . . .
%ENDOFPROGRAM
.END LITERAL
 ^SHOULD <FORTRAN <I/O BE REQUIRED, THEN THE EXTERNAL ROUTINE <INITFOR
SHOULD BE REQUESTED AND CALLED AT THE START OF EXECUTION. ^THIS WILL
CAUSE THE <FORTRAN LIBRARY TO BE SEARCHED AND WILL INITIALISE THE INPUT/OUTPUT
SYSTEM. ^IF <I/O IS BEING DONE FROM BOTH <IMP AND <FORTRAN THEN THE
<FORTRAN CHANNELS SHOULD BE SET UP FIRST AND THEN THE <IMP ONES.
^THIS IS BECAUSE <IMP SEES IF A CHANNEL IS IN USE BEFORE IT TRIES TO ASSIGN IT.
^IT IS ALSO NECESSARY THAT THE HEAP SPACE WHERE <IMP SETS UP ITS BUFFERS
IS DECLARED IN THE USER'S OWN AREA (SEE THE MEMORY MANAGEMENT SECTION),
OTHERWISE BOTH <FORTRAN AND <IMP WILL COMPETE FOR STORE MANAGEMENT AT THE TOP
OF THE LOW SEGMENT.
.S
.INDEX <FORTRAN <COMMON BLOCKS
^&<COMMON BLOCKS\&
 ^IF <COMMON BLOCKS NEED TO BE ACCESSED FROM <IMP, THIS IS ACCOMPLISHED
BY DECLARING AN EXTERNAL BLOCK OF STORE HAVING THE SAME NAME AS
THE COMMON BLOCK AND HAVING THE SAME FORM. ^THIS CAN BE DONE EITHER BY
MAPPING ONTO AN INTEGER ARRAY OR ELSE BY DEFINING A RECORD HAVING THE
APPROPRIATE FORM.
 ^BELOW IS AN EXAMPLE PROGRAM WHICH ACCESSES THE <FORTRAN
<COMMON BLOCK:-
.S.NF
.NAP
   ^^COMMON/FORIMP/ IA,IB,IC,X,Y,Z\\
.S.F
GIVING IN <IMP:-
.S
.LITERAL
%BEGIN
   %RECORDFORMAT COMMON1(%INTEGER IA,IB, %REAL X,Y)
   %EXTERNALRECORD(COMMMON1)%SPEC FORIMP
    .......
   %IF FORIMP_IA = FORIMP_IB %THEN FORIMP_X = FORIMP_Y
    .....
%ENDOFPROGRAM
.END LITERAL
.S 2
.INDEX CALLING <IMP FROM <FORTRAN
.INDEX INPUT/OUTPUT
.INDEX HEAP
^&^CALLING <IMP FROM <FORTRAN\&
.AP
 ^AN <IMP PROCEDURE MAY BE CALLED FROM <FORTRAN JUST LIKE
AN EXTERNALLY DEFINED <FORTRAN PROCEDURE. ^IF ANY PARAMETERS NEED TO BE PASSED,
THIS MAY BE DONE EITHER THROUGH <COMMON (SEE ABOVE) OR BY THE APPROPRIATE
DECODING OF THE PARAMETERS ON THE <IMP SIDE. ^SINCE <FORTRAN
PASSES THE ADDRESS OF A LIST OF POINTERS TO THE PARAMETERS, THE <IMP PROCEDURE
SEES THE EQUIVALENT OF A %<RECORD %<NAME PARAMETER, WHOSE FORMAT IS A
LIST OF %<NAME TYPE PARAMETERS. ^THE FOLLOWING CODE WOULD
BE REQUIRED TO HANDLE THE CALL OF AN <IMP ROUTINE HAVING TWO INTEGER
NAME PARAMETERS, INVOKED BY THE <FORTRAN STATEMENT
.S
.LITERAL
      CALL IMPRTN(IVAL1,IVAL2)

.END LITERAL
.S
IN <IMP:-
.S
.LITERAL
%RECORDFORMAT IMPRTN PARAMETERS(%INTEGERNAME IVAL1,IVAL2)
%RECORD (IMPRTN PARAMETERS) R

   %EXTERNALROUTINE IMPRTN(%RECORD(IMPRTN PARAMETERS)%NAME R)
      R_IVAL1=R_IVAL1+1
      R_IVAL2=R_IVAL2-1
   %END
%ENDOFFILE
.END LITERAL
 ^IF THE <IMP INPUT/OUTPUT SYSTEM IS REQUIRED THEN A CALL FROM <FORTRAN
OF THE <IMP ROUTINES <INITIO AND <INITHEAP ARE NEEDED BEFORE ANY
<IMP INPUT/OUTPUT IS DONE. ^HOWEVER THE SAME LIMITATION EXISTS, AS FOR
CALLING <FORTRAN FROM <IMP, THAT ANY <FORTRAN <I/O CHANNELS SHOULD
BE SET UP FIRST, BEFORE <IMP <I/O IS ATTEMPTED, AND THAT THE HEAP SHOULD
BE DECLARED IN THE <IMP MODULE (SEE THE MEMORY MANAGEMENT SECTION).
.SUBTTL <IMP/MACRO CROSS CALLING
.PAGE
.INDEX INPUT/OUTPUT
.INDEX HEAP
.INDEX <MACRO
.INDEX CALLING <MACRO FROM <IMP
.INDEX CALLING <IMP FROM <MACRO
.INDEX <SCB
^&^CALLING <MACRO FROM <IMP\&
 ^NO DIFFICULTIES SHOULD BE ENCOUNTERED, SO LONG AS THE <IMP CALLING
CONVENTIONS ARE ADHERED TO AND THE BASE REGISTERS ARE ALWAYS PRESERVED.
^THE FILE <IMP:IMPPRM.MAC CONTAINS THE DEFINITION OF REGISTERS, <IMP STRINGS
AND <SCB RECORDS. (SEE ALSO ^APPENDIX ^D).
.S 2
^&^CALLING <IMP FROM <MACRO\&
 ^SO LONG AS THE STACK (REGISTER 17) IS LARGE ENOUGH FOR THE
<IMP PROCEDURES BEING CALLED, NO DIFFICULTIES SHOULD BE
ENCOUNTERED. <IMP WILL DESTROY THE LEFT HALF OF THE
STACK POINTER AND WILL NOT NECESSARILY PRESERVE ANY OF THE REGISTERS.
^IF THE REGISTERS NEED TO BE PRESERVED THEN THE MACRO PROGRAM MUST
LOOK AFTER IT, ALTHOUGH THERE ARE TWO ROUTINES IN THE <IMP SYSTEM LIBRARY
TO HELP.
 ^THESE ROUTINES ARE CALLED <SAVEACS AND <RESTORE AND WILL SAVE AND
RESTORE REGISTERS 2-17. ^REGISTERS 0 AND 1 ARE LEFT SO THAT RESULTS FROM
MAPS AND FUNCTIONS CAN BE RETURNED.
 ^IF <IMP <I/O IS REQUIRED, THEN THE ROUTINES <INITIO AND <INITHEAP MUST
BE CALLED FIRST, EITHER BY <MACRO OR <IMP AND THE HEAP MUST BE DECLARED
IN THE <IMP MODULE (SEE THE MEMORY MANAGEMENT SECTION).
.PAGE
.SUBTITLE ^SECTION 6: ^&^PROGRAM DEBUGGING\&
.INDEX <DDT
.INDEX DEBUGGING
.NF.NAP
    ^&<DDT\&
.AP.F
 ^THE STANDARD <DEC-10 DEBUGGING SYSTEM <DDT CAN BE USED IN THE NORMAL WAY.
^THE CODE CAN BE FOLLOWED WITH THE HELP OF <ALIST OR <RECODE LISTINGS
(SEE BELOW).
 ^THERE IS ALSO A SYSTEM ROUTINE <DDT WHICH TAKES A
<%NAME TYPE PARAMETER AND, WHEN ENCOUNTERED, WILL
ENTER <DDT WITH ALL THE REGISTERS UNCHANGED AND THE ARGUMENT ADDRESS SAVED IN
<DDARG. ^THE MAIN PROGRAM CAN BE RESUMED BY TYPING:-
.NAP;.NF;.S
      <DDCONT$G
.PAGE
.INDEX DEBUGGING
.INDEX </CROSS
   ^&</CROSS\&
.F.AP
 ^A CROSS REFERENCE LISTING FILE, USING THE COMPILER'S OWN CROSS REFERENCE
LISTER, IS OBTAINED BY INCLUDING THE </CROSS SWITCH IN THE COMPILER
COMMAND STRING. ^THE OUTPUT ALLOWS ONE TO TRACE THE USE OF LOCAL AND GLOBAL
VARIABLES IN PROCEDURES AND AT DIFFERENT CONTEXTUAL LEVELS.
.NF.NAP.PAGE
.INDEX DEBUGGING
.INDEX <ALIST
.INDEX <RECODE
    ^&<ALIST\&
.AP.F
 <ALIST IS A PROGRAM ON THE SYSTEM AREA WHICH TAKES AN <IMP SOURCE
FILE AND THE CORRESPONDING  OBJECT FILE AND PRODUCES A LISTING FILE WHICH CONTAINS,
ALONG WITH THE LINE-NUMBERED SOURCE, THE RELATIVE ADDRESSES
OF THE CODE GENERATED FOR EACH SOURCE LINE.
^AN EXAMPLE OF <ALIST OUTPUT IS SHOWN AT THE END OF THIS SECTION.
.S 2
    ^&<RECODE\&
.AP.F
 ^RECODE IS A PROGRAM RESIDING ON THE SYSTEM AREA WHICH TAKES AN <IMP
SOURCE FILE AND THE CORRESPONDING OBJECT FILE AND PRODUCES A LISTING FILE
WHICH CONTAINS ALONG WITH THE LINE-NUMBERED SOURCE, THE CODE WHICH THE
COMPILER HAS GENERATED FOR EVERY LINE.
^AN EXAMPLE OF <RECODE OUTPUT IS SHOWN OVERLEAF.
.NAP;.S;.TS 6, 15;.NF
    ^&^THE COMMAND FORMAT FOR BOTH <ALIST AND <RECODE\&
.AP.F.S
^BOTH PROGRAMS PROMPT WITH 
.NAP.NF
	*
TO WHICH THE RESPONSE IS
.NAP.NF.S
	* _<LIST-FILESPEC_> = _<SOURCE-FILESPEC_> , _<REL-FILESPEC_>
OR	* _<LIST-FILESPEC_> = _<SOURCE-FILESPEC_>
OR	* _<SOURCE-FILESPEC_>
.S
WHERE THE MISSING ARGUMENTS ARE REPLACED BY THE FOLLOWING
.S
	LIST-FILESPEC   - <DSK: FILENAME <.LST [USER]
	REL-FILESPEC    - <DSK: FILENAME <.REL [USER]
	SOURCE-FILESPEC - <DSK: FILENAME <.IMP [USER]
.AP;.F
 ^IN ADDITION TO THIS <RECODE REQUIRES A RANGE OF LINES FOR WHICH RECODING
IS REQUIRED. ^THE PROMPTS FOR THIS ARE:-
.NAP;.NF;.S
	^FROM: N
	^TO:   M
.AP;.F
THIS MAY BE REPEATED A NUMBER OF TIMES. ^A RESPONSE OF ZERO CLOSES THE
OUTPUT AND RETURNS TO MONITOR LEVEL.
.PAGE
.INDEX DEBUGGING
.INDEX <ALIST EXAMPLE
.NF.NAP.C
^&^AN EXAMPLE OF <ALIST OUTPUT\&
.S.LIT
    1 400016 %BEGIN;   !A PROGRAM TO OUTPUT A FILE ONTO THE TERMINAL
    2        
    3           %CONSTINTEGER IN=1;     !STREAM NUMBER
    4           %INTEGER SYM;          !AN INTEGER TO READ CHARACTERS INTO
    5        
    6 400022    %ON %EVENT 9 %START;   !TRAP WHEN END-OF-FILE ENCOUNTERED ON INPUT
    7 400023       CLOSE INPUT;        !CLOSE THE INPUT FILE
    8 400024       %STOP;              !AND FINISH PROGRAM EXECUTION
    9           %FINISH
   10        
   11 400027    DEFINE INPUT(IN,"FILE.TXT"); !OPEN INPUT FILE
   12 400032    SELECT INPUT(IN);              !SET TO READ FROM FILE
   13        
   14           %CYCLE;                 !MAIN PROGRAM LOOP
   15 400034       READ SYMBOL(SYM);    !READ A CHARACTER FROM THE FILE
   16 400036       PRINT SYMBOL(SYM);   !OUTPUT CHARACTER TO TERMINAL
   17 400040    %REPEAT;                !CONTINUE UNTIL END-OF-FILE EVENT 
   18 400004 %ENDOFPROGRAM

.END LITERAL
.PAGE
.INDEX DEBUGGING
.INDEX <RECODE
.NF.NAP.C
^&^AN EXAMPLE OF <RECODE OUTPUT\&
.S.LIT
   1 %BEGIN;   !A PROGRAM TO OUTPUT A FILE ONTO THE TERMINAL
      400016  202717 000001  MOVEM  13,      1(17)
      400017  200700 000017  MOVE   13,     17
      400020  271740 000003  ADDI   17,      3
      400021  417017 000006  SETMM   0,      6(17)
   2 
   3    %CONSTINTEGER IN=1;     !STREAM NUMBER
   4    %INTEGER SYM;          !AN INTEGER TO READ CHARACTERS INTO
   5 
   6    %ON %EVENT 9 %START;   !TRAP WHEN END-OF-FILE ENCOUNTERED ON INPUT
      400022  254000 400027  JRST    0, 400027
      400014  400041 400027  SETZ    1, 400027(1)
      400015  001000 400023  USER    0, 400023
   7       CLOSE INPUT;        !CLOSE THE INPUT FILE
      400023  260740 000000  PUSHJ  17,      0
   8       %STOP;              !AND FINISH PROGRAM EXECUTION
      400024  403200 000005  SETZB  14,     15
      400025  400300 000000  SETZ   16,      0
      400026  265140 000000  JSP     3,      0
   9    %FINISH
  10 
  11    DEFINE INPUT(IN,"FILE.TXT"); !OPEN INPUT FILE
      400027  201040 000001  MOVEI   1,      1
      400030  551300 000001  HRRZI  16,      1
      400031  260740 400107  PUSHJ  17, 400107
  12    SELECT INPUT(IN);              !SET TO READ FROM FILE
      400032  551300 000001  HRRZI  16,      1
      400033  260740 400136  PUSHJ  17, 400136
  13 
  14    %CYCLE;                 !MAIN PROGRAM LOOP
  15       READ SYMBOL(SYM);    !READ A CHARACTER FROM THE FILE
      400034  201316 000002  MOVEI  16,      2(16)
      400035  260740 000000  PUSHJ  17,      0
  16       PRINT SYMBOL(SYM);   !OUTPUT CHARACTER TO TERMINAL
      400036  200316 000002  MOVE   16,      2(16)
      400037  260740 000000  PUSHJ  17,      0
  17    %REPEAT;                !CONTINUE UNTIL END-OF-FILE EVENT 
      400040  254000 400034  JRST    0, 400034
  18 %ENDOFPROGRAM
      400004  000000 400013
      400013  000000 400163
      400005  000000 000000
      400163  000000 400165
      400041  000000 000000
      400165  000000 400167
      400164  000000 000000
      400167  000000 400171
      400166  000000 000000
      400171  000000 400173
      400170  000000 000000
      400173  000000 000000
      400172  000000 000000
.END LITERAL
.SUBTITLE                              ^&^APPENDIX ^A\&
.PAGE;.NAP;.NF
.INDEX CHARACTER CONSTANTS
.INDEX CONSTANTS
.INDEX MONITOR LOCATIONS
.TS 6
^&^USEFUL CONSTANTS AND VARIABLES.\&
.S
^CHARACTERS:-
	<NL  -  NEWLINE CHARACTER
	<SP  -  SPACE CHARACTER
	<TAB -  TAB CHARACTER
	<FF  -  FORM-FEED CHARACTER
	<ESC -  ESCAPE CHARACTER

MONITOR LOCATIONS:-
	<AC(0:8__17)         - REGISTERS
	<VERSION            - <DEC-10 FORMAT ^VERSION NUMBER
	<JOBDAT(8__40:8__140) - ^JOB ^DATA AREA
.SUBTITLE                              ^&<APPENDIX ^B\&
.PAGE.NAP.NF
.INDEX <FILESPEC RECORDS
.INDEX FILE SPECIFICATIONS
.INDEX FILE SWITCHES
.INDEX SWITCHES
.FLAG CAP
^&^DEFINITION OF THE FILE SPECIFICATION RECORD\&
.S 1
<%RECORDFORMAT <FILESPEC( %^C
   <%STRING(6) <DEV,      - ^DEVICE NAME
   <%STRING(6) <FILE,     - ^FILE NAME
   <%STRING(3) <EXT,      - ^FILE EXTENSION
   <%INTEGER <PPN,        - ^PROJECT-PROGRAMMER PAIR
   <%STRING(6)%ARRAY <SFDS(1:MAX <SFDS),
                        - ^LIST OF SUB-FILE DIRECTORIES
   <%INTEGER <PROT,       - 3 OCTAL DIGIT PROTECTION CODE
   <%STRING(20) <SWITCHES)- ^STRING OF SWITCHES
.S 1
^SWITCHES RECOGNISED BY THE <DEC-10 SYSTEM LIBRARY ARE:-
.F
.LM19.TS 19.S.I-15
   </ALLOCATE: N	^ALLOCATE 'N' CONTIGUOUS BLOCKS WHEN CREATING A FILE
.I-15
   </BLOCKSIZE:#N	^SET BLOCKSIZE FOR A DEVICE
.I-15
   </BUFFERS: #N	^USE 'N' BUFFERS IN THE BUFFER RING
.I-15
   </BYTE: ####N	^SET THE BYTE SIZE FOR READING/WRITING
.I-15
   </DENSITY: #N	^SET DENSITY FOR MAGNETIC TAPE
( 200, 556, 800 OR 1600 BPI )
.I-15
   </ESTIMATE: N	^SET ASIDE 'N' BLOCKS WHEN CREATING A FILE
.I-15
   </EXTEND: ##N	^USE AN EXTENDED ^LOOKUP/^ENTER BLOCK
WHERE 'N' IS OMMITTED 35 OCTAL IS ASSUMED
.I-15
   </FUNCTION: N	^THE APPROPRIATE <FILOP FUNCTION IS USED
.I-15
   </MODE: ####N	^SET THE MODE TO BE THIS (THE STATUS WORD)
.I-15
   </PARITY: ##N	^SET PARITY FOR MAGNETIC TAPES: 0 = EVEN, 1 = ODD
.I-15
   </TRMOP	^USE <TRMOP <UUO FOR TERMINAL <I/O
.I-15
   </VERSION: #N	^VERSION NUMBER INTERPRETED IN <DEC <.JBVER FORMAT
(SEE ^^DEC\\SYSTEM 10 ^MONITOR ^CALLS ^MANUAL)
.LM 0.F
^SWITCHES CAN BE ABREVIATED TO THE SHORTEST UNIQUE STRING.
^NUMBERS CAN BE SPECIFIED AS OCTAL IF PRECEDED BY A HASH SIGN.
.NF.S
E.G.    </BL:_#203   - SET THE BLOCKSIZE TO OCTAL 203
.SUBTITLE                              ^^^&APPENDIX C\\\&
.PAGE
.INDEX <SCB RECORD DEFINITION
.INDEX INPUT/OUTPUT INTERNAL RECORDS
.NAP.NF
^&^DEFINITION OF THE INTERNAL INPUT/OUTPUT RECORDS\&
.S
^&^DEFINITION OF STREAM CONTROL BLOCKS\&
.F.S
^THE STREAM CONTROL BLOCKS FOR ALL THE STREAMS ARE POINTED
TO BY THE FOLLOWING ARRAYS:-
.NF.S
^^%EXTERNALRECORD(SCBNAME)%ARRAY INVEC(0:15)
%EXTERNALRECORD(SCBNAME)%ARRAY OUTVEC(0:15)\\
.F.S
WHERE THE RECORD <SCBNAME IS DEFINED:-
.NF
^^%RECORDFORMAT SCBNAME(%RECORD(SCB)%NAME NAME)\\
.S
AND THE CURRENT ^^SCB\\S ARE POINTED TO BY
.NF.S
^^%EXTERNALRECORD(SCB)%NAME INSCB
%EXTERNALRECORD(SCB)%NAME OUTSCB\\
.S.F
^AND FOR <DA/SQ CHANNELS THEY ARE POINTED TO BY THE ARRAY:-
.NF.S
^^%EXTERNALRECORD(SCBNAME)%ARRAY DASQVEC(1:15)\\
.S.F
WHERE THE FORMAT OF THE <SCB IS AS FOLLOWS:-
.NF.S
<%RECORD <%FORMAT <SCB(   <%C
    <%INTEGER <DEVTYP    - ^DEVICE TYPE, WHERE
                         (-3=STRING, -2=TMPCOR, -1=NUL:
                         AND >=0 IS DEFINED IN '<DEVTYP' <UUO)
                         IS DEFINED IN '<DEVTYP' <UUO)
    <%INTEGER <CHNTYP    - ^STREAM OR CHANNEL TYPE. ^WHERE
                         (0=STREAM, 1=<DA FILE, 2=<SQ FILE)
    <%INTEGER <NXTCHR    - ^THE NEXT CHARACTER FOR INPUT
    <%INTEGERNAME <OPER  - ^ADDRESS OF READ OR WRITE ROUTINE
    <%INTEGER <FLAGS     - ^FLAGS (BIT0=ZERO AS NEXT SYMBOL)
    <%INTEGER <RESERVED  - ^RESERVED
    <%STRING(3) <TMPNAME - ^NAME OF A TMPCOR FILE.
    <%INTEGER <UDX       - ^UNIVERSAL ^DEVICE ^INDEX
    <%INTEGER <FILOPFN   - ^FIRST WORD OF A FILOP TYPE RECORD
                         PHYSICAL CHANNEL NUMBER IN LH
                         AND FILOP FUNCTION CODE IN RH
    <%INTEGER <STATUS    - ^FIRST WORD OF AN OPEN BLOCK
                         IS STATUS WORD, INCLUDING <I/O MODE
    <%INTEGER <DEVNAM    - ^SIXBIT DEVICE NAME
    <%INTEGER <BUFHEDS   - ^ADDRESSES OF BUFFER RING HEADERS
                         OUTPUT<(LH) AND INPUT<(RH)
    <%INTEGER <BUFNUM    - ^NUMBER OF BUFFERS IN RING
                         OUTPUT<(LH) AND INPUT<(RH)
    <%RECORD(LOOKUPBLOCK)%NAME <LKENT
                       - ^ADDRESS OF LOOKUP-ENTER BLOCK
    <%INTEGER <PATHARG   - ^PATH BLOCK POINTER
                         LENGTH<(LH) AND ADDRESS<(RH)
    <%RECORD(RINGHEADER) <RINGHEAD
                       - ^BUFFER RING HEADER
    <%INTEGER <IBUFOP    - <IN <CHAN,0
    <%INTEGER <OBUFOP    - <OUT <CHAN,0
    <%INTEGER <USETI     - <USETI <CHAN,0
    <%INTEGER <USETO     - <USETO <CHAN,0
    <%INTEGER <STATZ     - <STATZ <CHAN,740000
    <%INTEGER <BLOCKSIZE - ^SIZE OF THE DEVICE BLOCKS
    <%RECORD(PATHBLOCK) <PATHBLK )
                       - ^PATH BLOCK
.S
^AND FOR TELETYPES
.S
<%RECORD <%FORMAT <TTSCB(   <%C
    <%INTEGER <DEVTYP    - !
    <%INTEGER <CHNTYP    - !
    <%INTEGER <NXTCHR    - !    SAME AS IN <SCB
    <%INTEGERNAME <OPER  - !
    <%INTEGER <FLAGS     - ^FLAG WORD
    <%INTEGER <ARGPTR    - ^POINTER TO <TRMOP ARG BLOCK
    <%INTEGER <FUNCT     - ^FIRST WORD OF ARG BLOCK -
                         (FUNCTION CODE)
    <%INTEGER <UDX       - ^UNIVERSAL ^DEVICE ^INDEX
    <%INTEGER <OUTARG)   - ^NEXT CHAR FOR OUTPUT
.S
^AND FOR STRINGS
.S
<%RECORD <%FORMAT <STRSCB(   <%C
    <%INTEGER <DEVTYP    - !
    <%INTEGER <CHNTYP    - !
    <%INTEGER <NXTCHR    - !    SAME AS IN <SCB
    <%INTEGERNAME <OPER  - !
    <%INTEGER <LENGTH    - ^STRING LENGTH
    <%INTEGER <LENPTR    - ^POINTER TO LENGTH BYTE
    <%INTEGER <POINTER)  - ^POINTER TO CURRENT BYTE
.S
^WHERE THE OTHER RECORDS ARE DEFINED AS FOLLOWS.
.S 2
<%RECORDFORMAT <OPENBLOCK(  <%C
   <%INTEGER <STATUS,    - ^STATUS INCLUDING <I/O MODE
   <%INTEGER <DEVNAM,    - ^SIXBIT DEVICE NAME
   <%INTEGER <BUFHEDS)   - ^ADDRESSES OF BUFFERS
                         OUTPUT<(LH) AND INPUT<(RH)
.S
^THIS RECORD CAN BE MAPPED ONTO THE <SCB AT <SCB__STATUS
.S2
<%RECORDFORMAT <LOOKUPBLOCK( <%C
   <%INTEGER <CNT,       - ^LENGTH OF FOLLOWING BLOCK
                         (DEFAULT=4)
   <%INTEGER <PPN)       - ^PROJECT-PROGRAMMER NUMBER
   <%INTEGER <NAM,       - ^SIXBIT FILE NAME
   <%INTEGER <EXT,       - ^SIXBIT EXTENSION<(LH)
   <%INTEGER <PRV,       - ^DATE-TIME AND PROTECTION
.F
^THE FOLLOWING RECORD ITEMS ARE ONLY USED WHEN THE ^^/EXTEND:\\N SWITCH IS
GIVEN. ^THEY ARE NAMED ACCORDING TO THE <DEC-10 EXTENDED LOOKUP-BLOCK
CONVENTIONS (SEE <DEC-10 <MONITOR <CALLS <MANUAL).
.NF
   <%INTEGER <SIZ, <VER, <SPL, <EST, <ALC, <POS, <TF1, <NCA, <MTA,
   <DEV, <STS, <ELB, <EUN, <QTF, <QTO, <USD, <AUT, <PCA, <UFD, <FLR,
   <XRA, <TIM)
.S2
<%RECORDFORMAT <RINGHEADER( <%C
   <%INTEGER <BUFADR,    - ^ADDRESS OF CURRENT BUFFER
   <%INTEGER <BYTPTR,    - ^POINTER TO CURRENT BYTE
   <%INTEGER <BYTCNT,    - ^BYTE COUNT
   <%INTEGER <MPXUDX)    - ^UNIVERSAL DEVICE INDEX FOR <MPX
.S2
<%RECORDFORMAT <PATHBLOCK( <%C
   <%INTEGER <FUNCT,     - ^REQUIRED FUNCTION
   <%INTEGER <SWITCHES,  - ^SCAN SWITCHES
   <%INTEGER <PPN,       - ^PROJECT-PROGRAMMER NUMBER
   <%INTEGERARRAY <SFDS(1:MAXSFDS)) - ^SIXBIT <SFD NAMES
.S 2
<%RECORDFORMAT <FILOPBLOCK( <%C
   <%INTEGER <FUNCT,     - ^PHYSICAL CHANNEL NUMBER<(LH)
                         AND FUNCTION CODE<(RH)
   <%INTEGER <STATUS,    - ^STATUS WORD, INCLUDING <I/O MODE
   <%INTEGER <DEVNAM,    - ^SIXBIT DEVICE NAME
   <%INTEGER <BUFHEDS,   - ^ADDRESSES OF BUFFER RING HEADERS
                         OUTPUT<(LH) AND INPUT<(RH)
   <%INTEGER <BUFNUM,    - ^NUMBER OF BUFFERS IN EACH
                         OUTPUT<(LH) AND INPUT<(RH)
   <%RECORD(LOOKUPBLOCK)%NAME <LKENT,
                       - ^LOOKUP-ENTER BLOCK ADDRESS
   <%INTEGER <PATHARG)   - ^PATH BLOCK POINTER
                         LENGTH<(LH) AND ADDRESS<(RH)
.S
^THIS RECORD CAN BE MAPPED ONTO THE <SCB AT <SCB__FILOPFN
.INDEX INPUT/OUTPUT INTERNAL RECORDS
.SUBTITLE                              ^^^&APPENDIX D\\\&
.PAGE
.INDEX DATA STORAGE
.INDEX <%BYTE STORAGE
.INDEX <%SHORT %<INTEGER STORAGE
.INDEX <%INTEGER STORAGE
.INDEX <%REAL STORAGE
.INDEX <%LONG %<REAL STORAGE
.INDEX %<STRING STORAGE
.INDEX <%RECORD STORAGE
^&^DATA STORAGE\&
.F.NAP.S
%<BYTE %<INTEGER VARIABLES OCCUPY 9-BIT BYTES AND ARE PACKED LEFT TO RIGHT 4 TO A WORD
.S
%<STRING VARIABLES COMPRISE 7-BIT BYTES AND ARE PACKED LEFT TO RIGHT 5 TO A WORD, WITH
THE FIRST TWO BYTES BEING ALIGNED ON A WORD BOUNDARY AND CONTAINING THE STRING LENGTH. (MAXIMUM 255)
.S
%<SHORT %<INTEGER VARIABLES OCCUPY 18 BITS OR HALF A ^^DEC\\SYSTEM-10/20 WORD
.S
%<INTEGER AND %<REAL VARIABLES OCCUPY 36 BITS OR
ONE ^^DEC\\SYSTEM-10/20 WORD, GIVING A RANGE OF VALUES OF
-34,359,738,367  TO +34,359,738,367 FOR INTEGERS AND
1.4@-39 TO 1.7@38 TO AN SIGNIFICANCE OF APPROXIMATELY EIGHT AND
ONE-HALF DECIMAL DIGITS FOR REALS.
.S
%<LONG %<REAL VARIABLES OCCUPY 72 BITS OR TWO ^^DEC\\SYSTEM-10/20 WORDS
AND EXTEND THE PRECISION OF REAL REPRESENTATION TO ABOUT SEVENTEEN DECIMAL DIGITS.
.S
%<RECORD VARIABLES OCCUPY AS MUCH SPACE AS THEIR COMPONENT
ITEMS, ALLOWING FOR NECCESSARY WORD ALLIGNMENT OF %<BYTE AND <%SHORT
%<INTEGER VARIABLES. ^THERE IS NO RECORD HEADER WORD.
.S
%<NAME VARIABLES OCCUPY A SINGLE ^^DEC\\SYSTEM-10/20 WORD. ^THEY
ARE POINTERS TO DIFFERENT TYPES OF OBJECTS. ^THE RIGHT HALF OF THE WORD
CONTAINS THE ADDRESS OF THE OBJECT. ^THE LEFT HALF CONTAINS THE TYPE OF OBJECT AND
ITS LENGTH AS A NUMBER OF ^^DEC\\SYSTEM-10/20 WORDS (RELEVANT
FOR RECORDS AND STRINGS)
.NF.S
BITS 0-8 CONTAIN THE LENGTH OF THE OBJECT (MAXIMUM=255)
.S
BITS 9-12 CONTAIN THE OBJECT TYPE, WHERE:-
   1 = %<INTEGER
   2 = %<SHORT %<INTEGER
   3 = %<BYTE %<INTEGER
   4 = %<STRING
   5 = %<RECORD
   6 = %<REAL
   7 = %<LONG %<REAL
.F
.PAG
^&^CODE CONVENTIONS\&
.INDEX CODE CONVENTIONS
.INDEX REGISTER ALLOCATION
.S 2
^&^REGISTER ALLOCATION\&
.TS 6.NF.S 1
	17	- PROCEDURE AND DATA STACK POINTER
	16	- FIRST PARAMETER
	15	- SECOND PARAMETER
	14	- THIRD PARAMETER
	13	-!
	12	-!
	11	-! - BASE REGISTERS
	10	-!
	#7	-!
	#6	- GENERAL PURPOSE
	#5	- GENERAL PURPOSE
	#4	- GENERAL PURPOSE
	#3	- GENERAL PURPOSE
	#2	- GENERAL PURPOSE
	#1	- <%RESULT REGISTER FROM <%^^MAP\\S
	#0	- <%RESULT REGISTER FROM %^^FUNCTION\\S
.S
.AP;.F
 ^REGISTERS 0-6 AND 14-16 CAN BE REGARDED AS FREE FOR USE IN MACHINE
CODE INSTRUCTIONS AND PROCEDURES.
.S 2
.INDEX PROCEDURE ENTRY AND EXIT
^&^PROCEDURE ENTRY AND EXIT\&
 ^THE NORMAL ENTRY AND EXIT SEQUENCE IS SHOWN BELOW, FOR A ROUTINE
WITH NO PARAMETERS. ^THE ROUTINE WOULD BE CALLED BY THE INSTRUCTION
.NF
    ^^PUSHJ   P,\\ROUTINE
.S
ENTRY SEQUENCE:-
.NAP.UC
    MOVEM  BASE1,1(P)  ;STORE PREVIOUS BASE REGISTER VALUE
    MOVE   BASE1,P     ;AND LOAD THE NEW BASE ADDRESS
    ADDI       P,'N'   ;MOVE POINTER OVER LOCAL STORAGE
    SETMM      0,6(P)  ;DO A TEST WRITE TO TOP OF STACK
                       ;THIS WILL TRAP TO CORE MANAGEMENT
                     ;SYSTEM IF BEYOND TOP OF CURRENT CORE
.S.LC
THEN THE ROUTINE BODY, FOLLOWED BY THE EXIT SEQUENCE:-
.UC.S
    MOVE      P,BASE1  ;GET CURRENT STACK BASE
    MOVE  BASE1,1(P)   ;RESTORE PREVIOUS STACK BASE
    POPJ      P,       ;RETURN
.AP.F.LC.S
^WHENEVER POSSIBLE THIS SEQUENCE WILL BE OPTIMISED,
FOR INSTANCE WHEN THERE ARE NO LOCAL VARIABLES AND SIMPLE OR NO
PARAMETERS. ^OVERLEAF IS THE <IMPLICIT ROUTINE <NEWLINE, TOGETHER
WITH CODE PRODUCED FOR IT.
.PAGE
.LITERAL
%EXTERNALROUTINE NEWLINE
   PRINTSYMBOL(NL)
%END

gives the following code:-

   HRRZI  ARG1,12      ;LOAD ARGUMENT WITH NEWLINE SYMBOL
   JRST   PRINTSYMBOL  ;AND JUMP TO ROUTINE, WHICH WILL DO
                       ; THE 'POPJ' RETURN
.END LITERAL
.S
.INDEX PARAMETERS TO PROCEDURES
^&^PARAMETERS TO PROCEDURES\&
.AP;.F
 ^ON ENTRY TO A PROCEDURE, ANY PARAMETERS HAVE BEEN STORED ON THE STACK
AT THE LOCATIONS 2(^P) UPWARDS. ^AS WE HAVE SEEN THE PREVIOUS STACK BASE ADDRESS IS
STORED AT 1(^P) AND THE RETURN ADDRESS AT 0(^P).
 ^HOWEVER THE FIRST THREE PARAMETERS, IF THEY HAVE ONE WORD
VALUES (E.G. INTEGERS, REALS AND ALL
NAME TYPE PARAMETERS), ARE PASSED IN THE THREE REGISTERS SHOWN ABOVE,
AND ARE STORED, IF NECESSARY, BY THE PROCEDURE ITSELF. ^SIMILARLY IF
THE FINAL PARAMETER IS A STRING VALUE, THE ADDRESS OF THE STRING IS
PASSED IN REGISTER 1.
 ^THE BASE REGISTERS AND STACK POINTER MUST BE PRESERVED ON RETURN FROM
THE PROCEDURE. ^THE ACTUAL BASE REGISTER USED BY THE PROCEDURE
DEPENDS ON IT'S CONTEXTUAL LEVEL, THERE BEING FIVE POSSIBLE
LEVELS.
^OVERLEAF IS AN EXAMPLE OF THE CODE PRODUCED FOR A COMPLICATED PROCEDURE CALL.
.PAGE
.LITERAL
%BEGIN
%RECORDFORMAT INTS(%INTEGER I1,I2)
%RECORD(INTS) R1
%INTEGER VAR

   %ROUTINE TEST(%INTEGER N,M %RECORD(INTS) R %STRING(255) S)
      %INTEGER A1,A2,A3
      A1=N
   %END

   TEST(1,VAR,R1,"TESTING")
%ENDOFPROGRAM

.END LITERAL
PRODUCES THE CODE:-
.LITERAL

%BEGIN
          MOVEM  BASE1,1(P)       ;SAVE OLD STACK BASE
          MOVE   BASE1,P          ;GET NEW BASE
          ADDI       P,5          ;MOVE STACK POINTER PAST LOCALS
          SETMM      0,6(P)       ;CHECK FOR TOP OF CORE
%RECORDFORMAT INTS(%INTEGER I1,I2)
%RECORD(INTS) R1
%INTEGER VAR

   %ROUTINE TEST(%INTEGER N,M %RECORD(INTS) R %STRING(255) S)
          MOVEM  BASE2,1(P)       ;SAVE OLD STACK BASE
          MOVE   BASE2,P          ;GET NEW BASE ADDRESS
          ADDI       P,111        ;MOVE PAST LOCAL STORAGE
          SETMM      0,6(P)       ;CHECK FOR TOP OF CORE
          MOVEM   ARG1,2(BASE2)   ;SAVE FIRST ARGUMENT - "N"
          MOVEM   ARG2,3(BASE2)   ;SAVE SECOND ARGUMENT - "M"
          MOVEI     P1,6(BASE2)   ;GET ADDRESS FOR WHICH STRING
          JSP        J,.$MOVE     ;AND MOVE IT FROM REGISTER 1
       %INTEGER A1,A2,A3
       A1=N
          MOVEM   ARG1,106(BASE2) ;MOVE "N" TO FIRST FREE LOCATION
                                  ;ON STACK, "A1" (AFTER THE STRING)
    %END
          MOVE       P,BASE2      ;GET OLD STACK BASE
          MOVE   BASE2,1(P)       ;RESTORE PREVIOUS VALUE
          POPJ       P,0          ;RETURN
    TEST(1,VAR,R1,"TESTING")
          HRRZI     T2,5(P)       ;DESTINATION ADDRESS FOR "R1"
          HRLZI     T1,3(BASE1)   ;AND WHERE IT IS AT PRESENT
          HRR       T1,T2         ;SET UP "BLT" POINTER
          BLT       T1,1(T2)      ;AND DO THE BLOCK TRANSFER
          MOVEI      1,T1         ;GET THE ADDRESS OF "S"
          MOVE    ARG2,2(BASE1)   ;GET THE VALUE OF "VAR"
          HRRZI   ARG1,1          ;GET THE VALUE "1"
          PUSHJ      P,TEST       ;AND CALL THE ROUTINE
%ENDOFPROGRAM
          MOVE       P,BASE1      ;GET THE BASE ADDRESS
          MOVE   BASE1,1(P)       ;RESTORE THE PREVIOUS VALUE
          POPJ       P,0          ;RETURN TO RUNTIME SYSTEM
.END LITERAL
.TEST PAGE 6.S 2
THE STACK AT THE TIME OF THE RETURN FROM THE ROUTINE <TEST LOOKS AS FOLLOWS:-
.LITERAL

BASE2-> | return address |  0 (relative addresses)
        | old stack base |  1
        |    N           |  2
        |    M           |  3
        |  R_I1          |  4
        |  R_I2          |  5
        |  string        |  6
        |    S           |  .
        |    .           |  .
        |    .           |  .
        |    A1          | 106
        |    A2          | 107
        |    A3          | 110
    P-> |                | 111
.END LITERAL
.S 2
.INDEX PROCEDURE PARAMETERS
^&^PROCEDURE PARAMETERS\&
.S
 ^THIS PARAMETER TYPE IS PASSED AS THE ADDRESS OF AN ARGUMENT BLOCK ON THE STACK
WHICH CONTAINS THE ADDRESS OF THE PROCEDURE AND THE FUTURE CONTEXT FOR THAT
PROCEDURE (I.E. THE STACK BASE REGISTERS). ^WHEN THE PROCEDURE IS CALLED,
THE CURRENT CONTEXT IS EXCHANGED FOR THE CONTEXT IN THE ARGUMENT BLOCK
BEFORE THE PROCEDURE IS ENTERED. ^UPON RETURN, THE CONTEXTS ARE EXCHANGED
BACK BEFORE CONTROL IS RETURNED.
 ^THE ARGUMENT BLOCK WHICH IS SET UP LOOKS LIKE THIS:-
.LITERAL

 | procedure entry address  | 0 (relative addresses)
 | return address to caller | 1
 |  base1                   | 2
 |  base2                   | 3
 |  base3                   | 4
 |  base4                   | 5
 |  base5                   | 6

.END LITERAL
.PAGE
.INDEX MACHINE CODE BLOCKS
^&^USE OF MACHINE CODE\&
.S
 ^BLOCKS OF MACHINE CODE CAN BE PLANTED IN-LINE IN A PROGRAM BY
PRECEDING THE OCTAL INSTRUCTIONS WITH AN ASTERISK. ^SPACES ARE NOT SIGNIFICANT
AND CAN BE USED TO SEPARATE FIELDS.
.NF.NAP.S
E.G.
.S
THE FOLLOWING CODE PERFORMS THE IMP FUNCTION
   ANSWER = REM(NUMBER,10)*12
.S
   AC(1)=NUMBER
   *8__231040 000012;   !IDIVI 1,_^<D10   REMAINDER IN AC(2)
   *8__221100 000014;   !IMULI 2,_^<D12
   ANSWER=AC(2)
.SUBTITLE                              ^^^&APPENDIX E\\\&
.PAGE
.INDEX <ASCII CHARACTER SET
.TS 8,15,23,29,38,43,52
.FLAG CAP.LC.NAP.NF
^&<ASCII CHARACTER SET\&
.S
^^OCT DEC CHAR  OCT DEC  CHAR  OCT DEC CHAR  OCT DEC  CHAR\\
.S
 0  0	<NUL	40 32	<SPACE	100 64	@	140  96	grave
 1  1	<SOH	41 33	!	101 65	^A	141  97	a
 2  2	<STX	42 34	"	102 66	^B	142  98	b
 3  3	<ETX	43 35	_#	103 67	^C	143  99	c
 4  4	<EOT	44 36	$	104 68	^D	144 100	d
 5  5	<ENQ	45 37	%	105 69	^E	145 101	e
 6  6	<ACK	46 38	_&	106 70	^F	146 102	f
 7  7	<BEL	47 39	'	107 71	^G	147 103	g
.S
10  8	<BS	50 40	(	110 72	^H	150 104	h
11  9	<HT	51 41	)	111 73	^I	151 105	i
12 10	<LF	52 42	*	112 74	^J	152 106	j
13 11	<VT	53 43	+	113 75	^K	153 107	k
14 12	<FF	54 44	,	114 76	^L	154 108	l
15 13	<CR	55 45	-	115 77	^M	155 109	m
16 14	<SO	56 46	.	116 78	^N	156 110	n
17 15	<SI	57 47	/	117 79	^O	157 111	o
.S
20 16	<DLE	60 48	0	120 80	^P	160 112	p
21 17	<DC1	61 49	1	121 81	^Q	161 113	q
22 18	<DC2	62 50	2	122 82	^R	162 114	r
23 19	<DC3	63 51	3	123 83	^S	163 115	s
24 20	<DC4	64 52	4	124 84	^T	164 116	t
25 21	<NAK	65 53	5	125 85	^U	165 117	u
26 22	<SYN	66 54	6	126 86	^V	166 118	v
27 23	<ETB	67 55	7	127 87	^W	167 119	w
.S
30 24	<CAN	70 56	8	130 88	^X	170 120	x
31 25	<EM	71 57	9	131 89	^Y	171 121	y
32 26	<SUB	72 58	:	132 90	^Z	172 122	z
33 27	<ESC	73 59	;	133 91	[	173 123	{
34 28	<FS	74 60	_<	134 92	_\	174 124	|
35 29	<GS	75 61	=	135 93	]	175 125	}
36 30	<RS	76 62	>	136 94	_^	176 126	~
37 31	<US	77 63	?	137 95	__	177 127	<DEL
.SUBTITLE                               ^^^&APPENDIX F\\\&
.PAGE
.INDEX LIBRARY PROCEDURES
.INDEX SYSTEM LIBRARY
.INDEX I/O PROCEDURES
.INDEX STREAMS
.INDEX FILE SYSTEM
.INDEX <DA FILES
.INDEX ^DIRECT ^ACCESS FILES
.INDEX ^SEQUENTIAL ^FILES
.NAP.UC.NF.TS 10,40
^&^RELATED LIBRARY PROCEDURES\&
.S
INPUT/OUTPUT PROCEDURES
.S
	INPUT	OUTPUT
	INPUT PENDING	NEWLINE
	NEXT ITEM	NEWLINES
	NEXT SYMBOL	NEWPAGE
	READ	PRINT
	READ HEX	PRINT FL
	READ ITEM	PRINT STRING
	READ OCTAL	PRINT SYMBOL
	READ STRING	PROMPT
	READ SYMBOL	REPORT
	READ TEXT	SPACE
	SKIP SYMBOL	SPACES
		WRITE
		WRITE HEX
		WRITE OCTAL
STREAM DEFINITION ROUTINES
.S
	CHECKPOINT
	CLOSE INPUT	CLOSE OUTPUT
	DEFINE INPUT	DEFINE OUTPUT
	INDEV	OUTDEV
	INSTATUS	OUTSTATUS
	INSTREAM	OUTSTREAM
	RESET INPUT	RESET OUTPUT
	SDEF INPUT	SDEF OUTPUT
	SELECT INPUT	SELECT OUTPUT
	USET INPUT	USET OUTPUT
	XDEFINE INPUT	XDEFINE OUTPUT
.S
FILE SYSTEM UTITLITIES
.S
	COPY	XCOPY
	CUSP FILES
	DEFAULT
	DELETE	XDELETE
	ECHO	NOECHO
	FSTOSTR	STRTOFS
	ISFILE	XISFILE
	JOBFILE
	READ FS	WRITE FS
	READ PPN	WRITE PPN
	RENAME	XRENAME
	SET STREAMS
.S
DIRECT ACCESS/SEQUENTIAL FILE ROUTINES
.S
	CLOSE DA	CLOSE SQ
	OPEN DA	OPEN SQ
	READ DA	READ SQ
	WRITE DA	WRITE SQ
	XOPEN DA	XOPEN SQ
.S
.INDEX TYPE CONVERSION
.INDEX ARITHMETIC
.INDEX JOB RELATED INFORMATION
TYPE CONVERSION PROCEDURES
.S
	INTTOSTR	STRTOINT
	HEXTOSTR	STRTOHEX
	OCTTOSTR	STRTOOCT
	BINTOSTR
	SIXTOSTR	STRTOSIX
	FSTOSTR	STRTOFS
.S
MAPS
.S
	BYTEINTEGER
	INTEGER
	REAL
	RECORD
	SHORTINTEGER
	STRING
.S
STRING PROCEDURES
.S
	CHARNO
	SUBSTRING
	LENGTH
	MATCH
	NEXT ITEM
	READ ITEM
	TO STRING
.S
ARITHMETIC
.S
	FLOAT
	FRAC PT
	IMOD
	INT
	INT PT
	MOD
	PI
	REM
	SHIFTC
.S
JOB RELATED INFORMATION
.S
	CPUTIME
	DAY
	DATE
	DATETIME
	JOBNUM
	PPN
	TIME
.FLAGS CAP
.SUBTITLE                              ^^^&APPENDIX G\\\&
.PAGE
.INDEX SYSTEM LIBRARY PROCEDURES
.LC.NAP.NOFILL;.TS 13,33
^&SYSTEM LIBRARY PROCEDURES\&
.S
NAME	CLASS TYPE	PARAMETERS
.S
<ACCPER	EXT %INTEGERFN	%INTEGER UDT
<ADDR	    %INTEGERFN	%NAME X
<ASCTOSTR	EXT %STRING(255)%FN	%NAME ADR
<BINTOSTR	EXT %STRING(36)%FN	%INTEGER NUM
<BLT	SYS %ROUTINE	%NAME FROM,TO %INTEGER LEN
<BYTEINTEGER	    %BYTEINTEGERMAP	%INTEGER ADR
<CALL(0-9)	EXT %ROUTINE	%NAME RTN, ...
<CALLI1	EXT %ROUTINE	%INTEGER N %INTEGERNAME AC
<CALLI2	EXT %PREDICATE	%INTEGER N %INTEGERNAME AC
<CALLI3	EXT %PREDICATE	%INTEGER N %INTEGERNAME AC
<CHARNO	    %BYTEINTEGERFN	%STRINGNAME S %INTEGER N
<CHECKPOINT	EXT %ROUTINE
<CLOSE	SYS %ROUTINE	%INTEGER CHAN
<CLOSE <DA	EXT %ROUTINE	%INTEGER CHAN
<CLOSE <INPUT	    %ROUTINE
<CLOSE <OUTPUT	    %ROUTINE
<CLOSE <SQ	EXT %ROUTINE	%INTEGER CHAN
<COPY	EXT %ROUTINE	%STRING(255) ORIG,NEW
<CPUTIME	EXT %INTEGERFN
<CUSP <FILES	EXT %ROUTINE	%RECORD(FILESPEC)%NAME R,S,
	    	T,U %INTEGER CHAN,
	    	%INTEGERNAME FOUND
<DATE	EXT %STRING(9)%FN
<DATETIME	EXT %STRING(18)%FN
<DATETOSTR	EXT %STRING(9)%FN	%INTEGER DATE
<DAY	EXT %STRING(9)%FN
<DAYTOSTR	EXT %STRING(9)%FN	%INTEGER UDT
<DDT	SYS %ROUTINE	%NAME X
<DECODE	EXT %ROUTINE	%INTEGER INST,ADR
<DEFAULT	EXT %ROUTINE	%RECORD(FILESPEC)%NAME F,F1
<DEFINE <INPUT	    %ROUTINE	%INTEGER N %STRING(255) S
^^DEFINE OUTPUT\\    %ROUTINE	%INTEGER N %STRING(255) S
<DELETE	EXT %ROUTINE	%STRING(255) SPEC
<ECHO	EXT %ROUTINE
<ENDOFPERIOD	EXT %INTEGERFN	%INTEGER PERIOD
<ESC	    %CONSTINTEGER
<EVENT	    %INTERGERFN
<EVENT <INFO	    %INTEGERFN
<FF	    %CONSTINTEGER
<FILOP	SYS %PREDICATE	%RECORD(SCB)%NAME R,
	    	%INTEGERNAME ERR
<FINIT	SYS %ROUTINE
<FLOAT	    %REALFN	%INTEGER N
<FRAC <PT	    %LONGREALFN	%LONGREAL A
<FREEVEC	SYS %ROUTINE	%INTEGER ADR,LEN
<FROMDATE	EXT %ROUTINE	%INTEGER DATE,
	    	%INTEGERNAME D,M,Y
<FROMTIME	EXT %ROUTINE	%INTEGER TIME,
	    	%INTEGERNAME H,M,S
<FROMUDT	EXT %ROUTINE	%INTEGER UDT,
	    	%INTEGERNAME DATE,TIME
<FSTOSTR	EXT %STRING(255)%FN	%RECORD(FILESPEC)%NAME FS
<GET <CHANNEL	SYS %INTEGERFN
<GETDATE	EXT %INTEGERFN
<GETNOW	EXT %INTEGERFN
<GETPAGES	SYS %ROUTINE	%INTEGER FIRST,LAST
<GETSEG	EXT %ROUTINE	%STRING(6) DEV,FILE,
	    	%STRING(3) EXT %INTEGER PPN
<GETSTS	SYS %INTEGERFN	%INTEGER CHAN
<GETTAB	SYS %PREDICATE	%INTEGER TABLE,INDEX,
	    	%INTEGERNAME RESULT
<GETTIME	EXT %INTEGERFN
<GETVEC	SYS %INTEGERFN	%INTEGER SIZE
<HEXTOSTR	EXT %STRING(9)%FN	%INTEGER N
<ICALL(0-9)	EXT %INTEGERFN	%NAME FN, ...
<IMOD	    %INTEGERFN	%INTEGER N
<INDEV	EXT %INTEGERFN
<INITFOR	SYS %ROUTINE
<INITHEAP	SYS %ROUTINE
<INITIO	SYS %ROUTINE
<INITSTACK	SYS %ROUTINE
<INPUT	SYS %ROUTINE
^^INPUT PENDING\\    %PREDICATE
<INSTATUS	EXT %INTEGERFN
<INSTREAM	    %INTEGERFN
<INT	    %INTEGERFN	%LONGREAL A
<INTEGER	    %INTEGERMAP	%INTEGER ADR
<INT <PT	    %INTEGERFN	%LONGREAL A
<INTTOSTR	EXT %STRING(12)%FN	%INTEGER N
<IOUUO	SYS %PREDICATE	%INTEGER FN,CHAN,
	    	%NAME ADR
<IOWD	SYS %INTEGERFN	%INTEGER LEN,
	    	%INTEGERNAME ADR
<ISFILE	EXT %PREDICATE	%STRING(255) SPEC
<JOBFILE	EXT %STRING(6)%FN	%STRING(3) S
<JOBNUM	EXT %INTEGERFN
<JSYS(0-4)	EXT %ROUTINE	%INTEGER N %INTEGERNAME ...
<LENGTH	    %BYTEINTEGERFN	%STRINGNAME S
<MATCH	EXT %INTEGERFN	%STRINGNAME SRC,
	    	%STRING(255) TARGET
<MOD	    %LONGREALFN	%LONGREAL A
<NEWLINE	    %ROUTINE
<NEWLINES	    %ROUTINE	%INTEGER N
<NEWPAGE	    %ROUTINE
<NEXT <ITEM	    %STRING(1)%FN
<NEXT <SYMBOL	    %INTEGERFN
<NL	    %INTEGERFN
<NOECHO	EXT %ROUTINE
<OCTTOSTR	EXT %STRING(12)%FN	%INTEGER N
<OPEN <DA	EXT %ROUTINE	%INTEGER CHAN,
	    	%STRING(255) SPEC
<OPEN <SQ	EXT %ROUTINE	%INTEGER CHAN,
	    	%STRING(255) SPEC
<OUTDEV	EXT %INTEGERFN
<OUTPUT	SYS %ROUTINE
<OUTSTATUS	EXT %INTEGERFN
<OUTSTREAM	    %INTEGERFN
<PI	    %CONSTLONGREAL
<PPN	EXT %INTEGERFN
<PRINT	    %ROUTINE	%LONGREAL A %INTEGER N,M
<PRINT <FL	    %ROUTINE	%LONGREAL A %INTEGER N
<PRINT <STRING	    %ROUTINE	%STRING(255) S
<PRINT <SYMBOL	    %ROUTINE	%INTEGER N
<PROMPT	EXT %ROUTINE	%STRING(255) S
<RAD50	EXT %INTEGERFN	%STRING(6) S
<RCALL(0-9)	EXT %REALFN	%NAME FN, ...
<READ	    %ROUTINE	%NAME A
<READ <DA	EXT %ROUTINE	%INTEGER CHAN,
	    	%INTEGERNAME BLOCK,
	    	%NAME START,END
<READ <FS	EXT %ROUTINE	%RECORD(FILESPEC)%NAME FS
<READ <HEX	EXT %ROUTINE	%INTEGERNAME N
<READ <ITEM	    %ROUTINE	%STRINGNAME S
<READ <OCTAL	EXT %ROUTINE	%INTEGERNAME N
<READ <PPN	EXT %ROUTINE	%INTEGERNAME PPN
<READ <SQ	EXT %ROUTINE	%INTEGER CHAN,
	    	%NAME START,END
<READ <STRING	    %ROUTINE	%STRINGNAME S
<READ <SYMBOL	    %ROUTINE	%NAME N
<READ <TEXT	    %ROUTINE	%STRINGNAME S,
	    	%INTEGER DELIM
<REAL	    %REALMAP	%INTEGER ADR
<RECORD	    %RECORDMAP	%INTEGER ADR
<RELEASE	SYS %ROUTINE	%INTEGER CHAN
<REM	    %INTEGERFN	%INTEGER N,M
<RENAME	EXT %ROUTINE	%STRING(255) ORIG,NEW
<REPORT	EXT %ROUTINE	%STRING(255) S
<RESET <INPUT	EXT %ROUTINE
<RESET <OUTPUT	EXT %ROUTINE
<RESTORE	EXT %ROUTINE
<RUN	EXT %ROUTINE	%STRING(6) DEV,FILE,
	    	%STRING(3) EXT,
	    	%INTEGER PPN,OFFSET
<SAVE <ACS	EXT %ROUTINE
<SDEF <INPUT	EXT %ROUTINE	%INTEGER N %STRINGNAME S
<SDEF <OUTPUT	EXT %ROUTINE	%INTEGER N %STRINGNAME S
<SELECT <INPUT	    %ROUTINE	%INTEGER N
<SELECT <OUTPUT    %ROUTINE	%INTEGER N
<SET <STREAMS	EXT %ROUTINE
<SETSTS	SYS %ROUTINE	%INTEGER CHAN,BITS
<SHIFTC	EXT %INTEGERFN	%INTEGER NUM,TIMES
<SHORTINTEGER	    %SHORTINTEGERMAP	%INTEGER ADR
<SKIP <SYMBOL	    %ROUTINE
<SLEEP	EXT %ROUTINE	%INTEGER N
<SP	    %CONSTINTEGER
<SPACE	    %ROUTINE
<SPACES	    %ROUTINE	%INTEGER N
^^STARTOFPERIOD\\EXT %INTEGERFN	%INTEGER PERIOD
<STRING	    %STRINGMAP	%INTEGER ADR
<STRTOASC	EXT %ROUTINE	%STRINGNAME S,
	    	%NAME ADR
<STRTOFS	EXT %RECORD(FILESPEC)%FN	%STRING(255) SPEC
<STRTOHEX	EXT %INTEGERFN	%STRINGNAME S
<STRTOINT	EXT %INTEGERFN	%STRINGNAME S
<STRTOOCT	EXT %INTEGERFN	%STRINGNAME S
<STRTOSIX	EXT %INTEGERFN	%STRING(6) S
<SUBEVENT	    %INTEGERFN
<SUB <STRING	    %STRING(255)%FN	%STRINGNAME S %INTEGER N,M
<SWITCH <ARG	EXT %PREDICATE	%STRING(255)%NAME S,
	    	%STRING(11) TARGET,
	    	%NAME ARG
<TAB	    %CONSTINTEGER
<TAPOP	SYS %PREDICATE	%INTEGER FUNCT,CHAN,NARGS,
	    	%INTEGERARRAYNAME ARGS,
	    	%INTEGERNAME RESULT
<TIME	EXT %STRING(8)%FN
<TIMETOSTR	EXT %STRING(8)%FN	%INTEGER TIME
<TMPCOR	SYS %ROUTINE	%INTEGER N,IOWD,FILE
<TODATE	EXT %INTEGERFN	%INTEGER D,M,Y
<TOSTRING	    %STRING(1)%FN	%INTEGER N
<TOTIME	EXT %INTEGERFN	%INTEGER H,M,S
<TOUDT	EXT %INTEGERFN	%INTEGER DATE,TIME
<UDTTOSTR	EXT %STRING(18)%FN	%INTEGER UDT
<USET <INPUT	EXT %ROUTINE	%INTEGER BLOCK
<USET <OUTPUT	EXT %ROUTINE	%INTEGER BLOCK
<WRITE	    %ROUTINE	%INTEGER N,M
<WRITE <DA	EXT %ROUTINE	%INTEGER CHAN,
	    	%INTEGERNAME BLOCK,
	    	%NAME START,END
<WRITE <FS	EXT %ROUTINE	%RECORD(FILESPEC)%NAME FS
<WRITE <HEX	EXT %ROUTINE	%INTEGER N,M
<WRITE <OCTAL	EXT %ROUTINE	%INTEGER N,M
<WRITE <PPN	EXT %ROUTINE	%INTEGER PPN
<WRITE <SQ	EXT %ROUTINE	%INTEGER CHAN,
	    	%NAME START,END
<XCOPY	EXT %ROUTINE	%RECORD(FILESPEC)%NAME F,F1
^^XDEFINE INPUT\\    %ROUTINE	    %INTEGER N,
		%RECORD(FILESPEC)%NAME FS
^^XDEFINE OUTPUT\\   %ROUTINE	    %INTEGER N,
		%RECORD(FILESPEC)%NAME FS
<XDELETE	EXT %ROUTINE	%RECORD(FILESPEC)%NAME FS
<XISFILE	EXT %PREDICATE	%RECORD(FILESPEC)%NAME FS
<XOPEN <DA	EXT %ROUTINE	%INTEGER CHAN,
	    	%RECORD(FILESPEC)%NAME FS
<XOPEN <SQ	EXT %ROUTINE	%INTEGER CHAN,
	    	RECORD(FILESPEC)%NAME FS
<XRENAME	EXT %ROUTINE	%RECORD(FILESPEC)%NAME F,F1
<ZERO	SYS %ROUTINE	%NAME FROM,TO

.SUBTITLE                              ^^^&APPENDIX H\\\&
.PAGE
.INDEX ERROR CODES
.INDEX %<EVENTS
.INDEX %<SIGNAL %<EVENT
.NAP;.TS 2,54
^&^RUNTIME ERROR CODES\&
.F.S 1
<IMP ALLOWS THE USER TO TRAP ON ANY GIVEN CONDITION BY THE %<SIGNAL
%<EVENT MECHANISM, DESRIBED IN THE <IMP77 ^LANGUAGE ^REFERENCE ^MANUAL.
^THE RUNTIME SYSTEM USES THIS FEATURE TO SIGNAL THAT ERRORS HAVE TAKEN PLACE
IN THE RUNTIME SYSTEM OR SYSTEM LIBRARY WHICH IT CANNOT SENSIBLY
RECOVER FROM. ^BELOW IS THE FULL LIST OF THESE %<EVENTS, WHOSE FORMAT IS AS FOLLOWS:-
.S
^THE MAIN EVENTS TOGETHER WITH THE TYPE OF EVENT THEY SIGNAL, ARE
GIVEN AT THE HEAD OF EACH SECTION. ^FOLLOWING THEM IN NUMERIC ORDER
ARE THE SUB-EVENTS WHICH HAVE ASSOCIATED WITH THEM
A MESSAGE HELD IN THE GLOBAL STRING <ERRMSG AND ALSO AN
INTEGER CONTAINING EXTRA INFORMATION, THE MEANING OF WHICH IS GIVEN IN
THE RIGHT-HAND COLUMN.
.S
E.G. AN END-OF-FILE CONDITION ON INPUT STREAM 4, IF NOT
TRAPPED BY THE USER, WOULD RESULT IN THE FOLLOWING MESSAGE
BEING OUTPUT ON THE USERS CONSOLE:-
.S.NF
<EOF ON STREAM
%<SIGNAL 9,0,4
.S 2
^EVENT  0, . . ^TERMINATION
.S
	-1 ^ABORT
	#0 NORMAL STOP
	>0
.S
^EVENT  1, . . ^ARITHMETIC OVERFLOW
.S
	#1 ^INTEGER TOO LARGE
	   ^INTEGER TOO LARGE FOR SHORT OR BYTE INTEGER	N
.S
^EVENT  2, .. ^EXCESS RESOURCE
.S
	#1 ^CANNOT GET STORE	FAULT
	   ^STACK SPACE FULL	FAULT
	#2 ^PROCEDURE STACK FULL
	#3
	#4 ^CANNOT GET STORE FOR HEAP	SIZE
	   ^HEAP SPACE FULL	REQD.
	#5 ^ALL <I/O CHANNELS IN USE
	   ^NO FREE CHANNELS FOR ^^COPY\\ING 'FILESPEC'
	#6 ^ARRAY SPACE EXHAUSTED
.S
^EVENT  3, ..  ^DATA ERROR
.S
	#1 ^NUMBER NOT FOUND	SYMBOL
	   ^INTEGER NOT FOUND	SYMBOL
	   ^OCTAL INTEGER NOT FOUND	SYMBOL
	   ^HEX INTEGER NOT FOUND	SYMBOL
	#2 ^NO OPENING STRING QUOTE	SYMBOL
.S
^EVENT  4, .. ^CORRUPT DATA
.S
	#1 ^INPUT ERROR STATUS _#NNNNNN	STR/CH
	   ^OUTPUT ERROR STATUS _#NNNNNN	STR/CH
	   (^SEE ^^DEC\\SYSTEM-10 ^MONITOR ^CALLS ^MANUAL
	    FOR MEANING OF THE STATUS BITS)
.S
^EVENT  5, .. ^INVALID ARGUMENTS
.S
	#1
	#2
	#3
	#4
	#5
	#6 ^ILLEGAL %NAME TYPE PARAMETER	TYPE
	#7 ^ILLEGAL STRING INDEX	INDEX
	#8 ^STRING PARAMETERS INSIDE OUT
	#9 ^INCORRECT ARGUMENT FOR SWITCH /....	ARG
	10 ^UNKNOWN SWITCH /'SWITCH'
.S
^EVENT  6, ..  ^OUT OF RANGE
.S
	#1 ^CONCATENATED STRING TOO LONG
	   ^STRING CAPACITY EXCEEDED
.S
^EVENT  7, ..  ^RESOLUTION FAILS
.S
	#0 ^RESOLUTION FAILS
.S
^EVENT  8, ..  ^UNASSIGNED VARIABLE
.S
^EVENT  9, ..  ^INPUT ENDED
.S
	#0 <EOF ON STREAM	STREAM
	   <EOF ON <DA OR <SQ CHANNEL	CHAN
.S 
	#1 ^NO INPUT ON STREAM	STREAM
	   (USED FOR NON-BLOCKING INPUT)
.S
^EVENT 10, ..  ^LIBRARY PROCEDURE ERROR
.S
	#1 ^DEFINING ILLEGAL STREAM/CHANNEL NUMBER	STR/CH
	#2 ^STREAM/CHANNEL ALREADY DEFINED	STR/CH
	#3 ^UNKNOWN DEVICE 'DEV'
	#4 ^LOOKUP ERROR FOR 'FILESPEC'	ERR*
	#5 ^ENTER ERROR FOR 'FILESPEC'	ERR*
	#6 ^CANNOT OPEN DEVICE 'DEV'
	   ^CANNOT OPEN DEVICE FOR 'FILESPEC'
	#7
	#8
	#9 ^BAD FILE SPECIFICATION 'FILESPEC'
	10 ^SELECTING ILLEGAL INPUT STREAM	STREAM
	11 ^SELECTING ILLEGAL OUTPUT STREAM	STREAM
	12 ^CANNOT <RESET INPUT STREAM	STREAM
	13 ^CANNOT <RESET OUTPUT STREAM	STREAM
	14 ^CHECKPOINT FAILURE	ERR*
	15 ^TAPOP FAILURE	T ERR
	   ('T ERR' IS A <TAPOP ERROR CODE - SEE ^MONITOR
	    ^CALLS ^MANUAL UNDER MAGNETIC TAPES)
	16 ^CANNOT <RENAME/DELETE 'FILESPEC'	ERR*
	17
	18
	19
	20 ^NOT A <DA OR <SQ TYPE DEVICE - 'DEV'
	21 ^CANNOT <OPEN <DA/SQ CHANNEL 'FILESPEC' ^ERROR:ERR*	CHAN
	22 ^^OPEN\\ING ALREADY OPEN <DA/SQ CHANNEL FOR 'FILESPEC' CHAN
	23 ^READ/WRITE TO ILLEGAL <DA/<SQ CHANNEL	CHAN
	   ^READ/WRITE TO <DA/<SQ CHANNEL BEFORE ^^OPEN\\ING IT	CHAN
	24 ^ACCESSING <DA CHANNEL BY <SQ ROUTINE OR VICE VERSA	CHAN
	25 ^STORAGE AREA FOR <DA/SQ ROUTINE INSIDE OUT	CHAN
	26 ^ILLEGAL BLOCK NUMBER FOR <DA READ/WRITE ROUTINE	BLOCK
	27 ^INPUTTING FROM AN <SQ CHANNEL SET FOR OUTPUT	CHAN
	   ^OUTPUTTING TO AN <SQ CHANNEL SET FOR INPUT	CHAN
	28 ^CLOSING ILLEGAL <DA/SQ CHANNEL	CHAN
	   ^CLOSING <DA/<SQ CHANNEL BEFORE ^^OPEN\\ING IT	CHAN
	   ^CLOSING <DA/SQ CHANNEL WITH THE WRONG ROUTINE	CHAN
.S 2
*
.F
THE EXTRA INFORMATION LABELED 'ERR' REFERS TO AN ERROR CODE
GIVEN IN ^APPENDIX ^E OF THE ^MONITOR ^CALLS ^MANUAL. ^HOWEVER THE
MOST COMMON VALUES ARE:-
.NF
0 - FILE NOT FOUND
1 - INCORRECT PROJECT-PROGRAMMER NUMBER
2 - PROTECTION FAILURE
.SUBTITLE                             ^^^^&INDEX\\\&
.PAGE
.DO INDEX
