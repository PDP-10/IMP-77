	                    %
THIS MODULE HANDLES ALL ROUTINES RELEVANT TO ACCOUNTING FILES, I.E. READING ACCT.SYS
AND BUILDING THE NAME TABLE IN THE HIGH SEGMENT.  THERE ARE THE FOLLOWING ENTRY
POINTS:
BUILDNAMETABLE  BUILDS THE NAME-TO-PPN NAME TABLE IN THE HIGH SEGMENT.
NAMESEARCH      RETURNS A LIST OF PPN'S EQUIVALENT TO THE ARGUMENT NAME
PPNSEARCH       RETURNS A LIST OF PPN'S EQUIVALENT TO THE ARGUMENT PPN.
TYPNMB		THIS ROUTINE IS PASSED THE ADDRESS OF A NAME BLOCK IN ANY OF
		A NUMBER OF FORMATS.  IT PROPERLY PRINTS THE NAME/PPN/GROUP
		NAME OR WHATEVER ON THE TTY.  



THE NAME TABLE IN THE HIGH SEGMENT IS POINTED TO BY NAMETABLE; ITS SIZE IS
NAMESIZE.  THE FORMAT OF THE TABLE IS THREE WORDS PER ENTRY; TWO WORDS FOR
THE NAME (UP TO 12 SIXBIT CHARACTERS) FOLLOWED BY THE PPN.  THE TABLE IS
SORTED BY NAME; THUS FINDING A NAME IN THE HIGH SEGMENT CAN BE DONE BY A
BINARY SEARCH.  HOWEVER FINDING A PPN REQUIRES A LINEAR SEARCH.
	                    %

MODULE TELACT(RESERVE(4,5,6))=
BEGIN

REQUIRE DSK:TELPRM.BLI;


EXTERNAL	NAMETABLE,		!START OF NAME TABLE IN HIGH SEG
		NAMEND;			!LAST LOC OF TABLE
OWN		NAMESIZE,		!NUMBER OF ENTRIES IN TABLE
		WHOPOINT;	!KLUDGE--POINTER TO FIRST OF A BLOCK OF
				!IDENTICAL NAMES
FORWARD	    QUICKSORT,PPNSEARCH,APPEND,REMOVE,TYPNMB,MASKPPNTYPE;
EXTERNAL    YES,ALLOCATE,NEXTITEM,INITSCAN,FILESPEC,OPENSPEC,FLAGWORD,ZEROSPEC;
MAP	    STRFILE FILESPEC;

BIND	    ITEM=3;                !THE SIZE OF AN ENTRY IN THE NAME TABLE
	                           !CHANGE THIS IF MORE INFO IS ADDED TO TABLE




EXTERNAL    ERR,ERRC,ERRFIN,PPNPRINT,PRTNM,MYPPN,TTYTYPE,STOP;


GLOBAL	    STRCOREBLK PPNLIST,        !LIST OF PPN'S WE DID UNDERSTAND
	    STRCOREBLK FAILLIST,       !LIST OF PEOPLE WE DIDN'T UNDERSTAND
	    STRCOREBLK GROUPLIST,      !LIST OF USER GROUPS
	    BUILDING,			!-1 IF BUILDING TABLE
	    CNTRLC;			!-1 IF ^C OCCURRED WHILE BUILDING TABLE
	                     %
THIS ROUTINE BUILDS THE NAME TABLE BY READING SYS:ACCT.SYS; THE TABLE IS
SORTED USING THE QUICKSORT ROUTINE BELOW.  IF THE ACCOUNTING FILES HAVE BEEN
CHANGED, THIS IS THE ONLY ROUTINE THAT NEEDS TO BE REWRITTEN (SO LONG AS THE
HIGH SEG TABLE REMAINS THE SAME).
	                      %

GLOBAL ROUTINE BUILDNAMETABLE=
BEGIN

OWN	    IBUFH[3];
	    BIND INPTR=(IBUFH+1)<0,36>,
	         INCOUNT=(IBUFH+2)<0,36>;

ROUTINE READWD=
	BEGIN
	IF (INCOUNT_.INCOUNT-1) LEQ 0
	    THEN IFSKIP IN(DSK)
	            THEN ERROR(SYSTEM,'ISA I/O error reading SYS:ACCT.SYS');
	@(INPTR_.INPTR+1)
	END;


BUILDING_-1;				!DISALLOW ^C'S WHILE BUILDING TABLE
ZEROSPEC(); FILESPEC[FILESTATUS]_#400000000010;   !OPEN SYS:ACCT.SYS
FILESPEC[FILEDEVICE]_SIXBIT 'SYS'; FILESPEC[FILEBUFS]_IBUFH<0,0>;
FILESPEC[FILENAME]_SIXBIT 'ACCT'; FILESPEC[EXTENSION]_SIXBIT "SYS";
IF OPENSPEC(0)
    THEN
        BEGIN
        REGISTER S;
        S_-EXTENDLH(FILESPEC[SIZEWORD]); !SIZE OF FILE EXTENDING SIGN
        IF .S MOD (IF CSLHACK THEN 19 ELSE 14) NEQ 1 THEN ERROR(SOFT,'AWS ACCT.SYS word count strange');
        NAMESIZE_.S/(IF CSLHACK THEN 19 ELSE 14);
        NAMETABLE_.JOBHRL<LH>+#400000;	!FIRST FREE LOC IN HIGH SEG
        S_READWD(); 
	IF .S<RH> NEQ (IF CSLHACK THEN 19 ELSE 14) OR .S<LH> LSS 2 OR .S<LH> GTR 4
	    THEN ERROR(SYSTEM,'WVA wrong version SYS ACCT.SYS');
	NAMEND_.NAMETABLE+(.NAMESIZE-1)*ITEM;
	S<LH>_.NAMEND+ITEM; S<RH>_0;
        IF .S<LH> GTR .JOBHRL<RH>
            THEN
                BEGIN
                IFSKIP CORE(S)
                    THEN %OK% 
                    ELSE ERROR(HARD,'CEH Cannot expand high segment to build name table');
                END;
	INCR S FROM .NAMETABLE TO .NAMEND BY ITEM DO
            BEGIN
            (@S+2)<0,36>_READWD();	!PPN OF USER
            DECR J FROM 2 TO 1 DO READWD();
            (@S)<0,36>_READWD();	!FIRST HALF OF NAME
            (@S+1)<0,36>_READWD();	!SECOND HALF OF NAME
            DECR J FROM (IF CSLHACK THEN 14 ELSE 9) TO 1 DO READWD();
            END;
        RELEASE(DSK);
        END
    ELSE
	STOP();
QUICKSORT(.NAMETABLE,.NAMEND);
BUILDING_0;				!REALLOW CONTROL C'S
IF .CNTRLC NEQ 0 THEN STOP();		!USER TYPED ^C WHILE BUILDING
END;
!
!MACRO TO COMPARE TWO QUANTITIES.  RETURNS 1 IF FIRST IS LARGER THAN OR
!EQUAL, 0 IF SMALLER.  ACTUALLY GENERATES AN (EFFICIENT) CALLTO GRTEQL ROUTINE
!BELOW.
!
MACRO	GREATEREQUAL(A,B)=
	BEGIN
	P1_A; P2_B; GRTEQL()
	END$;
MACRO	SMALLER(AA,BB)=NOT GREATEREQUAL(AA,BB)$,
	GREATER(AA,BB)=NOT GREATEREQUAL(BB,AA)$,
	SMALLEREQUAL(AA,BB)=GREATEREQUAL(BB,AA)$;

!MACRO TO COMPARE UNSIGNED 36 BIT QUANTITY.  MUCH COMPLICATED BY THE
!FACT THAT THE TEN DOES NOT HAVE LOGICAL COMPARE INSTRUCTIONS...
!RETURNS 1 IF A GEQ B, 0 IF A SMALLER
MACRO COMPARE(A,B)=
	BEGIN
	IF A LSS 0			!IS BIT 0 A 1?
	    THEN			!YES
		IF B LSS 0		!IS BIT 0 OF B A 1 TOO?
		    THEN A GEQ B	!YES, RETURN COMPARISON 
		    ELSE 1		!BIT 0 OF A=1, BIT 0 OF B=0, THEREFORE A GTR B
	    ELSE			!BIT 0 OF A = 0
		IF B LSS 0		!IS BIT 0 OF B 1?
		    THEN 0		!BIT 0 OF A=0, BIT 0 OF B=1, THEREFORE A LSS B
		    ELSE A GEQ B	!BOTH HAVE BIT 0=0, LET HARDWARE DO IT.
	END$;
!
!ROUTINE TO COMPARE TWO FULL-WORD KEYS.  RETURNS 1 IF FIRST IS GREATER
!THAN OR EQUAL TO SECOND, 0 IF FIRST IS SMALLER.  ADDRESS OF FIRST
!IS ASSUMED TO BE IN P1, SECOND IN P2.  SEE GREATEREQUAL MACRO ABOVE
!
ROUTINE GRTEQL=
IF @.P1 EQL @.P2			!FIRST WORDS EQUAL?
    THEN COMPARE(@(.P1+1),@(.P2+1))	!YES LOOK AT SECOND WORD
    ELSE COMPARE(@.P1,@.P2);		!NO, LET COMPARISON MACRO DO WORK


MACRO	INTERCHANGE(A,B)=
	BEGIN
	P1_A; P2_B; INTRTN()
	END$;
ROUTINE INTRTN=
	BEGIN
	P3_@.P1; (.P1)<0,36>_@.P2; (.P2)<0,36>_.P3;
	P3_@(.P1+1); (.P1+1)<0,36>_@(.P2+1); (.P2+1)<0,36>_.P3;
	P3_@(.P1+2); (.P1+2)<0,36>_@(.P2+2); (.P2+2)<0,36>_.P3;
	.VREG
	END;

				%
THE SORT USED HERE IS QUICKSORT.  THE BASIC IDEA OF QUICKSORT IS TO DIVIDE A
LIST INTO TWO NON-EMPTY SUBLISTS, EACH OF WHICH CAN THEN BE SORTED USING
QUICKSORT.  THE FIRST LIST MUST CONTAIN ONLY ELEMENTS SMALLER THAN OR EQUAL
TO SOME SPECIFIED ELEMENT OF THE LIST; THE SECOND SUBLIST MUST CONTAIN ONLY
ELEMENTS GREATER THAN OR EQUAL TO THE SPECIFIED ELEMENT OF THE LIST.  THE
SPECIFIC ELEMENT IS CHOSEN HERE BY TAKING THE MEDIAN OF THE FIRST, MIDDLE,
AND LAST ELEMENTS OF THE LIST.

ASSUMPTIONS:
(1) THE MACRO PRIMITIVES (GREATEREQUAL,COPY,INTERCHANGE) WORK CORRECTLY.
(2) ON INITIAL CALL TO QUICKSORT, THE LIST IS NON-EMPTY (B LEQ E)
(3) EACH ELEMENT OF THE LIST IS OF SIZE ITEM WORDS.

SKETCH OF CORRECTNESS PROOF:
BY INDUCTION ON THE NUMBER OF ELEMENTS IN THE LIST.
BASIS: (LINES 2-7) IF THE LIST HAS 1 ELEMENT THAN IT DOES NOT NEED TO BE
SORTED. IF THE LIST HAS TWO ELEMENTS THAN ONLY ONE COMPARE IS NECESSARY.

INDUCTIVE STEP(LINES 8-26):
ASSUME THE LIST HAS N ELEMENTS, WHERE N GEQ 3.  THEN IF WE CAN SHOW THAT
QUICKSORT DIVIDES THE LIST INTO TWO NON-EMPTY SUBLISTS, THE FIRST OF
WHICH CONTAINS ONLY ELEMENTS SMALLER OR EQUAL TO A SPECIFIED MEDIAN ELEMENT,
THE SECOND OF WHICH CONTAINS ONLY ELEMENTS GREATER OR EQUAL TO THE MEDIAN,
THEN WE ARE DONE.

TO DO THIS, THE FIRST, MIDDLE, AND LAST ELEMENTS OF THE LIST ARE SORTED USING
BUBBLE SORT IN LINES 11-13.  THE MIDDLE ELEMENTS IS NOW SMALLER OR EQUAL TO
THE LAST; THE MIDDLE ELEMENT IS NOW LARGER OR EQUAL TO THE FIRST.

(NOTATION: LIST IS THE SET OF ALL ADDRESSES OF ELEMENTS TO BE SORTED BETWEEN
B AND E, INCLUSIVE.  KEY(X) IS THE KEY OF THE ELEMENT POINTED TO BY X.)
THE LOOP HYPOTHESIS (HENCEFORTH, LOOP HYPO) OF LINES 17-26 IS THE FOLLOWING:
FOR ALL X IN LIST, [(IF X LSS I THEN KEY(X) LEQ KEY(M)) AND
		    (IF X GTR J THEN KEY(X) GEQ KEY(M)]
THUS WHEN THE LOOP TERMINATES (I GTR J) WE WILL HAVE THE TWO SUBLISTS
(ACTUALLY WE NEED THE STRONGER CONDITION THAT I=J+ITEM AT TERMINATION, BUT
THIS IS WHAT WE IN FACT PROVE).

AFTER EACH LINE OF THE LOOP WE CAN SAY THE FOLLOWING:
AFTER LINE 19
	(LOOP HYPO AND I=J+ITEM) OR (LOOP HYPO AND KEY(I) GTR KEY(M))
AFTER LINE 20 (WHICH ONLY DOES SOMETHING IF I LEQ J)
	(LOOP HYPO AND I=J+ITEM)
OR	(LOOP HYPO AND KEY(I) GTR KEY(M) AND (I=J+ITEM OR KEY(J) LSS KEY(M))
WHICH IS LOGICALLY EQUIVALENT TO
	(LOOP HYPO AND I=J+ITEM) OR (LOOP HYPO AND KEY(I) GTR KEY(M) AND KEY(J) LSS KEY(M))
NOTE THE CONSEQUENCES: I NEQ J, I NEQ M, J NEQ M.

LINE 22 IS ONLY EXECUTED IF I LSS J, I.E. THE KEY(I) GTR KEY (M) GTR KEY(J).
AFTER THE INTERCHANGE, WE HAVE KEY(I) LSS KEY(M) LSS KEY(J). HENCE AFTER
I AND J GET INCRED/DECRED THE LOOP HYPO STILL HOLDS.  FURTHERMORE,
I LEQ J+ITEM, SINCE I AND J ONLY GOT CHANGED IF (I-ITEM) LSS (J+ITEM).

HENCE AT LINE 23, THE LOOP HYPOTHESIS HOLDS.
WHEN THE LOOP TERMINATES, WHICH HAPPENS ONLY IF I=J+ITEM, WE SORT THE FIRST
LIST (ALL ELEMENTS UP TO BUT NOT INCLUDING I), AND THE SECOND LIST (ALL
ELEMENTS FOLLOWING BUT NOT INCLUDING J=I-ITEM.  NIETHER LIST IS EMPTY,
BECAUSE I IS INITIALLY GTR B, J IS INITIALLY LSS J.
			%

ROUTINE QUICKSORT(B,E)=
BEGIN REGISTER I,J,M;
%1%	IF .E-.B LEQ ITEM			!CHECK FOR 1 OR 2 ELT LIST
%2%	    THEN				!IT IS
%3%		BEGIN
%4%		IF .E-.B NEQ 0			!CHECK FOR 2 ELT LIST
%5%		   THEN
%6%			IF GREATER(.B,.E) THEN INTERCHANGE(.B,.E);
%7%		END
%8%	    ELSE				!AT LEAST 3 ELTS IN LIST
%9%		BEGIN	
%10%		M_(.E-.B)/(2*ITEM)*ITEM+.B;	!MIDDLE ELT OF LIST
%11%		IF GREATER(.B,.M) THEN INTERCHANGE(.B,.M);
%12%		IF GREATER(.B,.E) THEN INTERCHANGE(.B,.E);
%13%		IF GREATER(.M,.E) THEN INTERCHANGE(.M,.E);
%14%
%15%		I_.B+ITEM;			!START OF LIST
%16%		J_.E-ITEM;			!END OF LIST
%17%		WHILE .I LEQ .J DO
%18%		    BEGIN
%19%		    WHILE .I LEQ .J AND SMALLEREQUAL(.I,.M) DO I_.I+ITEM;
%20%		    WHILE .I LEQ .J AND GREATEREQUAL(.J,.M) DO J_.J-ITEM;
%21%		    IF .I LSS .J
%22%			THEN (INTERCHANGE(.I,.J); I_.I+ITEM; J_.J-ITEM);
%23%		    END;
%24%		QUICKSORT(.B,.I-ITEM);
%25%		QUICKSORT(.I,.E);
%26%		END;
END;
			%
DECRIPTION OF SEARCH LOGIC: (NAMES)
THERE ARE TWO DIFFERENT KINDS OF NAMES THAT CAN MATCH A USER REQUEST.  THEY
ARE USER GROUP NAMES AND ACTUAL USER NAMES.
USER NAMES ARE STORED IN THE SORTED HIGH SEGMENT TABLE;
USER GROUP NAMES ARE STORED IN THE DYNAMIC LIST "GROUPLIST".
ANY NAME WHICH MATCHES WHAT THE USER TYPE (UNDER THE MASK
EQUAL TO THE NUMBER OF CHARACTERS THE USER TYPED) WILL BE ACCEPTED.

THE ROUTINE FINDNAM ROUTINE IS WHAT ACTUALLY SEARCHES THE TABLES.  IT IS CALLED
EXCLUSIVELY FROM "NAMESEARCH".  FINDNAM RETURNS "1" IF A MATCH WAS FOUND,
0 IF NO MATCH WAS FOUND.  THE ARGUMENT TO FINDNAM IS A POINTER TO THE BLOCK
OF CONTROL VARIABLES USED BY IT AND SET UP BY NAMESEARCH.  (FINDNAM COULD BE
A FUNCTION WITHIN THE LEXICAL SCOPE OF "NAMESEARCH".  HOWEVER THAT GENERATES
INEFFICIENT CODE AND ALSO SEEMS TO CONFUSE THE BLISS COMPILER...)  THE VARIABLE
"WHERE" WITHIN THE PARAMETER BLOCK IS THE ADDRESS OF THE BLOCK WHICH MATCHED.
THIS MIGHT BE A LOW SEG ADDRESS, IN THE CASE OF A USER GROUP TABLE, OR A
HIGH SEG ADDRESS IN THE CASE OF A USER NAME. IN THE FORMER
CASE "GROUPNAME" IS 1; IN THE LATTER, "GROUPNAME" IS 0.

IF THE COMPILE-TIME SWITCH "INDPPN" IS 0, I.E. PPN'S ARE NOT INDEPENDENT,
TWO IDENTICAL NAMES WITH THE SAME PROGRAMMER NUMBER ARE CONSIDERED EQUIVALENT.
THE FINDNAM CODE SCANS UNTIL IT FINDS THE LAST ENTRY OF THE SAME NAME AND
PROGRAMMER NUMBER BEFORE RETURNING.  (THIS AFFECTS HIGH SEGMENT SEARCHING
ONLY).
			%


!THESE MACROS ARE DEFINED OUTSIDE OF THE LEXICAL SCOPE OF BOTH FINDNAM AND
!NAMESEARCH SO THAT THEY CAN BE USED INSIDE BOTH.

MACRO	 HIGHSEG=FLAGS<35,1>$,    !1 = (HISEG)NAME TABLE, 0 = (LOW SEG)GROUP TABLE
         FOUND=FLAGS<34,1>$,      !1 IF FOUND ENTRY IN NAME TABLE
         GROUPNAME=FLAGS<33,1>$,  !1 IF LAST ENTRY FOUND WAS A GROUP NAME
	 UNKNOWN=FLAGS<32,1>$;	  !1 IF SOME RECURSIVE CALL TO NAMESEARCH/PPNSEARCH
				  !ENCOUNTERED AN UNKNOWN NAME OR OTHER ERROR



MACRO	MASKEQUAL(A,B)=
	BEGIN
	IF ((@A XOR @B) AND @NAMEMASK) EQL 0
	    THEN
		IF ((@(A+1) XOR @(B+1)) AND @(NAMEMASK+1)) EQL 0
		    THEN 1
		    ELSE 0
	    ELSE 0
	END$;
!
!ROUTINE TO FIND NAME WITHIN HIGH SEGMENT NAME TABLE OR LOW SEGMENT GROUP
!TABLE.
!
ROUTINE FINDNAM(PARMS)=
BEGIN
MACRO	WHERE=(.PARMS)<0,36>$,	!CURRENT SCAN POINTER
	NAME=(.PARMS+1)<0,36>$,	!POINTER TO NAME BLOCK LOOKING FOR
	NAMEMASK=(.PARMS+2)$,	!NAME MASK IS A TWO-WORD BLOCK
	FLAGS=(.PARMS+4)$;	!FOR THE FLAGS DEFINED ABOVE

!IF HIGHSEG IS ZERO, WE HAVEN'T FINISHED SCANNING THE LOW-SEG GROUP TABLE
IF NOT .HIGHSEG
    THEN
	WHILE (WHERE_NEXTITEM(GROUPLIST)) NEQ 0 DO
            BEGIN
            IF MASKEQUAL(.WHERE,.NAME) THEN (GROUPNAME_1; RETURN 1);
            END;

!HERE IF NOT FOUND IN GROUP TABLE, AND SHOULD START (OR CONTINUE) SCANNING
!THE NAME TABLE.
HIGHSEG_1;                      !NOT FOUND IN GROUP TABLE, SEARCH NAME TABLE
IF NOT .FOUND
    THEN

	!WE GET HERE IF WE HAVEN'T FOUND ANY MATCHES AT ALL IN THE HIGH
	!SEG NAME TABLE YET.  DO A BINARY SEARCH OF THE TABLE TO FIND
	!THE (POSSIBLY EMPTY) BLOCK WHICH MATCHES THE NAME PASSED TO US
        BEGIN REGISTER B,E,MID;
        LABEL L;
        B_.NAMETABLE; E_.NAMEND;
        L: DO
            BEGIN
            MID _ ((.E-.B)/(2*ITEM))*ITEM+.B;
            IF MASKEQUAL(.NAME,.MID) THEN LEAVE L;
            IF GREATEREQUAL(.NAME,.MID)
                THEN B_.MID
                ELSE E_.MID;
            END
        WHILE
            .B LSS .E - ITEM;
	!WE HAVE EITHER FOUND AN ENTRY THAT MATCHES, OR THERE IS NONE.
	!BACK UP PAST THE BEGINNING OF THE BLOCK WHICH MATCHES.
	!THE SCAN POINTER WILL BE INCREMENTED AS SOON AS WE JUMP OUT
        WHERE_.MID;
        UNTIL NOT MASKEQUAL(.NAME,.WHERE) DO WHERE_.WHERE-ITEM;
        END;
!HERE IF EITHER WE HAVE FOUND AT LEAST ONE MATCHING ENTRY IN THE HIGH
!SEGMENT (THIS CALL OR THE PREVIOUS) OR THERE IS NO MATCHING ENTRY.
!SKIP TO THE NEXT ENTRY AND RETURN 0 IF IT MATCHES, 1 IF NOT.
FOUND_1;
WHERE_.WHERE+ITEM;
IF .WHERE GTR .NAMEND THEN RETURN 0;

!IF PROGRAMMER NUMBERS UNIQUELY REPRESENT A USER, SCAN TILL THE END OF THE
!BLOCK IN WHICH THIS USER EXISTS.  THIS PREVENTS A TELLER FROM BEING QUERIED
!SEVERAL TIMES ABOUT THE SAME PERSON WHO HAS DIFFERENT ACCOUNTS.
IF .INWHO AND (.WHOPOINT EQL 0) THEN WHOPOINT_.WHERE;	!SAVE POINTER TO START OF BLOCK
IF NOT INDPPN
    THEN
	BEGIN LABEL L;
	L: REPEAT
	    BEGIN
	    IF .WHERE GEQ .NAMEND THEN LEAVE L;
	    IF (@(.WHERE) NEQ @(.WHERE+ITEM)) OR
	       (@(.WHERE+1) NEQ @(.WHERE+1+ITEM)) OR
	       (.(.WHERE+2)<RH> NEQ .(.WHERE+2+ITEM)<RH>)
		    THEN LEAVE L;
	    WHERE_.WHERE+3;
	    END;
	END;
IF MASKEQUAL(.WHERE,.NAME) THEN (GROUPNAME_0; 1) ELSE 0
END;
	                    %
ROUTINE TO RETURN ALL PPN'S EQUIVALENT TO A GIVEN NAME.  
THIS ROUTINE WILL EITHER ADD OR DELETE THE PPN'S EQUIVALENT TO THE
ARGUMENT NAME FROM THE PPN LIST DEPENDING ON THE VALUE OF THE ADD FLAG.
NAME	IS A POINTER TO A THREE WORD BLOCK (MAPPED WITH STRUCTURE STRNAME)
OPTIONS	IS A BIT VECTOR DESCRIBING HOW NAMESEARCH SHOULD WORK.
	BIT 35 (DELETE) IS 1 IF PPNS ARE TO BE DELETE, 0 IF ADDED
	BIT 34 (QUERY) IS 0 IF (A) NO QUERIES ARE TO BE MADE (FIRST MATCH
		USED) (B) NO ERRORS PRINTED (C) GROUP NAMES IGNORED.
	                    %

GLOBAL ROUTINE NAMESEARCH(NAME,OPTIONS)=
BEGIN
LABEL	    NS;
MAP	    STRNAME NAME;
LOCAL	    PARMS[5];       !PARMS IS A PARAMETER AREA (AS DEFINED BELOW).
	                    !RATHER THAN LETTING THE COMPILER PUSH LOTS OF THE
	                    !THINGS ON THE STACK (AS IT WOULD DO IF FINDNAM WERE
	                    !A FUNCTION) WE MAKE FINDNAM A ROUTINE AND PASS PARMS


	   MACRO WHERE=PARMS<0,36>$,     !WHERE IS THE ADDRESS WITHIN THE NAME TABLE
	                                 !OR GROUP TABLE WE ARE CURRENTLY SCANNING
	         NAMEADDR=(PARMS+1)<0,36>$,  !ADDRESS OF NAME BLOCK FOR FINDNAM
	         NAMEMASK=(PARMS+2)$,    !NAME MASK IS A TWO-WORD BLOCK FOR THE MASK OF THE NAME
	         FLAGS=(PARMS+4)$;       !FLAGS ARE DEFINED ABOVE

	    MACRO DELETE=OPTIONS<0,1>$,
		  QUERY=OPTIONS<1,1>$;

!MACRO TO BUILD MASK FOR COMPARISON OF NAMES IN NAME TABLE (USE WITH MASKEQUAL
!MACRO IN FINDNAM).

MACRO	BUILDMASK=
	BEGIN P3_0;
	P1_@(.NAME); P2_@(.NAME+1);
	IF (.P1 OR .P2) NEQ 0  %CHECK FOR ZERO NAME%
	    THEN
		WHILE .P2<0,6> EQL 0
		DO (LSHC(P1,-6); P3_.P3+6);
	P1_P2_-1;
	LSHC(P1,0,P3);
	NAMEMASK<0,36>_.P1; (NAMEMASK+1)<0,36>_.P2;
	END$;
!START OF THE NAME SEARCH CODE ITSELF

!SPECIAL KLUDGEY CHECK FOR THE CASE OF "ME": IF FOUND CALL PPNSEARCH WITH MY PPN
IF .NAME[NM1] EQL SIXBIT 'ME' AND .NAME[NM2] EQL 0
    THEN RETURN PPNSEARCH(MYPPN<ADDR>,DELETE_.DELETE XOR .NAME[DELFLAG]);
				!REQUIRES TWO WORDS FOLLOWING MY PPN
				!TO LOOK LIKE A GROUP BLOCK
INITSCAN(GROUPLIST);
ASKQUEST_WHOPOINT_FLAGS_0;      !ASSUME NOTHING IN THE BEGINNING
NAMEADDR_.NAME;                 !COPY ADDRESS OF NAME BLOCK FOR FINDNAM ROUTINE
BUILDMASK;                      !BUILD MASK FROM USER NAME
IF NOT .QUERY THEN HIGHSEG_1;	!DO NOT LOOK AT GROUP TABLE IF NOT QUERYING

NS:
IF FINDNAM(PARMS<ADDR>)
	THEN                    !OK--AT LEAST ONE MATCH
	    BEGIN LOCAL SAVEFLAGS,SAVEWHOPNT,SAVEGROUP;
	    REGISTER STRNAME MATCH; LABEL L;
	    SAVEFLAGS_.FLAGS;	!SAVE FLAGS OF FIRST MATCH
	    MATCH_.WHERE; SAVEWHOPNT_.WHOPOINT; WHOPOINT_0;
	    SAVEGROUP_.GROUPNAME;	!save group flag for first entry which matched
	    L: IF FINDNAM(PARMS<ADDR>) AND .QUERY
	        THEN            !OH NO-- A CONFLICT
	            BEGIN
		    ASKQUEST_1;
!EDIT-2
		    IF .SAVEGROUP THEN IF NOT .GROUPNAME THEN
			%groupname takes precedence over other names%
			(FLAGS_.SAVEFLAGS; WHOPOINT_.SAVEWHOPNT; LEAVE L;);
		    IF .IAMBATCH THEN TYPECHR("??"); !ADD AN ERROR FLAG
	            TYPE ('Do you mean '); TYPNMB(.MATCH); TYPECHR("??");;
!EDIT-2 IN NAMESEARCH
		    IF .IAMBATCH THEN RETURN;   !CANT GET RESPONSES
	            IF YES() THEN (FLAGS_.SAVEFLAGS; WHOPOINT_.SAVEWHOPNT; LEAVE L;);
	            DO
	                BEGIN
	                TYPE ('Or '); TYPNMB(.WHERE); TYPECHR("??");
	                IF YES() THEN (MATCH_.WHERE; LEAVE L);
			WHOPOINT_0;
	                END
	            WHILE
	                FINDNAM(PARMS<ADDR>);
	            LEAVE NS;
	            END
		ELSE
		    WHOPOINT_.SAVEWHOPNT;
	    DELETE_.DELETE XOR .NAME[DELFLAG];
	    IF .GROUPNAME
	        THEN
	            BEGIN
	            REGISTER STRNAME P;
		    INITSCAN(.MATCH+3);
	            UNTIL
	                (P_NEXTITEM(.MATCH+3)) EQL 0
	            DO
			UNKNOWN _ .UNKNOWN OR
	                (IF .P[PPNFLAG]
	                    THEN PPNSEARCH
	                    ELSE NAMESEARCH)(.P,.OPTIONS)
	            END
	        ELSE
		    BEGIN
		    IF .INWHO THEN MATCH_.WHOPOINT;	!RESTORE POINTER
	            (IF .DELETE THEN REMOVE ELSE APPEND)(.MATCH);
		    IF .INWHO
		      THEN
			BEGIN LABEL L;
		      L:REPEAT
			    BEGIN
			    IF .MATCH GEQ .NAMEND THEN LEAVE L;
			    IF  (@(.MATCH) NEQ @(.MATCH+ITEM)) OR
				(@(.MATCH+1) NEQ @(.MATCH+1+ITEM)) OR
				(.(.MATCH+2)<RH> NEQ .(.MATCH+2+ITEM)<RH>)
				    THEN LEAVE L;
			    (IF .DELETE THEN REMOVE ELSE APPEND)(MATCH_.MATCH+ITEM);
			    END;
			END;
		    END;
	    RETURN .UNKNOWN;
	    END;

IF .QUERY
    THEN
!EDIT-2
	BEGIN
	IF .IAMBATCH THEN TYPECHR("??");
	TYPE ('I don''t know '); TYPNMB(.NAME); TYPE('?M?J');
	END;
1
END;
	            %
THIS ROUTINE ADDS ALL PNN'S WHICH MATCH THE SPECIFICATIONS PASSED TO IT
ONTO PPNLIST.  PPNBLOCK SHOULD BE A PPN IN THE FIRST WORD, A MASK IN THE
SECOND (TO HANDLE WILDCARDING).  OPTIONS IS "1" IF PPNS ARE TO BE DELETED FROM
PPNLIST, "0" IF THEY ARE TO BE ADDED.
	            %

GLOBAL ROUTINE PPNSEARCH(PPNBLOCK,OPTIONS)=
BEGIN
MACRO DELETE=OPTIONS<0,1>$,
      QUERY=OPTIONS<1,1>$;

MAP STRNAME PPNBLOCK; REGISTER MATCH;


IF (IF INDPPN THEN .PPNBLOCK[NM2] ELSE .PPNBLOCK[NM2]<RH>) NEQ 0 AND .QUERY AND NOT .INWHO AND NOT .NEVREM
    THEN
	IF .MYPPN<LH> NEQ 1			!WILD CARD TELL? OK IF I AM PROJ 1
	    THEN 
		IF .PPNBLOCK[NM1]<LH> NEQ .MYPPN<LH>
		    THEN
			IF ((.PPNBLOCK[NM1]<DEPT> EQL .MYPPN<DEPT>) AND
			   (.MYPPN<RH> EQL 1) AND	!RES CTL SUP TO HIS DEPT?
			   (IF FTRCUG THEN 1 ELSE ((.MYPPN<18,3> GEQ 4) OR (.MYPPN<18,3> EQL 0)))) THEN ELSE
!EDIT-2
			BEGIN
			IF .IAMBATCH THEN TYPECHR("??");
			(TYPE ('Sorry, you can''t TELL'); TYPNMB(.PPNBLOCK); TYPE ('?M?J'); RETURN 1);
			END;


DELETE_.DELETE XOR .PPNBLOCK[DELFLAG];
MATCH_0;
INCR I FROM .NAMETABLE TO .NAMEND BY ITEM
	DO
	    BEGIN MAP STRNAME I;
	    IF ((.PPNBLOCK[NM1] XOR .I[PPNOFNAME]) AND NOT .PPNBLOCK[NM2]) EQL 0
	        THEN
	            BEGIN
	            (IF .DELETE THEN REMOVE ELSE APPEND)(.I);
	            MATCH_1;
	            END;
	    END;
IF NOT .MATCH AND .QUERY
    THEN
!EDIT-2
	BEGIN
	IF .IAMBATCH THEN TYPECHR("??");
	TYPE ('I don''t know '); TYPNMB(.PPNBLOCK); TYPE('?M?J');
	END;
NOT .MATCH
END;
			%
THIS ROUTINE ALLOWS YOU TO SPECIFY A LIST OF PPN'S WHICH MAY NOT RECEIVE
MESSAGES (EG 1,4).  TO INHIBIT PEOPLE FROM TELLING A PPN (OR PROJECT)
MESSAGES, ADD TO NLIST (BELOW). TO SPECIFY AN ENTIRE PROJECT THAT MAY
NOT RECEIVE MESSAGES, LET THE PROGRAMMER NUMBER BE 777777.
			%
GLOBAL ROUTINE NEVTEL=
BEGIN
	BIND NTELL=PLIT(0,		!BE DEFENSIVE ABOUT REACT BUG
		#1777777,#2777777,#3777777,#4777777,#5777777,#6777777,#7777777,#10777777,#11777777,#12777777,#777777000001,
#140000141,#140000143,#140000145,#141000147,#142000147,#120000121,#121000120,
#122000120,#110000120,#110000113,#1000001003,#140000142,#121000132,#110000127,
#111000127,#122000127);
	REGISTER STRNAME PNTR;
	OWN PPNBLOCK[3];
	PNTR_PPNBLOCK<ADDR>;
	NEVREM_1;			!CURRENTLY REMOVING PPN'S
	PNTR[NAMEFLAGS]_0;
	INCR I FROM 0 TO .NTELL[-1]-1
	  DO
	    BEGIN
	    PNTR[NM1]_.NTELL[.I];	!GET A PPN
	    PNTR[PROJMASK]_IF .PNTR[PROJNUM] EQL #777777 THEN #777777 ELSE 0;
	    PNTR[PROGMASK]_IF .PNTR[PROGNUM] EQL #777777 THEN #777777 ELSE 0;
	    PPNSEARCH(PPNBLOCK,1);	!REMOVE THIS PPN
	    END;
	NEVREM_0;			!NO LONGER IN THIS ROUTINE
END;
			%
ROUTINES TO MANIPULATE PPNLIST.  PPNLIST IS A LIST OF POINTERS TO THE
NAME/PPN BLOCKS IN THE HIGH SEGMENT OF THE PEOPLE WE  ARE SUPPOSED TO
TELL.  ENTRIES CAN BE BOTH ADDED AND DELETED FROM PPNLIST; HOWEVER IF
THEY ARE DELETED, THE LIST IS NOT COMPRESSED.  RATHER THE POINTER IS 
ZEROED; ANY ROUTINE WHICH LOOKS AT PPNLIST SHOULD BE SMART ENOUGH TO
HANDLE THIS CASE.
			%

!THE PPNEQUAL MACRO DECIDES WHETHER AN ENTRY ON PPNLIST IS EQUAL TO THE
!ELEMENT WE ARE GOING TO ADD OR DELETE.  IF PROGRAMMER NUMBERS UNIQUELY
!DEFINE A USER (INDPPN=0) THEN THE PROGRAMMER FIELD IS CHECKED.  OTHERWISE
!THE ADDRESS OF THE NAME/PPN BLOCK IS SUFFICIENT TO SEE IF THE ENTRIES ARE
!EQUAL.
MACRO PPNEQUAL=
	IF INDPPN OR .INWHO OR .NEVREM	!PROGRAMMER NUMBERS DEFINE A USER?
	    THEN (@.P EQL .ELT)	!NO, JUST CHECK ADDRESSES
	    ELSE		!YES, LOOK AT PROGRAMMER NUMBERS
		BEGIN REGISTER STRNAME R;
		R_@.P; .R[PROGNUMOFNAME] EQL .ELT[PROGNUMOFNAME]
		END$;
	            %
THIS ROUTINE APPENDS THE NAME BLOCK POINTED TO BY "ELT" ONTO PPNLIST,
IF THE NAME BLOCK IS NOT ALREADY ON PPNLIST.  NOTE THAT ADDRESSES, NOT
PPNS, ARE ADDED TO THE LIST.
	            %
ROUTINE APPEND(ELT)=
	BEGIN REGISTER P,EMPTYSLOTPTR; MAP STRNAME ELT;
	INITSCAN(PPNLIST<ADDR>);  EMPTYSLOTPTR_0;
	UNTIL (P_NEXTITEM(PPNLIST<ADDR>)) EQL 0
	    DO
	        BEGIN
	        IF @.P EQL 0 THEN EMPTYSLOTPTR_.P;
		IF PPNEQUAL THEN RETURN;		!USER ALREADY ON LIST
	        END;
	IF .EMPTYSLOTPTR NEQ 0
	    THEN ((.EMPTYSLOTPTR)<0,36>_.ELT; PPNLIST[ITEMCOUNT]_.PPNLIST[ITEMCOUNT]+1)
	    ELSE ALLOCATE(PPNLIST<ADDR>)<0,36>_.ELT;
	END;

	            %
THE REMOVE RTN REMOVES THE PPN FROM THE LIST OF PPN'S PASSED TO IT.
	            %
ROUTINE REMOVE(ELT)=
	BEGIN REGISTER P; MAP STRNAME ELT;

!THE FOLLOWING LIST CONSISTS OF PPN'S WHICH MAY BE TOLD MESSAGES, EVEN
!THOUGH THEIR PROJECT APPEARS IN THE NEVER-TELL LIST. THUS, IF PROJECT
!5 HAS 30 PPN'S IN IT, AND ONLY 2 OF THEM SHOULD RECEIVE MESSAGES,
!YOU WOULD PUT #5777777 IN NTELL, AND THE 2 NUMBERS WHICH MAY RECEIVE
!MESSAGES HERE IN DTELL.
	BIND DTELL=PLIT(#6000010);

	INITSCAN (PPNLIST<ADDR>); 
	UNTIL (P_NEXTITEM(PPNLIST<ADDR>)) EQL 0
	DO
	    IF PPNEQUAL
		THEN
		    BEGIN
		    IF .NEVREM
		      THEN
			BEGIN
			INCR J FROM 0 TO .DTELL[-1]-1
			  DO
			    IF .ELT[PPNOFNAME] EQL .DTELL[.J]
				THEN RETURN;	!RETURN IF SHOULD TELL PPN ANYWAY
!EDIT-2
			IF .IAMBATCH THEN TYPECHR("??");
			TYPE('%You can''t TELL ');
			P3_TTYTYPE<ADDR>;
			PPNPRINT(.ELT[PPNOFNAME]);
			TYPE('?M?J');
			END;
		    (.P)<0,36>_0;
		    PPNLIST[ITEMCOUNT]_.PPNLIST[ITEMCOUNT]-1;
		    END;
	END;
	                %
THIS ROUTINE PRINTS A NAME OR PPN.  THE ARGUMENT IS THE ADDRESS OF THE
3 WORD BLCCK CONTAINING THE INFORMATION (I.E. NAME+FLAGS,PPN+MASK+FLAGS,
OR NAME+PPN).  IF THE 3 WORD BLOCK IS IN THE HIGH SEGMENT, IT IS ASSUMED
TO BE IN THE FORMAT NAME+PPN.  IF IT IS IN THE LOW SEGMENT, THE FLAGS
IN THE THIRD WORD (SEE STRNAME STRUCTURE) ARE BELIEVED
***DESTROYS P1 - P3*** 
	                %
GLOBAL ROUTINE TYPNMB(NAME)=
BEGIN
MAP STRNAME NAME; MAP STRNAME P1:P2;

	!THE EQUAL ROUTINE RETURNS 1 IF THE NAMES POINTED TO BY P1 AND
	!P2 ARE THE SAME NAME BUT ARE ACTUALLY DIFFERENT USERS (ALWAYS
	!IF INDPPN=1, IF DIFFERENT PROJECT NUMBERS IF INDPPN=0)
	ROUTINE EQUAL=
	IF .P1[NM1] EQL .P2[NM1]
	    THEN IF .P1[NM2] EQL .P2[NM2]
		THEN
	            IF NOT INDPPN   !IF PROGRAMMER NUMBERS UNIQUELY DESCRIBE A PPN
	                THEN IF .P1[PROGNUMOFNAME] EQL .P2[PROGNUMOFNAME]
	                    THEN 0
	                    ELSE 1
			ELSE 1	   !INDPPN=1, SO PRINT [PJ,PN]
		ELSE 0
	    ELSE 0;


P3_TTYTYPE;			!POINT PRINT NAME AT TTY
IF .NAME<17,1> NEQ 0            !CHECK FOR HISEG ADDRESS
    THEN
	BEGIN REGISTER T; T_0;
	PRINTNAME(.NAME);
	P1_.NAME; 
	IF .NAME LSS .NAMEND
	    THEN (P2_.NAME+3; IF EQUAL() THEN T_1);
	IF .NAME GTR .NAMETABLE
	    THEN (P2_.NAME-3; IF EQUAL() THEN T_1);
	IF .T NEQ 0 THEN PPNPRINT(.NAME[PPNOFNAME]);
	END
    ELSE                      !NOT A HIGH SEG ADDRESS, BELIEVE THE STUFF IN FLAGS
	BEGIN
	IF .NAME[PPNFLAG]
	    THEN MASKPPNTYPE(.NAME)
	    ELSE
	        BEGIN
	        PRINTNAME(.NAME);
	        IF .NAME[GROUPFLAG]
	            THEN TYPE ('(a group name)');
	        END;
	END;
END;
	                %
ROUTINE TO PRINT A PPN SPECIFICATION IN A SMART MANNER.  THE ARGUMENT
IS A THREE WORD BLOCK WITH PPN/MASK IN THE FIRST TWO WORDS (I.E.
PPNFLAG IS ON IN THE THIRD WORD).
	                %

ROUTINE MASKPPNTYPE(NAME)=
BEGIN MAP STRNAME NAME;
REGISTER N,MSK;

ROUTINE RECURSE=
	BEGIN LOCAL REM;
	REM _ IF .MSK MOD #10 NEQ 0 THEN "??" ELSE  (.N MOD #10)+"0";
	N _ .N / #10; MSK _ .MSK / #10;
	IF (.N+.MSK) NEQ 0 THEN RECURSE();
	TYPECHR(.REM);
	END;

TYPECHR("[");
N_.NAME[PROJNUM]; MSK_.NAME[PROJMASK];
IF .MSK EQL #777777 THEN TYPECHR("*")
	             ELSE RECURSE();
TYPECHR(",");
N_.NAME[PROGNUM]; MSK_.NAME[PROGMASK];
IF .MSK EQL #777777 THEN TYPECHR("*")
	             ELSE RECURSE();
TYPECHR("]");
END;


