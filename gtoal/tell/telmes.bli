MODULE TELMES(RESERVE(4,5,6))=
BEGIN

REQUIRE DSK:TELPRM.BLI;


				%
THIS MODULE HANDLES THE MESSAGE COMMAND.  IT PRINTS MAIL BELONGING TO
THE USER.
				%

OWN	MESSAGES,		!1 IF SOME FOUND, 0 IF NONE
	EARLYDATE,		!EARLIEST DATE IN MESSAGE FILE
	QUERYING,		!-1 IF IN DIALOG MODE.  NEEDED SO WE DON'T
				!TRY TO CLEAR TTY IF NO TTY INPUT
	EOFMAILFILE,		!1 IF END-OF-FILE FROM MAIL FILE, 0 IF OK
	FORWARDED,		!1 IF WE FORWARDED MAIL
	TYPED,			!1 IF WE TYPED THIS MESSAGE, 0 IF NOT
	HEADTYPED,		!1 IF WE TYPED MESSAGE HEADER
	OTHERMAIL,		!OTHER KIND OF MAIL EXISTS (HOLD/NON-HOLD)
	ONHOLD,			!AT LEAST ONE MESSAGE IS ON HOLD
	COPIEDFIRST,		!-1 IF WE HAVE COPIED FIRST BUFFER INTO FIRSTBLOCK
	SAVEDMESSAGES,		!-1 IF SOME MESSAGES HAVE BEEN SAVED, 0 IF NOT
	MAILHEADSIZE,		!LH: 0 RH: NUMBER OF WORDS IN HEADER OF MAIL FILE
	MAILSIZE,		!LH: NUMBER OF HEADER WORDS
				!RH: SIZE OF MESSAGE INCLUDING HEADER WORDS
	SAVEJOBFF,		!PLACE TO PUT JOBFF BEFORE DOING CORE ALLOCATION
	OUTBUFH[3],		!OUTPUT BUFFER HEADER
	INBUFH[3],		!INPUT BUFFER HEADER
	FIRSTBLOCK[128],	!COPY OF FIRST BLOCK OUTPUT TO MESSAGE FILE
				!SO WE CAN RE-OUTPUT FIRST BLOCK AFTER EARLIEST DATE ETC.
				!KNOWN WITHOUT REREADING IT
	MLINES,			!HOW MANY LINES THIS MESSAGE IS
	EXITNOW;		!SET IF SHOULD TYPE NO MORE MESSAGES.

EXTERNAL
	RESCAN,READSPEC,HLPAFQ,HLPBFQ,
	PRTNM,PRTSTR,PRTSXB,
	MYNAME,
	YES,			!ROUTINE TO ACCEPT A YES OR A NO
	LERERROR,		!PRINTS LOOKUP/ENTER/RENAME ERRORS
	STRFILE FILESPEC,	!FILE SPEC BLOCK
	COPYSPEC,		!COPY OF FILESPEC FOR COPY FILE
	ERR,ERRC,ERRFIN,	!ERROR ROUTINES
	SENDERPPN,		!WHO SENT THE MESSAGE (ALSO USED BY TELL)
	MAILFLAGS,		!FLAGS CONCERNING MAIL
	TELLCOMMAND,		!TO TELL PEOPLE THINGS
	MTCHNM,			!ROUTINE TO FIND COMMAND IN TABLE
	PRTDEC,PRTOCT,
	SIXREAD,		!READS A COMMAND IN SIXBIT
	PRTNM,			!ROUTINE TO PRINT USER NAME
	FLAGWORD,		!ALL GLOBAL FLAGS LIVE HERE
	ALLOCATE,		!GET SOME STORAGE
	NEXTITEM,		!SCAN LIST ROUTINE
	INITSCAN,		!INITIALIZES LISTHEADER TO DO A SCAN
	CLREOL,			!CLEAR-TO-END-OF-LINE
	TTYTYPE,		!TTY OUTPUT ROUTINE
	SWITCHRTN,		!ROUTINE TO PARSE SWITCHES
	MAILSPEC,		!ROUTINE TO RETURN MAIL FILE SPECIFICATION
	OPENSPEC,		!ROUTINE TO OPEN A FILE
	CHARBSU,		!ROUTINE TO READ ONE CHARACTER (BSU FORMAT)
	DATEMESSAGE,		!DATE MESSAGE IS TO BE DELIVERED
	PPNSEARCH,		!ROUTINE TO FIND PPN IN HIGH SEG TABLE
	MYPPN,			!MY PROJECT-PROGRAMMER NUMBER
	NOW,			!IN UNIVERSAL DATE-TIME FORMAT
	CHKACC,			!ROUTINE TO CHECK FILE ACCESS
	DEFPROT,		!DEFAULT FILE PROTECTION
	TEXTLIST,		!LIST CONTAINING MESSAGE TEXT
	PPNLIST;		!LIST CONTAINING PPN'S MAIL IS TO BE SENT TO (FOR FORWARDING)

GLOBAL	DISPOPTION;		!WHAT TO DO WITH MAIL (SEE DISPOSETABLE FOR INDICES)

MAP	STRCOREBLK TEXTLIST:PPNLIST;


FORWARD	READHEADERINFO,GETFILE,PRINTMESSAGE,READWD,PUTWD,FIXUP,TYPEHEADER,CALLTELL,
	READMESSAGE,OUTERROR,CHECKERR,SAVEMESSAGE,OUTPUTMESSAGE,ASKSEE;

MACRO	HOLDFLAG=MAILFLAGS<35,1>$,
	UNREADFLAG=MAILFLAGS<34,1>$;
			%
THIS IS THE TOP LEVEL OF THE MESSAGE COMMAND.  FIRST ACTION IS TO READ ANY
SWITCHES, UNTIL END-OF-LINE IS REACHED.
			%

GLOBAL ROUTINE MESSAGECOMMAND=
BEGIN MAP STRCHAR P1;

DO
    BEGIN
    P1_CHARBSU();
    IF .P1[CLASS] EQL SLASH
	THEN SWITCHRTN();
    END
UNTIL
    .P1[CLASS] EQL EOF OR .P1[CLASS] EQL EOL;

MESSAGES_0;				!ASSUME NO MESSAGES (SET BY PRINTMESSAGE)
ONHOLD_0;				!NO MESSAGES ON HOLD
OTHERMAIL_0;				!ASSUME NO "OTHER" MAIL (HELD MAIL IF NO /HOLD
					!UNHELD MAIL IF /HOLD)
EOFMAILFILE_0;				!NO END OF FILE YET
EARLYDATE_BIGGEST;			!ANYTHING IS SMALLER THAN THIS
SAVEDMESSAGES_0;			!HAVEN'T SAVED ANY MESSAGES YET
EXITNOW_0;				!TYPE HIS MESSAGES FOR HIM!

!MAIN LOOP:  READ USER MAIL FILE.


MAILSPEC(.MYPPN);			!GET MAIL SPECIFICATION FOR ME
FILESPEC[FILESTATUS]_#400000000010; FILESPEC[FILEBUFS]_INBUFH<ADDR>;
IF OPENSPEC(1)				!IS THERE A MAIL FILE?
    THEN
	BEGIN				!YES, READ IT
	READHEADERINFO();		!READ THE INFORMATION IN FILE HEADER
	UNTIL .EOFMAILFILE		!KEEP READING TILL EOF IS REACHED
	  DO
	    BEGIN REGISTER SAVE,TYPEIT;
	    SAVEJOBFF_@JOBFF;		!SAVE STORAGE USED BY READMESSAGE ETC.
	    MLINES_READMESSAGE();	!GET A MESSAGE
	    TYPEIT_0;			!ASSUME WE DON'T TYPE
	    IF .HOLDPRINT		!PRINT MAIL ON HOLD OR NORMAL
		THEN
	    	    IF .HOLDFLAG	!PRINT MAIL ON HOLD, IS IT
			THEN TYPEIT_1
			ELSE 
			    (IF .DATEMESSAGE LEQ .NOW
				THEN OTHERMAIL_1)
		ELSE
		    IF .HOLDFLAG	!PRINT NORMAL MAIL, IS THIS ON HOLD?
			THEN OTHERMAIL_1
			ELSE
			    IF .DATEMESSAGE LEQ .NOW
				THEN TYPEIT_1;
	    IF .UNREAD			!IF /UNREAD...
	      THEN
		IF NOT .UNREADFLAG	!AND THIS MESSAGE HAS BEEN READ
		    THEN TYPEIT_0;	!THEN DON'T TYPE THIS MESSAGE
	    IF .EXITNOW THEN TYPEIT_0;
	    SAVE _ IF .TYPEIT 
		THEN PRINTMESSAGE()
		ELSE 1;
	    IF .HOLDFLAG AND .SAVE THEN ONHOLD_1;
	    IF .SAVE THEN SAVEMESSAGE();
	    JOBFF<0,36>_.SAVEJOBFF;	!RECLAIM SPACE THAT WAS USED
	    IF .SAVE LSS 0 THEN EXITNOW_1;
	    END;
	FIXUP();			!REWRITE BLOCK 0 WITH INFO WE NOW KNOW
	CLOSE(DSK);			!PREVENT ADDRESS CHECKS!
	END;

IF .OTHERMAIL				!ANY MESSAGES SUPPRESSED?
    THEN
	IF .HOLDPRINT			!FIGURE OUT WHICH MESSAGE
	    THEN TYPE('[You have messages not on hold]?M?J')
	    ELSE TYPE('[You have messages on hold]?M?J')
    ELSE IF .MESSAGES EQL 0
	THEN TYPE('[You don''t have any messages]?M?J');

!IF COMPATIBLE IS ON, DO A RUN UUO DO SYS:MESSAG TO PRINT OLD STYLE MESSAGES
!IF ANY
IF COMPATIBLE					!WITH V3 AND EARLIER...
    THEN
	BEGIN					!SEE IF ANY EARLIER MESSAGES
	LOCAL ARGBLOCK[7];
	ARGBLOCK[0]_ARGBLOCK[2]_0;
	ARGBLOCK[1]_SIXBIT 'DSK';
	IFSKIP OPEN(DSK,ARGBLOCK)		!IT BETTER SKIP
	  THEN
	    BEGIN
	    ARGBLOCK[0]_6; ARGBLOCK[1]_.MYPPN; ARGBLOCK[2]_SIXBIT 'MESSAG';
	    ARGBLOCK[3]_SIXBIT 'TXT'; ARGBLOCK[4]_ARGBLOCK[5]_ARGBLOCK[6]_0;
	    IFSKIP LOOKUP(DSK,ARGBLOCK)
	      THEN
		BEGIN
		IF .ARGBLOCK[6] LSS .NOW
		  THEN
		    BEGIN
		    ARGBLOCK[0]_SIXBIT 'SYS'; ARGBLOCK[1]_SIXBIT 'MESSAG';
		    ARGBLOCK[2]_ARGBLOCK[3]_ARGBLOCK[4]_ARGBLOCK[5]_0;
		    RUN(ARGBLOCK<ADDR>);
		    END;
		END;
	    END;
	END;
END;
			%
ROUTINE TO READ THE HEADER INFORMATION FROM THE  USERS MAIL FILE.  
WHAT IS READ IS ALSO COPIED TO THE OUTPUT FILE.
			%

ROUTINE READHEADERINFO=
BEGIN
!FIRST OPEN THE OUTPUT SIDE OF THE CHANNEL
FILESPEC[FILEBUFS]_OUTBUFH<ADDR>^18;
FILESPEC[ERRORCODE]_FILESPEC[PROTWORD]_0; FILESPEC[PROTECTION]_MAILPROT;
FILESPEC[SFDPTR] _ IF .FILESPEC[SFDLIST] EQL 0
			THEN .FILESPEC[FILEPPN]
			ELSE FILESPEC[FILEPPN]<ADDR>-3;
IFSKIP OPEN(MES,FILESPEC[FILESTATUS])
    THEN
	IFSKIP ENTER(MES,FILESPEC[FILENAME])
	    THEN %OK%
	    ELSE (ERRORC(HARD,'EFM ENTER'); LERERROR(); ERRFIN())
    ELSE
	ERROR (HARD,'OMD Can''t OPEN mail device');
IFSKIP OUT(MES) THEN OUTERROR();	!SET UP INITIAL BUFFERS
COPIEDFIRST_0;				!HAVEN'T COPIED FIRST BUFFER


IFSKIP IN(DSK) THEN CHECKERR();		!READ FIRST BUFFER, CHECK FOR NULL FILE
MAILHEADSIZE_READWD();			!NUMBER OF WORDS IN HEADER
PUTWD(.MAILHEADSIZE);
DECR J FROM .MAILHEADSIZE<RH> TO 1
    DO (READWD(); PUTWD(0));		!WRITE OUT 0'S.  THIS WILL BE FIXED UP LATER
PUTWD(READWD());        		!FLAG WORD
END;




			%
ROUTINE TO CLEAR TO END OF LINE.  THIS ROUTINE DOES NOTHING IF WE
WEREN'T IN DIALOG MODE, OTHERWISE IT CALLS CLREOL TO EAT THE REST 
OF THE LINE THE USER TYPED.
			%
ROUTINE CLRLINE=
IF .QUERYING LSS 0 THEN CLREOL();
			%
ROUTINE TO PRINT USERS MESSAGES ON TTY OR OTHER DEVICE
THE MESSAGE IS ASSUMED TO BE IN TEXTLIST.  THIS ROUTINE RETURNS 1 IF MAIL
IS TO BE SAVED (I.E. COPIED TO THE USERS MAIL FILE)
 0 IF IT CAN BE DELETED.  HOLDFLAG WILL BE SET IF APPROPRIATE.
			%

BIND DISPOSETABLE=PLIT(
SIXBIT 'HELP',
SIXBIT 'TYPE',
SIXBIT 'SAVE',
SIXBIT 'HOLD',
SIXBIT 'REPLY',
SIXBIT 'DELETE',
SIXBIT 'FORWAR',
SIXBIT 'COPY',
SIXBIT 'EXIT');
ROUTINE PRINTMESSAGE=
BEGIN

REGISTER T,INDEX;
MESSAGES_1;					!HE DOES INDEED HAVE MESSAGES...
FORWARDED_HEADTYPED_TYPED_T_UNREADFLAG_0;	!HAVEN'T TYPED THE MESSAGE YET...
REPEAT						!ONLY WAY OUT IS THROUGH A RETURN 0/1
	BEGIN
	QUERYING_0;				!ASSUME NOT IN DIALOG MODE
	INDEX _					!WHAT WE ARE SUPPOSED TO DO
	    IF .TYPED EQL 0			!TYPED THE MESSAGE YET?
		THEN				!HAVEN'T TYPED THE MESSAGE
		    IF .QUERYBEFORE		!QUERY BEFORE TYPING?
			THEN			!YES, PRINT HEADER FOR USERS
			    BEGIN		!EDIFICATION BEFORE PROMPTING
			    TYPEHEADER();	!PRINT USER NAME, MAIL SIZE
			    TYPE ('Action:'); T_SIXREAD(); QUERYING_-1;
			    IF .T EQL 0 
			        THEN QBDFLT	!NO COMMAND, USE DEFAULT
				ELSE IF .T EQL SIXBIT 'H'
				    THEN 0
			            ELSE MATCHNAME(.T,DISPOSETABLE)
			    END
			ELSE
			    IF .MLINES GTR MAXLINES
			      THEN
				IF ASKSEE()
				  THEN
				    QBDFLT
				  ELSE
				    BEGIN
				    TYPE('Action:'); T_SIXREAD(); QUERYING_-1;
				    IF .T EQL 0
					THEN QBDFLT
					ELSE IF .T EQL SIXBIT 'H'
					    THEN 0
					    ELSE MATCHNAME(.T,DISPOSETABLE)
				    END
			    ELSE QBDFLT
		ELSE
		    IF .QUERYAFTER		!TYPED MESSAGE, ASK WHAT TO DO?
			THEN
			   BEGIN
			   TYPE('Dispose:'); T_SIXREAD(); QUERYING_-1;
			   IF .T EQL 0
				THEN (IF .HOLDFLAG THEN 3 ELSE .DISPOPTION)
				ELSE IF .T EQL SIXBIT 'H'
				    THEN 0
				    ELSE MATCHNAME(.T,DISPOSETABLE)
			   END
			ELSE (IF .HOLDFLAG THEN 3 ELSE .DISPOPTION);

	CASE .INDEX+2 OF SET
    %-2%		(CLRLINE(); TYPE('Ambiguous command, type HELP for help?M?J'));

    %-1%		(CLRLINE(); TYPE('Unknown command, type HELP for help?M?J'));

    %0 HELP%		(TYPEADR(IF .TYPED THEN HLPAFQ ELSE HLPBFQ); CLRLINE());

    %1 TYPE%		(P3_TTYTYPE<ADDR>; OUTPUTMESSAGE(); CLRLINE(); TYPED_-1);

    %2 SAVE%		(CLRLINE(); HOLDFLAG_0; DATEMESSAGE_.NOW;  RETURN 1);

    %3 HOLD%		(CLRLINE(); HOLDFLAG_1; DATEMESSAGE_BIGGEST; RETURN 1);

    %4 REPLY%		(HAVEMESSAGE_0; CALLTELL(.SENDERPPN));

    %5 DELETE%		(CLRLINE(); RETURN 0);

    %6 FORWARD%		(HAVEMESSAGE_1; CALLTELL(0); HAVEMESSAGE_0);

    %7 COPY%		IF GETFILE(.T)
			    THEN
				BEGIN
				OUTPUTMESSAGE();
				RELEASE(CFILE);
				P3_TTYTYPE<ADDR>;
				IF .T EQL 0 THEN RETURN 0;
				END;

    %8 EXIT%		(CLRLINE(); RETURN -1);
    TES;
	END;
END;

ROUTINE ASKSEE=
BEGIN
	IF .HEADTYPED THEN RETURN 0; HEADTYPED_1;
	TYPE('%Message is ');
	P3_TTYTYPE<ADDR>;
	PRINTDEC(.MLINES);
	TYPE(' lines. Do you want to see it (Y or N)??');
	RETURN YES()
END;
			%
ROUTINE TO PRINT MESSAGE HEADER.  PRINTS THE FIRST LINE OF THE MESSAGE
(WHICH IS PRESUMABLY FROM <NAME> ON <DATE> AT <TIME>), THEN THE
NUMBER OF LINES IN THE MESSAGE.
			%

ROUTINE TYPEHEADER=
BEGIN
	REGISTER C,T;
	LABEL LOOP;

IF .HEADTYPED THEN RETURN; HEADTYPED_1;
INITSCAN(TEXTLIST);
P3_TTYTYPE<ADDR>;				!GO TO TTY
LOOP:
UNTIL (T_NEXTITEM(TEXTLIST)) EQL 0
DO
    BEGIN
    T<LH>_0<36,7>^(-18);			!BUILD A BYTE POINTER IN T
    DECR J FROM 5 TO 1 DO			!5 CHARS/WORD
	BEGIN
	C_SCANI(T);				!ONE OF THE CHARACTERS
	TYPECHR(.C);
	IF .C EQL #12
	    THEN LEAVE LOOP;			!IF TYPED FIRST LINE, QUIT
	END;
    END;
TYPECHR("["); PRINTDEC(.MLINES); TYPE (' lines]?M?J');
END;




			%
ROUTINE TO OUTPUT MESSAGE SOMEWHERE.  REGISTER P3 IS ASSUMED TO HAVE
THE ADDRESS OF AN OUTPUT ROUTINE (DISK/TTY).
			%

ROUTINE OUTPUTMESSAGE=
BEGIN REGISTER T;

PRINT('?M?J');					!SEPARATE MESSAGES WITH A BLANK LINE
INITSCAN(TEXTLIST);
UNTIL
    (T_NEXTITEM(TEXTLIST)) EQL 0
DO
    BEGIN
    T<LH>_0<36,7>^(-18);			!BUILD BYTE POINTER
    DECR J FROM 5 TO 1				!CHARS/WORD
	DO PRINTCHR(SCANI(T));			!OUTPUT IT WHEREVER
    END;
END;
			%
ROUTINE TO READ MESSAGE FROM MAIL FILE.
THE MESSAGE IS READ AND STORED IN ITS ENTIRETY IN "TEXTLIST".  THE HEADER
INFORMATION IS STORED AS FOLLOWS:
MAILSIZE	LH: # WORDS IN MAIL HEADER RH: # WORDS IN MAIL FILE INCLUDING HEADER
DATEMESSAGE	DATE (UNIVERSAL DATE/TIME FORMAT) WHEN MESSAGE IS TO BE DELIVERED
SENDERPPN	THE PPN OF THE PERSON WHO SENT THE MAIL (USED IN REPLY OPTION)
MAILFLAGS	FLAGS CONCERNING MAIL
			%

ROUTINE READMESSAGE=
BEGIN
	LOCAL WORD,POINTER,MESLINES;



DO MAILSIZE_READWD() UNTIL .MAILSIZE<RH> NEQ 0;	!SIZE INFO
DATEMESSAGE_READWD();				!DELIVERY DATE
SENDERPPN_READWD();				!PPN WHO SENT MAIL
MAILFLAGS_READWD();				!FLAGS ABOUT MAIL
DECR J FROM .MAILSIZE<LH>-3 TO 1		!READ REST OF HEADER WHICH SHOULDN'T BE THERE
    DO READWD();				!JUST FOR EASE IN ADDING MORE INFO IF DESIRED

INITSTORAGE(TEXTLIST,1,128);			!PLACE TO PUT THE MESSAGE ITSELF
MESLINES_0;
DECR J FROM .MAILSIZE<RH>-.MAILSIZE<LH> TO 1
    DO
	BEGIN
	ALLOCATE(TEXTLIST)<0,36>_WORD_READWD();
	POINTER_WORD<36,7>;
	DECR I FROM 5 TO 1
	  DO
	    IF SCANI(POINTER) EQL #12
		THEN MESLINES_.MESLINES+1;
	END;
RETURN .MESLINES
END;
			%
ROUTINE TO OUTPUT A MESSAGE TO USER'S MAIL FILE.  MESSAGE IS ASSUMED TO BE
IN TEXTLIST; HEADER INFO SET UP IN THE APPROPRIATE PLACE.
			%

GLOBAL ROUTINE SAVEMESSAGE=
BEGIN

SAVEDMESSAGES_-1;				!YES WE DID SAVE A MESSAGE
IF .DATEMESSAGE LSS .EARLYDATE
    THEN EARLYDATE_.DATEMESSAGE;

PUTWD(3^18+.TEXTLIST[ITEMCOUNT]+3);		!OUTPUT SIZE OF MESSAGE
PUTWD(.DATEMESSAGE);				!DATE OF MESSAGE
PUTWD(.SENDERPPN);				!WHO SENT IT
PUTWD(.MAILFLAGS);				!DESCRIPTION OF MAIL
INITSCAN(TEXTLIST);				!SCAN THE MESSAGE ITSELF


UNTIL (P1_NEXTITEM(TEXTLIST)) EQL 0
DO PUTWD(@.P1);
END;
			%
ROUTINE TO SAVE EVERYTHING VALUABLE AND CALL TELL. THIS IS USED IN REPLY
AND FORWARD OPTIONS.  ARGUMENT IS THE PPN TO WHOM WE ARE TO SEND THE MESSAGE;
0 IF MAIL IS BEING FORWARDED.  (IF 0, THEN THE LINE [FORWARDED FROM...]
IS APPENDED TO THE END).
			%

ROUTINE CALLTELL(RECEIVEPPN)=
BEGIN LOCAL SAVEIT[3],COPYHEADER[HEADERSIZE];

!EDIT 226--ALWAYS MUST SAVE TEXT HEADER, IN CASE THIS IS A REPLY
P1<LH>_TEXTLIST<ADDR>; P1<RH>_COPYHEADER<ADDR>; 
BLT (P1,COPYHEADER<ADDR>+HEADERSIZE-1);
IF .RECEIVEPPN EQL 0			!FORWARDING?
    THEN
	BEGIN OWN BP;
	ROUTINE ADDCHR=(IF .BP<30,6> LEQ 1 
			    THEN (BP_ALLOCATE(TEXTLIST); BP<LH>_0<36,7>^(-18));
			REPLACEI(BP,.P1));
	!KLUDGE -- COPY LIST HEADER SO AFTER MESSAGE FORWARDED CAN
	!GET RID OF [FORWARDED FROM ...]
	BP _ 0; P3 _ ADDCHR<ADDR>;
	PRINT('[Forwarded from '); PRINTNAME(MYNAME<ADDR>); PRINT(']?M?J');
	END;

!NOW SAVE ALL MESSAGE ATTRIBUTES (WHICH MIGHT GET ZAPPED BY TELL)
SAVEIT[0]_.MAILFLAGS;
SAVEIT[1]_.SENDERPPN;
SAVEIT[2]_.DATEMESSAGE;
INMESSAGE_1;				!TELL TELL THAT WE ARE IN MESSAGE
TELLCOMMAND(.RECEIVEPPN);
INMESSAGE_0;				!CLEAR THE BIT TO BE NEAT
MAILFLAGS_.SAVEIT[0];
SENDERPPN_.SAVEIT[1];
DATEMESSAGE_.SAVEIT[2];

!NOW COPY LIST HEADER BACK.  THIS EFFECTIVELY FORGETS ABOUT
!THE [FORWARDED FROM ...] LINE AT THE BOTTOM
P1<LH>_COPYHEADER<ADDR>; P1<RH>_TEXTLIST<ADDR>;
BLT (P1,TEXTLIST<ADDR>+HEADERSIZE-1);
END;
			%
ROUTINE TO FIX UP THE MAIL FILE NOW THAT WE ARE DONE.  THIS CONSISTS OF 
DELETING THE FILE (IF THERE ARE NO MESSAGES), OR REWRITING THE FIRST
BLOCK (NOW THAT WE KNOW THE EARLIEST MESSAGE DATE).
			%

ROUTINE FIXUP=
BEGIN
MACRO	BUFFERDATE=(.OUTBUFH+3)<0,36>$,		!PLACE WITHIN BUFFER OF DATE
	FILEFLAGS=(.OUTBUFH+4+2*NSENDER)$;	!FLAGS PERTAINING TO FILE

IF .SAVEDMESSAGES EQL 0
    THEN
	BEGIN					!NO MESSAGES , DELETE FILE
	FILESPEC[FILENAME]_FILESPEC[EXTENSION]_0;
	IFSKIP RENAME(MES,FILESPEC[FILENAME])
	    THEN %OK%
	    ELSE ERROR(SOFT,'DMF Can''t delete mail file');
	END
    ELSE
	BEGIN					!STILL WANT FILE, SO DON'T DELETE
	IF .COPIEDFIRST NEQ 0			!HAVE WE DONE AN OUTPUT?
	    THEN				!YES, THEN FIRST BLOCK WAS SAVED
	    BEGIN
	    IFSKIP OUT(MES) THEN OUTERROR();	!OUTPUT THE LAST BLOCK
	    USETO(MES,1);			!SET TO REWRITE THE LAST BLOCK
	    P1<LH>_FIRSTBLOCK; P1<RH>_.OUTBUFH+2;
	    BLT(P1,(.OUTBUFH+2)+127);		!COPY BLOCK TO BUFFER
	    END;
	BUFFERDATE_.EARLYDATE;			!SET DATE WITHIN THE BUFFER
	ANYONHOLD_.ONHOLD;
	MORESENDERS_0;

!***SET NAMES OF USERS WHO ARE SENDING MAIL TO THIS GUY???***
	IFSKIP OUT(MES) THEN OUTERROR();	!WRITE FIRST (MAYBE ONLY) BLOCK
	END;
RELEASE(MES);
END;
BIND	OUTBUFCNT=(OUTBUFH+2)<0,36>,
	OUTPTR=(OUTBUFH+1)<0,36>,
	INBUFCNT=(INBUFH+2)<0,36>,
	INBUFPTR=(INBUFH+1)<0,36>;


				%
ROUTINE TO READ ONE WORD FROM THE MAIL FILE.  THIS ROUTINE DIFFERS FROM
THE RUN-OF-THE-MILL INPUT ROUTINE IN THAT IT SETS END-OF-FILE WHEN
THE LAST WORD IS RETURNED (RATHER THAN RETURNING SOME SPECIAL VALUE
TO INDICATE END OF FILE).  IF IT IS CALLED WITH THE EOF FLAG SET, IT RETURNS 0.
				%

ROUTINE READWD=
IF .EOFMAILFILE					!SEEN EOF?
    THEN 0					!YES RETURN 0
    ELSE
	(REGISTER T;				!NOT EOF, WE HAVE A WORD
	T_@(INBUFPTR_.INBUFPTR+1);		!GET THE WORD TO RETURN
	 IF (INBUFCNT_.INBUFCNT-1) LEQ 0	!BUFFER NOW EMPTY?
	    THEN
		IFSKIP IN(DSK)			!YES GET ANOTHER
		    THEN CHECKERR();		!COULDN'T. SEE IF EOF OR ERROR
	.T);



				%
THIS IS A RUN-OF-THE-MILL OUTPUT ROUTINE.  IT SHOVES ITS ARGUMENT INTO
THE OUTPUT BUFFER, WHICH GETS WRITTEN IF IT IS FULL.
THE FIRST TIME A BUFFER IS WRITTEN IT IS COPIED TO FIRSTBLOCK.  THIS IS SO WE
CAN REWRITE THE FIRST BLOCK WITHOUT REREADING IT.  (WE COULD DO A USETO TO THE
SECOND BLOCK OF THE FILE, AND NOT WRITE THE FIRST, BUT THIS PROBABLY ISN'T MUCH
FASTER AND IN THE EVENT THE SYSTEM CRASHES BEFORE WE HAVE CALLED FIXUP, THE FIRST
BLOCK CONTAINS GARBAGE).
				%

ROUTINE PUTWD(WORD)=
BEGIN

UNTIL (OUTBUFCNT_.OUTBUFCNT-1) GEQ 0
    DO
	BEGIN
	IF .COPIEDFIRST EQL 0		!HAVE WE DONE AN OUTPUT YET?
	    THEN
		BEGIN			!NO, FIRST OUTPUT.  COPY BUFFER
		COPIEDFIRST_-1;		!SAY WE DID THE COPY
		P1<LH>_.OUTBUFH+2; P1<RH>_FIRSTBLOCK<ADDR>;
		BLT(P1,FIRSTBLOCK+127);
		END;
	IFSKIP OUT(MES)
	    THEN OUTERROR();
	END;
OUTPTR_.OUTPTR+1;
(.OUTPTR)<0,36>_.WORD;
END;


!ROUTINE TO PRINT ERROR MESSAGE IF ERROR READING FILE
ROUTINE CHECKERR=
BEGIN
EOFMAILFILE_1;				!IN ANY EVENT ASSUME EOF
GETSTS(DSK,P1);			!GET ERROR BITS
IF (.P1 AND #740000) NEQ 0
    THEN
	(ERRORC(SOFT,'IRM Input error status ');PRINTOCTAL(.P1); TYPE(' reading mail file'); ERRFIN());
END;

ROUTINE OUTERROR=
BEGIN
GETSTS(MES,P1);			!GET ERROR BITS
ERRORC(SOFT,'OWM Output error status ');
PRINTOCTAL(.P1);
TYPE(' writing mail file');
ERRFIN()
END;
				%
THIS ROUTINE OPENS THE "COPY" FILE, SO THAT THE USER CAN KEEP A COPY OF
HIS MESSAGE (IF IT REALLY IS IMPORTANT TO HIM)
PARAMETER 'TYPEDFLAG' IS NON-0 IF THE USER ACTUALLY TYPED 'COPY' IN
RESPONSE TO DISPOSE QUESTION. IF IT 0, COPY IS DEFAULT DISPOSE OPTION.
				%

FORWARD OUTCOPY,SETUP;
OWN OUTCOPYBUF[3],INCOPYBUF[3],AFLAG,BLOCKNO;
MACRO	OUTCOPYPNT=(OUTCOPYBUF+1)<0,36>$,
	OUTCOPYCNT=(OUTCOPYBUF+2)<0,36>$;
ROUTINE GETFILE(TYPEDFLAG)=
BEGIN REGISTER STRCHAR C;
	OWN TEMP;

IF .TYPEDFLAG NEQ 0
    THEN
	BEGIN
	DO C_CHARBSU() UNTIL .C[CLASS] NEQ BLANK;
	IF .C[CLASS] EQL EOF OR .C[CLASS] EQL EOL
	    THEN TYPE ('Copy to file:')
	    ELSE RESCAN(.C[ASCII]);
	READSPEC();				!GET THE FILE SPECIFICATION
	IF .DOTFLAG EQL 0 THEN FILESPEC[EXTENSION]_SIXBIT "MAI";
	CLREOL();				!IGNORE JUNK FOLLOWING FILE SPEC
	END
    ELSE
	BEGIN REGISTER S;
	IF .QUERYING THEN CLREOL();
	S<LH>_COPYSPEC<0,0>; S<RH>_FILESPEC<0,0>;
	BLT(S,FILESPEC+13);
	END;
FILESPEC[FILEBUFS]_OUTCOPYBUF<ADDR>^18+INCOPYBUF<ADDR>; FILESPEC[FILESTATUS]_0;
IFSKIP OPEN(CFILE,FILESPEC[FILESTATUS])
    THEN
	BEGIN
	TEMP_.FILESPEC[SFDPTR];
	AFLAG_0;			!SHOULD NOT APPEND
	IFSKIP LOOKUP(CFILE,FILESPEC[FILENAME])
	    THEN (AFLAG_1; BLOCKNO_-EXTENDLH(FILESPEC[6]))
	    ELSE FILESPEC[PROTECTION]_.DEFPROT;	!KLUDGE UP BLOCK IF NO FILE
	IF NOT CHKACC(2,CFILE)
	    THEN (ERROR(SOFT,'MNW You may not write that file');RETURN 0);
	FILESPEC[SFDPTR]_.TEMP;
	IFSKIP ENTER(CFILE,FILESPEC[FILENAME])
	    THEN (P3_OUTCOPY<ADDR>; SETUP())
	    ELSE (ERRORC(SOFT,'EFC ENTER'); LERERROR(); 0)
	END
    ELSE
	(ERRORC(SOFT,'OFC OPEN failure device'); PRINTSIXBIT(.FILESPEC[FILEDEVICE]); ERRFIN(); 0)
END;



			%
THIS IS  A BYTE-OUT ROUTINE FOR USE WITH GETFILE.  IF THE USER HAS SPECIFIED
AN OUTPUT FILE, P3 CONTAINS THE ADDRESS OF THIS ROUTINE
ON CALL, P1 WILL CONTAIN THE CHARACTER TO SHOVE IN THE OUTPUT BUFFER.
			%

ROUTINE OUTCOPY=
BEGIN
IF (OUTCOPYCNT_.OUTCOPYCNT-1) LEQ 0
    THEN IFSKIP OUT(CFILE)
	THEN ERROR(SOFT,'OWC Output error writing COPY file');
REPLACEI(OUTCOPYPNT,.P1)			!SHOVE THE BYTE OUT
END;

ROUTINE SETUP=
BEGIN REGISTER T;

ROUTINE GETWD=
BEGIN
	UNTIL (INCOPYBUF[2]_.INCOPYBUF[2]-1) GEQ 0
	    DO IFSKIP IN(CFILE)
		THEN ERROR(SOFT,'ERC input error reading copy file');
	RETURN SCANI(INCOPYBUF[1])
END;

ROUTINE STORWD(WORD)=
BEGIN
	UNTIL (OUTCOPYCNT_.OUTCOPYCNT-1) GEQ 0
	    DO IFSKIP OUT(CFILE)
		THEN ERROR(SOFT,'OWC output error writing copy file');
	REPLACEI(OUTCOPYPNT,.WORD)
END;

	IF NOT .AFLAG THEN RETURN 1;
	T_DEVCHR(CFILE);
	IF NOT .T<19,1> THEN RETURN 1;	!OUTPUT ONLY?
	T_.BLOCKNO/128;			!T IS LAST BLOCK
	IF .BLOCKNO MOD 128 NEQ 0
	  THEN
	    BEGIN
	    USETI(CFILE,1,T);		!POINT TO LAST BLOCK
	    IFSKIP IN(CFILE) THEN RETURN 0;
	    USETO(CFILE,1,T);		!AND REWRITE IT
	    DECR I FROM 5*(.BLOCKNO MOD 128) TO 1
		DO STORWD(GETWD());	!STORE WORDS
	    END
	  ELSE
	    (USETO(CFILE,1,T); OUTCOPYCNT_0);
	RETURN 1			!INDICATE SUCCESS
END;
