MODULE TELCOM(RESERVE(4,5,6))=
BEGIN

REQUIRE DSK:TELPRM.BLI;
GLOBAL   STRCOREBLK TELLIST,     !PEOPLE TO TELL IN UNEXPANDED FORM
         STRCOREBLK TEXTLIST,    !HEADER FOR MESSAGE TEXT
	 EXPECTING,		!SET IF MORE NAMES ARE EXPECTED ON THE NEXT LINE
	 MAILFLAGS,		 !FLAGS TO SET UP TO DESCRIBE MAIL (IF CALLER HAS MESSAGE)
	 DATEMESSAGE,		 !DATE TO DELIVER MESSAGE
	 SENDERPPN;		 !PPN OF SENDER (NORMALLY MYPPN, BUT NOT IF FORWARDING)


EXTERNAL ALLOCATE,      !ROUTINE TO ALLOCATE STORAGE
         NEXTITEM,      !ROUTINE TO SCAN DYNAMIC LIST
	 INITSCAN,	!INITIALIZE FOR SCAN OF LIST
	 MTCHNM,PRTSXB,
	 MYPPN,		!YOU GUESSED IT...
	 CLREOL,	!ROUTINE TO CLEAR TO END OF LINE
	 FILESPEC,      !ADDRESS OF A BLOCK WHERE OPEN/LOOKUP BLOCKS LIVE
	 ZEROSPEC,	!ROUTINE TO ZERO FILESPEC
	 TYPNMB,        !ROUTINE TO PRINT USER NAME IN A FANCY WAY
	 PRTNM,	        !FANCY NAME PRINT ROUTINE, DOESN'T WORRY ABOUT PPN
	 DAY,MONTH,YEAR,TIME,NOW,WEEKDAY,
	 PPNPRINT,	!PRINTS A PPN
	 PRTSTR,        !OUTPUT A STRING
         RESCAN,        !ROUTINE TO CAUSE CHARACTER TO BE RE-READ
         ERR,ERRC,ERRFIN,	!ERROR ROUTINES
	 PPNLIST,       !LIST HEADER OF NAME POINTERS RECOGNIZED BY SEARCH CODE
	 FAILLIST,      !LIST HEADER OF NAME POINTERS NOT RECOGNIZED
	 PPNSEARCH,	!ROUTINE TO SEARCH FOR PPN'S
	 NAMESEARCH,	!ROUTINE TO RETURN ALL PPN'S EQUIVALENT TO NAME
	 NEVTEL,	!ROUTINE TO REMOVE A LIST OF PPN'S FROM PPNLIST
	 SAVEMESSAGE,	!ROUTINE IN MESSAGE TO SAVE MAIL IN USERS FILE
         YES,           !ROUTINE TO RETURN 1 OR 0 FOR YES OR NO
	 YESCHECK,	!EDIT-1 AS ABOVE BUT ONLY ACCEPT YES OR NO REPLY
	 FLAGWORD,      !LOTS OF MULTI-COLORED FLAGS
	 LERERROR,      !ROUTINE TO PRINT LOOKUP/ENTER/RENAME ERRORS
	 TYPEFILE,      !ROUTINE TO PRINT FILE SPEC
	 PRTOCT,PRTDEC, !OUTPUT ROUTINES
         CHARBSU,	!ROUTINE TO GET ONE CHAR IN BSU FORMAT
	 NEXTCHAR,      !NEXT CHARACTER IN ASCII WITH NO FRILLS
	 MYNAME,        !MY NAME (IN SIXBIT, TWO WORDS)
	 MYJOB,		!MY JOB NUMBER
         SWITCHRTN;     !GENERAL SWITCH PROCESSOR

FORWARD	TELLPARSE,NAMEPARSE,DATE,MAILSPEC,READMESSAGE,SENDMAIL,COPYRESTOFLINE;
FORWARD TELLHIM;

			!IT IS THE STATE TO START IN IF TO SCAN DATE

MAP	STRFILE FILESPEC,
	STRCOREBLK PPNLIST,
	STRCOREBLK FAILLIST;
OWN	NAMEERROR,PROMPT;
                            %
THIS IS THE TOP LEVEL OF THE TELL COMMAND (GET HERE IF KNOW FOR SURE THAT
THIS IS "TELL"; INPUT STREAM POINTS TO PERSON TO TELL).

OPTIONALLY THE PPN TO SEND THIS MAIL TO CAN BE  SPECIFIED; IF THIS IS DESIRED
THE ARGUMENT RECEIVEPPN SHOULD BE THE PPN TO SEND THE MAIL TO.  IF TEXT EXISTS,
THE FLAG "HAVEMESSAGE" SHOULD BE SET ON CALL AND THE TEXT SHOULD BE IN "TEXTLIST".
THE VARIABLE SENDERPPN SHOULD BE THE PPN OF THE SENDER MESSAGE.  THE
VARIABLES DATEMESSAGE AND MAILFLAGS WILL BE ZAPPED.


THE BASIC FLOW IS:
PARSE THE TELL COMMAND AND INTERPRET THE DATE.  THE LIST OF USERS TO SEND
TO WILL BE IN "TELLIST" IN ESSENTIALLY THE FORMAT THE USER TYPED, I.E. A
NAME (TWO WORDS IN SIXBIT, WHICH MAY BE A GROUP NAME) OR A PPN (FIRST WORD
IS SPECIFIED PART OF PPN, SECOND IS MASK).  THIS LIST IS EXPANDED INTO A
LIST OF JUST PPN'S (INTERPRETING GROUP NAMES, WILD CARDS, ETC.) IN PPNLIST.
DURING THIS THE USER MAY BE QUERIED TO RESOLVE AMBIGUITIES IN NAMES.
USING PPNLIST, THE MAIL IS SENT.  IF ANY ERRORS OCCURRED (COULDN'T SEND MAIL,
ETC.) THE USER IS QUERIED TO SEE IF HE WANTS TO SEND THE MAIL TO SOMEONE ELSE.
                            %

GLOBAL ROUTINE TELLCOMMAND(RECEIVEPPN)=
BEGIN
REGISTER STRNAME T;
LABEL   TELL,GETUSERS;

INITSTORAGE(PPNLIST,1,10);			!INITIALIZE LIST OF PPNS TO SENT TO
INITSTORAGE(TELLIST,3,30);			!PEOPLE TO TELL
IF NOT .HAVEMESSAGE				!IF WE DON'T HAVE THE MESSAGE
    THEN SENDERPPN_.MYPPN;			!THIS HASN'T BEEN SET UP
IF .RECEIVEPPN NEQ 0				!DO WE HAVE A PPN TO SEND TO?
   THEN
	BEGIN					!YES, ADD HIM TO LIST
	T_ALLOCATE(TELLIST);			!GET SOME SPACE
	T[NM1]_.RECEIVEPPN; T[NM2]_T[NAMEFLAGS]_0;
	T[PPNFLAG]_1;				!MAKE LOOK LIKE A PPN ENTRY
	PROMPT_0				!DON'T PROMPT
	END
    ELSE
	PROMPT_1;				!FORCE PROMPT
DATEERROR_ITOLD_COPIED_0;			!CLEAR THE WORLD
INDIRECTOK_1;					!ALLOW INDIRECT TELLS
MAILFLAGS_#200000000000;			!"UNREAD" FLAG ONLY
DATEMESSAGE_.NOW;				!NEEDED IF FORWARDING MAIL
!HERE TO FIND ALL USERS WHO WE WISH TO TELL.  THERE ARE SEVERAL CASES:
!1) THE NORMAL CASE IS FROM A TELL COMMAND, WITH POTENTIALLY A LIST
!   OF USERS ON THE SAME LINE AS THE TELL COMMAND.  THE MAIN LOOP
!   IS "GETUSERS".  TELLPARSE WILL RETURN ALL NAMES (POTENTIALLY NONE)
!   THAT ARE ON THE CURRENT LINE, UP TO A CHARACTER WHICH TERMINATES SCAN.
!   THE TERMINATING CHARACTER CAN BE A LINE FEED, AN INVALID CHARACTER, OR
!   A SPACE FOLLOWING A VALID LIST OF NAMES.  SINCE THE USER MAY HAVE TYPED
!   THE BEGINING OF HIS MESSAGE ON THE SAME LINE AS THE TELL <LIST> WE CALL
!   COPYRESTOFLINE TO READ THE START OF HIS MESSAGE AND STORE IT IN AN
!   INTERNAL BUFFER.  THEN WE SCAN THE LIST OF NAMES THE USER TYPED,
!   CONVERTING THEM INTO POINTERS TO THE APPROPRIATE NAME/PPN BLOCK IN THE
!   HIGH SEGMENT (THIS IS PPNLIST).  FINALLY, IF ALL NAMES WERE OK, WE
!   ACTUALLY HAVE SOMEBODY TO TELL, AND A + OR - WAS NOT SEEN AT EOL
!   (THE EXPECTING FLAG), THEN WE LEAVE THE GETUSERS LOOP.  THIS HAS THE
!   FOLLOWING EFFECTS: AN EMPTY LINE IMMEDIATELY PROMPTS WHO? (TELLPARSE
!   IS CALLED, WHICH RETURNS NOTHING IN TELLIST, AND SO PPNLIST IS EMPTY TOO.)
!   IF A LINE IS TERMINATED BY A + OR -, AND THEN A <CR> IS HIT AFTER
!   WHO ELSE? IS TYPED, THE MESSAGE IS ASKED FOR (BECAUSE EXPECTING ALWAYS GETS
!   RESET).  FINALLY, IF THE USER SCREWED A NAME, AND DECIDES HE DIDN'T WANT
!   TO TELL THE GUY ANYWAY, HE CAN JUST TYPE <CR> TO GET TO THE MESSAGE PORTION.
!   (NAMEERROR IS ALSO ALWAYS CLEARED).
!2) ANOTHER CASE IS WHEN WE ENTER BECAUSE MAIL IS BEING FORWARDED.  THIS IS
!   VERY SIMILIAR, EXCEPT THAT WE ALREADY HAVE A MESSAGE (FLAG HAVEMESSAGE)
!   IS SET.  HENCE WE WILL NEVER CALL READMESSAGE (ALTHOUGH WE MAY CALL
!   COPYRESTOFLINE, BUT THE TEXT WE COPIED IS LOST).
!3) THE THIRD CASE IS WHEN WE ARE REPLYING TO MAIL ALREADY SENT.  THEN THE
!   ARGUMENT RECEIVEPPN IS NON-ZERO.  THE PPN WE ARE TO REPLY TO IS ADDED
!   TO TELLIST (SO WE CAN MAKE SURE USER IS STILL ON SYSTEM); THE PROMPT
!   FLAG GETS SET TO ZERO (SO WON'T TYPE WHO).  HOWEVER IF ANY NAMES ARE
!   ON THE SAME LINE AS THE REPLY COMMAND, MAIL GETS SENT TO THEM TO.

TELL:						!OUTER LOOP FOR SENDING SAME MESSAGE
    REPEAT					!ONLY JUMP OUT IF NO ERRORS
	BEGIN
	GETUSERS:				!INNER LOOP IS TO FETCH USER NAMES
	  REPEAT				!ONLY GET OUT BY LEAVE
	    BEGIN
	    EXPECTING_0;			!EXPECTING IS SET BY NAMEPARSE IF +- AT EOL
	    TELLPARSE(.PROMPT);			!GO SEE IF ANYBODY TO TELL
	    DATE();				!INTERPRET DATE IF ANY
	    IF .COPIED				!HAVE WE ALREADY GOT FIRST LINE OF TEXT?
		THEN CLREOL()			!YES, THROW AWAY THIS ONE (TOO BAD...)
		ELSE COPYRESTOFLINE();		!NO COPY IT SO IF ERROR IT IS STILL THERE
	    NAMEERROR_0;			!NO INCORRECT NAMES
	    INITSCAN(TELLIST);			!LIST OF PEOPLE TO TELL
	    UNTIL (T_NEXTITEM(TELLIST)) EQL 0	!SCAN LIST TILL EMPTY
	    DO
		NAMEERROR_.NAMEERROR OR
		(IF .T[PPNFLAG] THEN PPNSEARCH ELSE NAMESEARCH)(.T,2);
	    NEVTEL();				!REMOVE PPN'S THAT ARE ON THE NEVER-TELL LIST
	    IF NOT .NAMEERROR AND NOT .EXPECTING AND .PPNLIST[ITEMCOUNT] GTR 0
		THEN LEAVE GETUSERS;		!IF EVERYTHING OK, EXIT
!EDIT-2 IN TELL LOOP
	    IF .IAMBATCH THEN (TYPECHR("??"); LEAVE TELL);	!DO NOTHING JUST EXIT
	    RESCAN(#12);			!RESCAN LINEFEED.  THIS FORCES TELLPARSE
	    PROMPT_1;				!TO PROMPT WHO?
	    INITSTORAGE(TELLIST,3,30);		!CLEAR LIST OF PEOPLE TO TELL
	    END;
	WHILE .DATEERROR DO (TYPE ('When??'); RESCAN("("); DATE(); CLREOL());
	IF NOT .HAVEMESSAGE THEN READMESSAGE();	!IF MESSAGE NOT COMPLETED YET, GET IT
	


!AT THIS POINT WE HAVE THE MESSAGE AND THE LIST OF PPN'S (IN PPNLIST) TO TELL.
!GO THROUGH PPNLIST AND SEND THE MESSAGE TO EACH ONE OF THEM

	INITSCAN(PPNLIST);			!GET READY TO SCAN PPNLIST
	INITSTORAGE(FAILLIST,3,30);		!LIST OF PEOPLE WE COULDN'T TELL
	UNTIL (T_NEXTITEM(PPNLIST)) EQL 0	!GRAB A USER TO TELL
	DO 
	    IF @.T NEQ 0 THEN SENDMAIL(@.T);	!SEND THE MAIL.  THE ENTRY IN PPNLIST MAY BE
						!ZERO IF WE DELETED A PPN ("-" SOMEBODY)
	IF .ITOLD THEN TYPE('?M?J');		!IF WE TOLD SOMEBODY, OUTPUT THE CRLF TO BE NEAT

!AT THIS POINT WE GO THROUGH FAILLIST, WHICH HAS ALL THE PPN'S WE COULDN'T TELL,
!FOR ONE REASON OR ANOTHER...


	INITSCAN(FAILLIST);
	IF (T_NEXTITEM(FAILLIST<0,0>)) NEQ 0
           THEN
	        BEGIN
!EDIT-2
		IF .IAMBATCH THEN TYPECHR("??"); !ADD AN ERROR FLAG
	        TYPE ('I couldn''t TELL ');
	        TYPNMB(@T);
	        UNTIL
		    (T_NEXTITEM(FAILLIST<0,0>)) EQL 0
	        DO
		    (TYPECHR(","); TYPNMB(@T));
		TYPE('?M?J');
	        END;
	IF .FAILLIST[ITEMCOUNT] EQL 0 THEN LEAVE TELL;
!EDIT-2 IN TELL:
	IF .IAMBATCH THEN LEAVE TELL;
	IF .IAMSMART
	    THEN TYPE('Others??')
	    ELSE TYPE('Send same message to other users??');
!EDIT-1 USE YES CHECK TO ENSURE A LONG MESSAGE DOESNOT GET LOST ACCIDENTALLY
	IF NOT YESCHECK() THEN LEAVE TELL;
	RESCAN(#12);			!GET A LF.  THIS FORCES NAMEPARSE TO TYPE WHO?
	INITSTORAGE(TELLIST,3,30);		!NOBODY TO TELL
	INITSTORAGE(PPNLIST,1,10);
        END;
END;
			%
THIS ROUTINE PARSES THE LIST OF NAMES THAT THE USER TYPED ON A TELL COMMAND.
IT ESSENTIALLY CALLS NAMEPARSE TO GET THE LIST OF NAMES AND ISSUES PROMPTS
AT APPROPRIATE TIMES.  WHEN THIS ROUTINE RETURNS, THE CHARACTER WHICH TERMINATED
THE NAME SCAN WILL BE RETURNED THE NEXT TIME CHARBSU IS CALLED; TELLIST WILL
HAVE THIS LIST OF NAMES THAT THE USER TYPED IN SIXBIT (OR OCTAL, IN THE CASE
OF A PPN).
    PROMPT IS 1 IF WE SHOULD ISSUE A PROMPT (WHO?/WHO ELSE?).  THIS HAPPENS
MOST OF THE TIME, BUT NOT IF WE DON'T KNOW FOR SURE WHETHER MORE NAMES ARE COMING.
			%


GLOBAL ROUTINE TELLPARSE(PROMPT)=
BEGIN
REGISTER STRCHAR C;

	IF .PROMPT NEQ 0
	  THEN				!ISSUE PROMPT ON LINE FEED
		BEGIN
		C_CHARBSU();			!GET CURRENT CHARACTER
		IF .C[CLASS] EQL EOF OR .C[CLASS] EQL EOL
		    THEN 			!NEED A PROMPT
!EDIT-2
			BEGIN
			IF .IAMBATCH THEN TYPECHR("??");  !ADD AN ERROR SIGN
			IF (IF .INWHO THEN .TELLIST[ITEMCOUNT] ELSE .PPNLIST[ITEMCOUNT]) EQL 0
			    THEN TYPE ('Who??')
			    ELSE TYPE('Who else??');
			END
		    ELSE RESCAN(.C[ASCII]);	!NOT EOL, MIGHT BE GOOD CHAR
		END;
	NAMEPARSE();			!GET LIST OF NAMES INTO TELLIST.  RETURNS
					!ON ANY STRANGE CHAR, INCLUDING SLASH, EOL
	C_CHARBSU();			!CHAR WHICH TERMINATED SCAN
	IF .C[CLASS] NEQ SLASH		!WAS IT A SWITCH DELIMITER?
	    THEN (RESCAN(.C[ASCII]); RETURN); !NO, LET TOP LEVEL DECIDE WHAT TO DO
	SWITCHRTN();			!CALL THE SWITCH PROCESSOR
	C_CHARBSU();			!GET LAST CHARACTER
	RESCAN(.C[ASCII]);		!MAKE SURE CALLER SEES IT
END;
			%
THIS ROUTINE PARSES A LIST OF USER NAMES.  IT IS CALLED FROM TELLPARSE ABOVE
AND FROM THE SWITCH.INI PROCESSOR.  IT APPENDS ANY NAMES IT ENCOUNTERS ONTO
TELLIST (PPN'S TOO, OF COURSE).  IT RETURNS WHEN IT SEES A CHARACTER THAT
IS NOT VALID; IT IS UP TO THE CALLER TO DECIDE WHAT TO DO WITH THE CHARACTER.
THE FLAG "EXPECTING" IS SET TO 1 IF A "+" OR "-" IS SEEN JUST BEFORE EOL;
IF THIS IS SET THE CALLER PROBABLY WANTS TO ISSUE A PROMPT AND RE-ENTER THIS
ROUTINE.
			%

GLOBAL ROUTINE NAMEPARSE=
BEGIN

REGISTER    STATE,
	    CHARCNT,
            STRCHAR C;

OWN         NUMBER,PROJNUMANDMASK,BP,TEMP[2],DELETE,MASK;

BIND        STATETRANSITION=PLIT(
!   BL  A-Z 0-9  /   (   )   *   +-  ,   =   [   ]   :   .   ?      EOL EOF
X (  0,  1,  2, 63, 63, 63,  2,  0,  1, 63,  2,  0, 63,  1,  2, 63, 63, 63),	!0 -- SCAN FOR NAME OR PPN
X (  6,  1,  1, 63, 63, 63, 63,  0,  1, 63, 63, 63, 63,  1, 63, 63, 63, 63),	!1 -- CONCATENATE USER NAME
X (  6,  1,  2, 63, 63, 63,  2,  0,  3, 63, 63, 63, 63, 63,  2, 63, 63, 63),	!2 --BUILD PROJECT NUMBER
X (  3,  1,  4, 63, 63, 63,  5,  0,  0, 63, 63, 63, 63, 63,  4, 63, 63, 63),	!3 -- HAVE SEEN "," IN PPN
X (  6,  1,  4, 63, 63, 63,  5,  0,  0, 63, 63,  5, 63, 63,  4, 63, 63, 63),	!4 -- BUILD PROGRAMMER NUMBER
X (  6,  1,  2, 63, 63, 63,  2,  0,  0, 63,  2,  5, 63,  1,  2, 63, 63, 63),	!5 --MAYBE MORE COMING
X (  6, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63));	!6 -- DELETE LEADING BLANKS

!ROUTINES TO BE EXECUTED
BIND	NL=0,		!DO NOTHING
	CC=1,		!CONCATENATE ONE CHARACTER OF NAME
	MO=2,		!MULTIPLY OCTAL (AS IN PROJ/PROG #)
	SJ=3,		!HANDLE "*" IN PROECT NUMBER
	SG=4,		!HANDLE "*" IN PROGRAMMER NUMBER
	QM=5,		!HANDLE "?"
	PN=6,		!PROCESS NAME
	PP=7,		!PROCESS PPN
	FG=8,		!FLAG "+" OR "-"
	XF=9;		!COPY PROJECT # SO CAN BUILD PROGRAMMER #


!ACTION TABLE FOR STATE TRANSITION (SEE ROUTINES ABOVE)
BIND ACTIONTABLE=PLIT(
!   BL  A-Z 0-9  /   (   )   *   +-  ,   =   [   ]   :   .   ?      EOL EOF
X ( NL, CC, MO, NL, NL, NL, SJ, FG, CC, NL, NL, NL, NL, CC, QM, NL, NL, NL),	!0
X ( PN, CC, CC, PN, PN, PN, PN, PN, CC, PN, PN, PN, PN, CC, PN, PN, PN, PN),	!1
X ( PN, CC, MO, PN, PN, PN, SJ, PN, XF, PN, PN, PN, PN, PN, QM, PN, PN, PN),	!2
X ( NL, CC, MO, PN, PN, PN, SG, PN, PN, PN, PN, PN, PN, PN, QM, PN, PN, PN),	!3
X ( PP, PP, MO, PP, PP, PP, SG, PP, PP, PP, PP, PP, PP, PP, QM, PP, PP, PP),	!4
X ( NL, CC, MO, NL, NL, NL, SJ, FG, NL, NL, NL, NL, NL, CC, QM, NL, NL, NL),	!5
X ( NL, NL, NL, NL, NL, NL, NL, NL, NL, NL, NL, NL, NL, NL, NL, NL, NL, NL));	!6
ROUTINE SCANINI=
    BEGIN
    NUMBER_TEMP[0]_TEMP[1]_0;  CHARCNT_12;  DELETE_0;  BP_(TEMP-1)<0,6>;
    MASK_0;
    END;

ROUTINE FLAGIT=
	BEGIN
	IF .C[ASCII] EQL "+" OR .C[ASCII] EQL "-"
	    THEN EXPECTING_1			!IF EXPECTING SOMETHING, FLAG IT
	    ELSE EXPECTING_0;			!OTHERWISE DON'T REENTER NAMEPARSE
	DELETE _ IF .C[ASCII] EQL "-" THEN 1 ELSE 0
	END;

STATE_0;			!START IN STATE 0
SCANINI();

UNTIL .STATE EQL 63             !63 IS ESCAPE TO TOP LEVEL STATE
    DO
        BEGIN
        C_CHARBSU();            !NEXT CHARACTER FROM INPUT STREAM (BSU FORMAT)
        CASE
	    ACTION (ACTIONTABLE,STATE,C[CLASS])
        OF
            SET
            %0 - NL%    ;

            %1 - CC%    IF (CHARCNT_.CHARCNT-1) GEQ 0
                            THEN REPLACEI(BP,.C[ASCII]-#40);

            %2 - MO%    BEGIN
                        IF (CHARCNT_.CHARCNT-1) GEQ 0
                            THEN REPLACEI(BP,.C[ASCII]-#40);
                        NUMBER_.NUMBER*#10 + .C[ASCII] - #60;
	                MASK _ .MASK * #10;
			IF .NUMBER<LH> NEQ 0 THEN IF .STATE EQL 2 THEN STATE_4;
                        END;

            %3 - SR%    MASK_-1;

	    %4 - SG%	BEGIN REGISTER STRNAME NAMEBLOCK;
			NAMEBLOCK_ALLOCATE(TELLIST);
			NAMEBLOCK[PPNFLAG]_1; NAMEBLOCK[DELFLAG]_.DELETE;
			NAMEBLOCK[NM1]_.PROJNUMANDMASK<LH>^18;
			NAMEBLOCK[NM2]_.PROJNUMANDMASK<RH>^18+#777777;
			SCANINI(); FLAGIT();
			END;

	    %5 - QM%	BEGIN
			MASK_.MASK*#10+7; NUMBER_.NUMBER*#10;
			END;

            %6 - PN%    BEGIN REGISTER NAMEBLOCK; MAP STRNAME NAMEBLOCK;
                        NAMEBLOCK_ALLOCATE(TELLIST);
                        NAMEBLOCK[PPNFLAG]_0;
                        NAMEBLOCK[DELFLAG]_.DELETE;
                        NAMEBLOCK[NM1]_.TEMP[0]; NAMEBLOCK[NM2]_.TEMP[1];
                        SCANINI(); FLAGIT();
                        END;

            %7 - PP%    BEGIN REGISTER NAMEBLOCK; MAP STRNAME NAMEBLOCK;
                        NAMEBLOCK_ALLOCATE(TELLIST);
                        NAMEBLOCK[PPNFLAG]_1;
                        NAMEBLOCK[DELFLAG]_.DELETE;
%
Note that for ease with communicating with ARPA sites (which don't allow
commas in user-ids) a programmer number with non-zero left half
is regarded as a PPN. This allows unique user ids (without any non-numeric
characters)
%
			IF .NUMBER<LH> EQL 0 THEN 
			    BEGIN
                            NAMEBLOCK[NM1]_.PROJNUMANDMASK<18,18>^18+.NUMBER<0,18>;
                            NAMEBLOCK[NM2]_.PROJNUMANDMASK<0,18>^18+.MASK<0,18>;
			END ELSE (NAMEBLOCK[NM1]_.NUMBER; NAMEBLOCK[NM2]_.MASK);
                        SCANINI(); FLAGIT();
                        END;

	    %8 - FG%	FLAGIT();

	    %9 - XF%	BEGIN
			PROJNUMANDMASK<LH>_.NUMBER; PROJNUMANDMASK<RH>_.MASK;
			NUMBER_MASK_0;
			END
            TES;
	STATE_ACTION(STATETRANSITION,STATE,C[CLASS]);
        END;
RESCAN(.C[ASCII]);
END;
BIND MONTAB=PLIT(
PLIT ASCIZ 'January',
PLIT ASCIZ 'February',
PLIT ASCIZ 'March',
PLIT ASCIZ 'April',
PLIT ASCIZ 'May',
PLIT ASCIZ 'June',
PLIT ASCIZ 'July',
PLIT ASCIZ 'August',
PLIT ASCIZ 'September',
PLIT ASCIZ 'October',
PLIT ASCIZ 'November',
PLIT ASCIZ 'December');


BIND DAYSFROMSTART=PLIT(		!TABLE OF DAYS FROM START OF YEAR
0,					!JANUARY
31,					!FEBRUARY
31+28,					!MARCH
31+28+31,				!APRIL
31+28+31+30,				!MAY
31+28+31+30+31,				!JUNE
31+28+31+30+31+30,			!JULY
31+28+31+30+31+30+31,			!AUGUST
31+28+31+30+31+30+31+31,		!SEPTEMBER
31+28+31+30+31+30+31+31+30,		!OCTOBER
31+28+31+30+31+30+31+31+30+31,		!NOVEMBER
31+28+31+30+31+30+31+31+30+31+30);	!DECEMBER

BIND MONTHLENGTH=PLIT(			!LENGTH OF MONTHS
31,					!JAN
28,					!FEB
31,					!MAR
30,					!APRIL
31,					!MAY
30,					!JUNE
31,					!JULY
31,					!AUGUST
30,					!SEPTEMBER
31,					!OCTOBER
30,					!NOVEMBER
31);					!DECEMBER
			%
DATE HANDLING ROUTINE.  THIS ROUTINE DECODES THE DATE THE MESSAGE IS TO
BE DELIVERED.  IT CONVERTS WHAT THE USER TYPED (IN A VARIETY OF FORMATS)
TO UNIVERSAL DATE-TIME SPECIFICATION.
			%

OWN	MESDAY,		!DAY HE WANTS MESSAGE DELIVERED
	MESMON,		!MONTH
	MESYR,		!YEAR
	MESTIME;	!MINUTES SINCE MIDNIGHT




ROUTINE DATE=
BEGIN

OWN	STATE,			!STATE WITHIN DATEPARSE
	DATESTATE,		!STATE WITHIN DATETOKEN
	TOKEN;			!RETURNED BY DATETOKEN



			%
THE DATE PARSE LOGIC IS BUILT AROUND TWO INDEPENDENT STATE TABLES AND A
CASE STATEMENT.

THE FIRST STATE TABLE IS IN THE ROUTINE DATETOKEN.  THE FUNCTION OF 
DATETOKEN IS TO RETURN THE NEXT LOGICAL ELEMENT OF A DATE, I.E. A
CHARACTER STRING OR A NUMBER.  DATETOKEN WILL LOOK UP CHARACTER
STRINGS IN ITS INTERNAL TABLE AND RETURN THE APPROPRIATE REPRESENTATION.

THE SECOND STATE TABLE IS IN THE ROUTINE DATEPARSE.  THE FUNCTION OF
DATEPARSE IS TO CONCATENATE NUMBERS, MNEMONIC MONTH NAMES, AND TIMES
TO MAKE SOME SENSE OF THEM.  IT UNDERSTANDS (6 12 75) (JUNE 12 75) ETC.
AS WELL AS (HH:MM).

IF A CHARACTER STRING IS RETURNED BY DATETOKEN WHICH IS NOT A MNEMONIC
MONTH, IT IS HANDLED BY THE CASE STATEMENT SEVERAL PAGES HENCE.  THIS
IS USED FOR THINGS LIKE MNEMONIC DATES, WEEKDAYS, ETC.
			%
			%
THIS ROUTINE PLUS THE STATE TABLES BELOW PARSE NORMAL DATE SPECS OF THE
FORM
	MTH DAY YEAR
	DAY MTH YEAR
	MTH
	DAY
	NUMERIC-MONTH DAY YEAR
AS WELL AS TIMES:
	HH:
	HH:MM
WHERE "MTH" IS AN ENGLISH MONTH NAME, I.E. JUNE, AND NUMERIC-MONTH IS A NUMBER,
I.E. 6. FOR THE MOST PART THE DEFAULTS ARE <TODAY> <THIS MONTH> <THIS YEAR>.
HOWEVER IF AN ENGLISH MONTH IS SPECIFIED WITHOUT A DAY, THE DEFAULT DAY IS 1.
			%

MACRO SIX(A,B,C,D,E,F)=
A^30+B^24+C^18+D^12+E^6+F$;
MACRO FETCH(TABLE,ST,CL)=
	.(TABLE[.CL]<ADDR>+.SIXBITBPTAB[.ST])$;


!TRANSITION TABLE FOR PARSING NUMERIC/MNEMONIC MONTHS
!NOTE THAT THIS TABLE IS BACKWARDS FROM MOST IN THAT STATES
!GO ACROSS THE TOP WHILE SYNTACTIC CLASSES ARE VERTICAL

BIND DATETAB=PLIT(
!CLASS		0	1	2	3	4	5
%0-# %    SIX(	1,	2,	2,	2,	0,	5),
%1-#: %   SIX(	4,	4,	4,	4,	5,	5),
%2-MTH %  SIX(	3,	2,	5,	5,	3,	5));

!ACTION TABLE FOR NUMBER/MNEMONIC DATE
BIND DATEACT=PLIT(
!CLASS		0	1	2	3	4	5
%0-# %	  SIX(	1,	2,	3,	1,	5,	8),
%1-#:%	  SIX(  4,	4,	4,	4,	8,	8),
%2-MTH%	  SIX(  6,	7,	8,	8,	7,	8));

ROUTINE DATEPARSE=
BEGIN
CASE FETCH(DATEACT,STATE,TOKEN<RH>) OF SET

	;				!0 DO NOTHING
	MESDAY_.TOKEN<LH>;		!1 A PLAIN NUMBER IS A DATE
	(MESMON_.MESDAY-1; MESDAY_.TOKEN<LH>); !2 BUT IF ANOTHER NUMBER APPEARS
					!THEN FIRST WAS MONTH, THIS THE DATE
	MESYR_.TOKEN<LH>+(IF .TOKEN<LH> GTR 99 THEN 0 ELSE 1900);		!3 YEAR
	MESTIME_.TOKEN<LH>*60;		!4 (HOURS)
	MESTIME_.MESTIME+.TOKEN<LH>;	!5 (MINUTES)
	(MESMON_.TOKEN<LH>; MESDAY_1);	!6 A MONTH BY ITSELF SETS DAY TO 1
	MESMON_.TOKEN<LH>;		!7 BUT MONTH FOLLOWING DAY JUST SETS MONTH
	DATEERROR_1			!8 YOU BLEW IT!
TES;
STATE_FETCH(DATETAB,STATE,TOKEN<RH>)
END;
			%
THIS ROUTINE RETURNS THE NEXT DATE TOKEN, I.E. A STRING OF CHARACTERS OR
A NUMBER.  NUMBERS ARE RETURNED AS IS; CHAR STRINGS ARE LOOKED UP IN
THE TABLE DATEKEYWORD.  THE POSSIBLE TOKENS RETURNED BY THIS ROUTINE ARE
0	A NUMBER (AS IN A DATE)
1	A NUMBER WHICH HAD A ":" IMMEDIATELY FOLLOWING (AS IN A TIME)
2	A MONTH (VALUES FROM 0-11)
3	DAY OF WEEK (0-6 FOR SUNDAY THROUGH SATURDAY)
4	MNEMONIC DAY (TODAY=0, TOMORROW=1, WEEK=2, MONTH=3, YEAR=4)
5	MNEMONIC TIME:
	BREAKFAST 0
	LUNCH	  1
	NOON	  1
	TEA	  3
	DINNER	  4
	MIDNIGHT  5
-1	MEANS END-OF-DATE SPECIFICATION; TOP LEVEL SHOULD EXIT

NOTE THAT "NOISE WORDS" (AND GARBAGE CHARACTERS) ARE IGNORED.
			%
BIND DATEKEYWORD=PLIT(
SIXBIT 'JANUAR',
SIXBIT 'FEBRUA',
SIXBIT 'MARCH',
SIXBIT 'APRIL',
SIXBIT 'MAY',
SIXBIT 'JUNE',
SIXBIT 'JULY',
SIXBIT 'AUGUST',
SIXBIT 'SEPTEM',
SIXBIT 'OCTOBE',
SIXBIT 'NOVEMB',
SIXBIT 'DECEMB',
SIXBIT 'SUNDAY',	!INDEX 12
SIXBIT 'MONDAY',
SIXBIT 'TUESDA',
SIXBIT 'WEDNES',
SIXBIT 'THURSD',
SIXBIT 'FRIDAY',
SIXBIT 'SATURD',
SIXBIT 'TODAY',		!INDEX 19
SIXBIT 'TOMORR',
SIXBIT 'WEEK',
SIXBIT 'MONTH',
SIXBIT 'YEAR',
SIXBIT 'BREAKF',	!INDEX 24
SIXBIT 'LUNCH',
SIXBIT 'NOON',
SIXBIT 'TEA',
SIXBIT 'DINNER',
SIXBIT 'MIDNIG',
SIXBIT 'AFTER',		!INDEX 30: FOLLOWING ARE NOISE
SIXBIT 'SINCE',
SIXBIT 'AT',
SIXBIT 'NEXT');
			%
THIS ROUTINE RETURNS THE NEXT TOKEN, I.E. A STRING RELEVANT TO THE DATE.
END-OF-DATE (-1) IS RETURNED IF NO "(" IS SEEN BEFORE THE FIRST NON-BLANK
CHARACTER.  IF A "(" IS NOT EXPECTED, BUT A DATE IS TO BE PARSED, IT
SHOULD BE DUMMIED UP BY THE CALLER.

NOTE THAT IN MANY CASES THE CHARACTER WHICH TERMINATED AN INPUT SCAN IS
RESCANNED AND HENCE WILL CAUSE THE STATE TABLE TO GO THROUGH TWO TRANSITIONS
FOR THAT PARTICULAR CHARACTER.  THIS MAKES RECOGNIZING "JUN15" EASY, AS WELL
AS "17)".
			%
ROUTINE DATETOKEN=
BEGIN
OWN BP,TEMP,NUMBER;
REGISTER STRCHAR C;

!TRANSITION TABLE
BIND DATEPARSENEXT=PLIT(
!  SP  A-Z  0-9  /   (   )   *  +-   ,   =   [   ]   :   .   ?     EOL  EOF
X ( 0,  63, 63,  0,  1, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63),
X ( 1,   2,  3,  1,  1,  4,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 63, 63),	!1 SCAN TILL ")" OR EOL
X ( 1,   2,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1),	!2 BUILD KEYWORD
X ( 1,   1,  3,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1),	!3 BUILD NUMBER
X ( 4,  63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63));	!4 DELETE BLANKS


!ACTION TABLE:
BIND DATEPARSEACT=PLIT(
!  SP  A-Z  0-9  /   (   )   *  +-   ,   =   [   ]   :   .   ?     EOL  EOF
X (0,   5,   5,  6,  0,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5),	!0
X ( 0,  1,   2,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,  5),	!1
X ( 7,  1,   7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7),	!2
X ( 3,  3,   2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  4,  3,  3,  3,  3,  3),	!3
X ( 0,  5,   5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5));	!4



BP_TEMP<36,6>; TEMP_NUMBER_0;
REPEAT					!ONLY EXIT IS THROUGH RETURN
    BEGIN
    C_CHARBSU();			!GET NEXT CHARACTER
    P1_ACTION(DATEPARSEACT,DATESTATE,C[CLASS]);

    DATESTATE_ACTION(DATEPARSENEXT,DATESTATE,C[CLASS]);
    CASE .P1 OF SET
	0;				!0 -- DO NOTHING
	IF .BP<30,6> NEQ 0 THEN REPLACEI(BP,.C[ASCII]-#40); !1 -- CONCATENATE CHARACTER
	NUMBER_.NUMBER*10+.C[ASCII]-#60; !2 -- BUILD DECIMAL NUMBER
	(RESCAN(.C[ASCII]); RETURN .NUMBER^18+0); !3 -- RETURN NUMBER
	RETURN .NUMBER^18+1;		!4 -- RETURN TIME SPEC
	(RESCAN(.C[ASCII]); RETURN -1);	!5 -- RETURN END-OF-DATE
	SWITCHRTN();			!6 -- PROCESS SWITCHES
	    BEGIN				!7 -- STRING (FIGURE IT OUT)
	    RESCAN(.C[ASCII]);		!WANT TO SEE TERMINATOR AGAIN
	    P1_MATCHNAME(.TEMP,DATEKEYWORD);
	    IF .P1 LSS 0
		THEN
		    BEGIN		! PUBLISH ERROR MESSAGE
		    IF .P1 EQL -1
			THEN ERRORC(SOFT,'UDK Unknown date/time keyword:')
			ELSE ERRORC(SOFT,'ADK Ambiguous date/time keyword:');
		    DATEERROR_1;
		    PRINTSIXBIT(.TEMP); ERRFIN()
		    END
		ELSE			! OK FIGURE OUT WHAT TO DO
		    BEGIN
		    IF .P1 LSS 12	!A MONTH NAME?
			THEN RETURN .P1^18+2; !YES
		    IF .P1 LSS 19	!A WEEKDAY?
			THEN RETURN (.P1-12)^18+3;
		    IF .P1 LSS 24	!MNEMONIC DATE
			THEN RETURN (.P1-19)^18+4;
		    IF .P1 LSS 30	!MNEMONIC TIME?
			THEN RETURN (.P1-24)^18+5;
		    END;		!IF FALL TO HERE, IT IS NOISE
	    TEMP_NUMBER_0; BP_TEMP<36,6>;
	    END;
    TES;
    END;
END;
			%
THIS IS THE TOP LEVEL OF THE DATE PARSE.  SIMPLY CALL DATETOKEN TILL
WE REACH AN END OF DATE SPECIFICATION, HANDLING WHAT WE CAN.  
OCCASIONALLY CALL DATEPARSE TO HANDLE (MM-DD-YR) TYPE CONSTRUCTS.
WHEN DONE CONVERT THE SPECIFIED DATE TO UNIVERSAL DATE-TIME FORMAT
			%

MESDAY_.DAY; MESYR_.YEAR;		!INITIAL VALUES
MESMON_.MONTH; MESTIME_0;		!TILL OVERRIDDEN
STATE_DATESTATE_0;			!INITIALIZE THE SCANNERS
DATEMESSAGE_0;				!NO MESSAGE DATE
DATEERROR_0;				!THE USER HAS NOT BLOWN THE DATE YET...
UNTIL (TOKEN_DATETOKEN()) EQL -1	!SCAN TILL END-OF-DATE
DO
    CASE .TOKEN<RH> OF SET
	DATEPARSE();			!0 NUMBER -- CALL PARSER
	DATEPARSE();			!1 TIME -- CALL PARSER
	DATEPARSE();			!2 MONTH
	DATEMESSAGE<LH> _		!3 WEEKDAY -- FIGURE IT OUT
	    .NOW<LH>+.TOKEN<LH>-.WEEKDAY+
		(IF .TOKEN<LH>-.WEEKDAY LEQ 0 THEN 7 ELSE 0);
	CASE .TOKEN<LH> OF SET		!4 MNEMONIC DATES
		;			!  0 -- TODAY IS WHAT YOU GET
	    DATEMESSAGE<LH>_.NOW<LH>+1;	!  1 -- TOMORROW
	    DATEMESSAGE<LH>_.NOW<LH>+7-.WEEKDAY; !  2--WEEK
	    BEGIN			!  3 -- MONTH
	    IF (MESMON_.MESMON+1) GEQ 12
		THEN (MESMON_1; MESYR_.MESYR+1);
	    MESDAY_1
	    END;

	    (MESYR_.MESYR+1; MESDAY_MESMON_1);  !  4 -- YEAR
	    TES;

	MESTIME_CASE .TOKEN<LH> OF SET	!5 MNEMONIC TIMES
	    8*60;			!  0  BREAKFAST
	    12*60;			!  1  LUNCH
	    12*60;			!  2  NOON
	    16*60;			!  3  TEA
	    20*60;			!  4  DINNER (EUROPEAN)
	    23*60+59			!  5  MIDNIGHT
	    TES;
	TES;				!OUTER CASE STATEMENT
!MAKE SOME GROSS CHECKS ON THE DATE/TIME TO SEE IF OK

IF NOT .DATEERROR
    THEN
	BEGIN
	IF .MESMON GEQ 12
	    THEN (ERRORC(SOFT,'IMS Invalid month in date specification'); DATEERROR_1; ERRFIN())
	    ELSE
		BEGIN REGISTER L;
		L_.MONTHLENGTH[.MESMON] + (IF .MESMON EQL 1 AND (.MESYR MOD 4) EQL 0 THEN 1 ELSE 0);
		IF .MESDAY GTR .L
		    THEN (DATEERROR_1; ERRORC(SOFT,'HAD '); TYPEADR(.MONTAB[.MESMON]);
			  TYPE (' has only '); PRINTDEC(.L); TYPE(' days'); ERRFIN());
		END;
	IF .MESTIME GEQ 24*60 
	    THEN (ERRORC(SOFT,'ITS Invalid time in date/time specification'); DATEERROR_1; ERRFIN());
	END;

!NOW CONVERT THE DATE TO UNIVERSAL DATE TIME FORMAT.  THIS ALGORITHM
!STOLEN FROM THE MANY PREDECESSORS TO THIS PROGRAM.


IF .DATEMESSAGE<LH> EQL 0		!NEQ 0 IF ALREADY KNOW DATE (MNEMONIC SPEC)
    THEN DATEMESSAGE<LH> _
	    (.MESYR*12+46+.MESMON)/48	!LEAP DAYS
	    +.DAYSFROMSTART[.MESMON]	!DAYS IN ALL PRECEDING MONTHES
	    +.MESDAY			!DAYS IN THIS MONTH
	    +.MESYR*365			!DAYS IN ALL PRECEDING YEARS
	    -678957;			!MINUS NOV 17,1858

DATEMESSAGE<RH>_.MESTIME*#1000000*60/86400;
END;
	                %
ROUTINES TO HANDLE READING AND SENDING THE MESSAGE.
	                %

OWN	MAILBLOCKBP,        !BP INTO INTERNAL MESSAGE BUFFER
	MAILWORDFREE;	    !CHARACTERS LEFT IN THIS WORD

	                %
ROUTINE TO STORE ONE CHARACTER IN INTERNAL MESSAGE BUFFER.
THE ADDRESS OF THIS ROUTINE OFTEN LIVES IN REGISTER P3 FOR USE BY THE
"DEVICE" INDEPENDENT OUTPUT ROUTINES.
	                %

ROUTINE STRMAILCHAR=
BEGIN
IF (MAILWORDFREE_.MAILWORDFREE-1) LEQ 0
    THEN
	(MAILWORDFREE_5; MAILBLOCKBP_(ALLOCATE(TEXTLIST))<36,7>);
REPLACEI(MAILBLOCKBP,.P1)
END;
			%
THIS ROUTINE COPIES ANY TEXT WHICH MAY FOLLOW A TELL COMMAND INTO AN INTERNAL
BUFFER.  THIS IS SO THE USER MAY FIX UP WHO HE IS SENDING TO AND THE DATE
ETC. WITHOUT LOSING HIS FIRST LINE.  THE BUFFER IS LIMITED TO 40 WORDS = 200
CHARACTERS; IF YOU DON'T LIKE THIS INCREASE THE BUFFER SIZE!
			%

OWN RESTOFLINE[40];	!PLACE TO STORE THE REST OF THE LINE

ROUTINE COPYRESTOFLINE=
BEGIN OWN COUNT;

P1_NEXTCHAR();			!READ THE CHARACTER WHICH TERMINATED NAME/DATE SCAN
IF .P1 NEQ #12 AND .P1 NEQ #32 AND .P1 NEQ #33
    THEN			!NOT LF, ALTMODE, OR ^Z.  COPY THE LINE
	BEGIN
	INDIRECTOK_0;		!HAVE TEXT CHAR, INDIRECT IS NOT OK
	COPIED_1;		!TELL TOP LEVEL WE DID COPY THE LINE (DON'T TRY AGAIN)
	P2_RESTOFLINE<36,7>;	!A BYTE POINTER INTO RESTOFLINE
	REPLACEI(P2,.P1);	!STORE THIS CHARACTER AWAY IN BUFFER
	COUNT_(40*5)-1;		!CHARS FREE IN BUFFER
	DO
	    (P1_NEXTCHAR();IF (COUNT_.COUNT-1) GTR 0 THEN REPLACEI(P2,.P1))
	UNTIL
	    (.P1 EQL #12 OR .P1 EQL #32 OR .P1 EQL #33);
	REPLACEI(P2,0);		!MAKE SURE THERE IS A ZERO FOR END-OF-TEXT
	END;
END;
			%
ROUTINE TO READ MESSAGE USER TYPES (OR INPUT FROM DISK FILE, IF @ SEEN).
THE MESSAGE GETS STORED IN AN INTERNAL TEXT BUFFER.  WE MAY GET HERE 
WITH THE FIRST LINE ALREADY READ; IF SO "COPIED" IS 1 AND THE TEXT
IS IN RESTOFLINE.
			%

ROUTINE READMESSAGE=
BEGIN REGISTER BP,T;


!THIS ROUTINE RETURNS THE NEXT CHARACTER.  IT GETS THE CHARACTER EITHER
!FROM THE BUFFER "RESTOFLINE" IF THERE IS ANYTHING IN IT, OR FROM THE
!USERS TTY.
ROUTINE GETCHR=
	BEGIN
	IF .COPIED			!ANYTHING IN RESTOFLINE?
	    THEN
		BEGIN			!YES, RETURN NEXT CHARACTER
		P1_SCANI(BP);		!GET THE CHARACTER
		IF .P1 NEQ 0
		    THEN RETURN .P1;	!IF NOT END OF BUFFER, RETURN IT
		COPIED_0;		!INDICATE NOTHING IN BUFFER
		IF NOT .DSKOPEN THEN	!PROMPT ONLY IF READING FROM TTY:
		IF NOT .IAMSMART	!SUPPRESS FOR "INTELLIGIENT?" USERS
		    THEN TYPE ('Enter rest of message, end with ^Z?M?J')
		    ELSE TYPECHR("#");
		END;
	NEXTCHAR()			!GET NEXT CHARACTER USER TYPES
	END;				!AND RETURN THAT


BP_RESTOFLINE<36,7>;			!INITIALIZE BP IN CASE ANYTHING IN BUFFER
INITSTORAGE(TEXTLIST,1,128);		!INTERNAL MESSAGE BUFFER
MAILWORDFREE_0;				!NOTHING IN BUFFER

!OUTPUT THE USER NAME AND HEADER
P3_STRMAILCHAR;				!ROUTINE TO SHOVE IN INTERNAL BUFFER
PRINT ('From ');  PRINTNAME (MYNAME<ADDR>); PPNPRINT(.MYPPN);
PRINT (' on ');  PRINTADR(.MONTAB[.MONTH]);
PRINTCHR(" "); PRINTDEC(.DAY); PRINT(', ');
PRINTDEC(.YEAR); PRINT (' at ');
T _ .TIME; IF .T GTR (12*60) THEN T_.T-(12*60);
PRINTDEC(IF .T/60 EQL 0 THEN 12 ELSE .T/60); PRINTCHR(":"); T_.T MOD 60;  
IF .T LEQ 9 THEN PRINTCHR("0"); PRINTDEC(.T);
IF .TIME GTR (12*60) THEN PRINT(' PM') ELSE PRINT(' AM');
PRINT('?M?J');
IF NOT .DSKOPEN THEN
IF NOT .COPIED THEN
    IF NOT .IAMSMART	                !DO WE HAVE ANY TEXT?
        THEN TYPE('Enter message, end with ^Z?M?J')
        ELSE TYPECHR("#");

P1_GETCHR();				!GET NEXT CHAR FROM INPUT STREAM (BUT ALLOW
					!USER TO SPECIFY "@" HERE
INDIRECTOK_0;				!"@" HAS NO SPECIAL EFFECT INSIDE TEXT

IF .P1 EQL #33 THEN (P1_#15; RESCAN(#12); TYPE('?M?J'));	!E-1 CONVERT ESC TO CRLF
UNTIL .P1 EQL #32 OR .P1 EQL #33	!^Z OR ALTMODE
DO 
    BEGIN
    STRMAILCHAR();
    P1_GETCHR();	!LOOP TILL ^Z OR ALTMODE SEEN
    IF .P1 EQL #33 THEN (P1_#15; RESCAN(#12); TYPE('?M?J'));	!E-1 CONVERT ESC TO CRLF
    END;

IF SCANN(MAILBLOCKBP) NEQ #12		!APPEND FINAL CR-LF IF NEEDED
    THEN PRINT('?M?J');			!IT WAS


!NOW ADD THE "CC:LIST" IF THE USER WANTS.

IF .CCPRT AND .PPNLIST[ITEMCOUNT] GTR 1
    THEN
	IF .PPNLIST[ITEMCOUNT] LEQ 10
	    THEN
	        BEGIN LABEL L;
		PRINT('CC:');
	        INITSCAN(PPNLIST);
		DO (T_NEXTITEM(PPNLIST)) UNTIL @.T NEQ 0;
		L: REPEAT
		    BEGIN
		    PRINTNAME(@.T);
		    DO
			(IF (T_NEXTITEM(PPNLIST)) EQL 0 THEN LEAVE L)
		    UNTIL @.T NEQ 0;
		    PRINTCHR (",");
		    END;
	        PRINT('?M?J');
	        END
	    ELSE
		PRINT('[Distribution to more than ten people]?M?J');
HAVEMESSAGE_1;			!YES WE DO HAVE THE MESSAGE
END;
	            %
STORAGE USED BY SENDMAIL ROUTINE TO ACTUALLY SEND THE MESSAGE
	            %

OWN	    MAILIBUFH[3],MAILOBUFH[3],UPDATE;
BIND	    OUTCNT=(MAILOBUFH+2)<0,36>,
	    OUTPTR=(MAILOBUFH+1)<0,36>,
	    INCNT=(MAILIBUFH+2)<0,36>,
	    INPTR=(MAILIBUFH+1)<0,36>;

FORWARD	    OPENMAILFILE,APPENDMESSAGE,FIXUP,IOERROR;





!ROUTINE TO READ ONE WORD FROM MAIL FILE
ROUTINE READWD=
	BEGIN 
	UNTIL (INCNT_.INCNT-1) GEQ 0
	    DO IFSKIP IN(MAIL)
	        THEN (IOERROR(); RETURN 0);
	@(INPTR_.INPTR+1)
	END;

!ROUTINE TO PUT ONE WORD TO MAIL FILE
ROUTINE PUTWD(WORD)=
	BEGIN
	UNTIL (OUTCNT_.OUTCNT-1) GEQ 0
	    DO IFSKIP OUT(MAIL)
	        THEN ERROR(SOFT,'ORM');
	OUTPTR_.OUTPTR+1; (.OUTPTR)<0,36>_.WORD;
	END;


ROUTINE IOERROR=
	BEGIN
	ERRORC(SOFT,'I/O error status '); PRINTOCTAL((GETSTS(MAIL,VREG);.VREG));
	TYPECHR(" "); TYPEFILE(); TYPE('?M?J');
	END;
	                        %
THIS ROUTINE SENDS MAIL TO ONE USER.  THE ARGUMENT IS THE ADDRESS OF THE NAME
BLOCK (AN ENTRY IN THE HIGH SEGMENT NAME TABLE) OF THE USER TO WHOM THE MAIL
IS TO BE SENT.  THE ACTUAL TEXT MESSAGE HAS ALREADY BEEN READ AND IS IN THE
LIST "TEXTLIST".
	                        %


ROUTINE SENDMAIL(RECEIVER)=
BEGIN MAP STRNAME RECEIVER;

LOCAL T,SAVEJOBFF;

!MAKE A SPECIAL CHECK FOR FORWARDING/REPLYING TO ONESELF.  THIS IS NECESSARY
!SINCE WE HAVE THE MAIL FILE OPEN IN TELL IN SUPERCEDE MODE, AND WON'T BE
!ABLE TO UPDATE IT HERE.

SAVEJOBFF_.JOBFF;			!SAVE .JBFF, SO CAN RECLAIM BUFFERS
T _					!1 IF SUCCESSFUL
    IF .INMESSAGE AND (.MYPPN EQL .RECEIVER[PPNOFNAME])
	THEN (SAVEMESSAGE(); 1)
	ELSE
	    IF OPENMAILFILE(.RECEIVER[PPNOFNAME])
		THEN 
		    IF APPENDMESSAGE()
			THEN FIXUP()
			ELSE 0
		ELSE 0;
JOBFF_.SAVEJOBFF;			!RECLAIM BUFFERS! (IF USED...)
IF .T
    THEN
	BEGIN
	IF .ITOLD THEN TYPECHR(",") ELSE TYPE('OK, I told ');
	TYPNMB(.RECEIVER);
	ITOLD_1;
	TELLHIM(.RECEIVER[PPNOFNAME]);
	END
    ELSE
	BEGIN MAP STRNAME T;
	T _ ALLOCATE (FAILLIST<ADDR>); T[NM1] _ .RECEIVER[NM1];
	T[NM2] _ .RECEIVER[NM2]; T[NAMEFLAGS] _ 0;
	END;
END;
	                        %
THIS ROUTINE OPENS THE MAIL FILE THAT WE ARE ABOUT TO WRITE.  THE ONLY
TRICKY PART IS HANDLING ENTER ERROR CODE 3 (WHICH MEANS SOMEONE ELSE IS
TELL'ING THE SAME USER).  IF WE GET ERROR CODE 3, WE SLEEP FOR 15 SECONDS
BEFORE GIVING UP.  (ANY OTHER SUGGESTIONS. . .)?
	                        %


	FORWARD	INFMES;

ROUTINE OPENMAILFILE(SENDPPN)=
BEGIN LABEL R; LOCAL SAVESFDPTR;

MAILSPEC(.SENDPPN);		            !BUILD FILE SPEC FOR THIS MESSAGE FILE
FILESPEC[FILESTATUS]_#400000000050;
FILESPEC[FILEBUFS]_MAILOBUFH<ADDR>^18+MAILIBUFH<ADDR>;
SAVESFDPTR _ .FILESPEC[SFDPTR];			!SAVE PPN/SFD LIST PTR SO LOOKUP/ENTER
						!DOESN'T CLOBBER

R: BEGIN					!JUMP OUT AFTER LOOKUP/ENTER FAILURE 3 GOES AWAY
   DECR J FROM 15 TO 1 DO			!TRY 15 TIMES
	BEGIN
	IFSKIP OPEN(MAIL,FILESPEC) THEN 0  ELSE RETURN 0;
	FILESPEC[SFDPTR] _ .SAVESFDPTR;		!RESTORE SFD PTR (MIGHT BE ZAPPED AFTER LOOKUP FAILURE)
	IFSKIP LOOKUP(MAIL,FILESPEC[FILENAME])	!IS FILE THERE
	    THEN (UPDATE_1; FILESPEC[ERRORCODE]_0) !YES SET UPDATE MODE
	    ELSE UPDATE_0;			!NO, NOT UPDATE
	IF .FILESPEC[ERRORCODE] EQL 0		!ANY OTHER ERROR WE CAN'T HANDLE
	    THEN
		BEGIN
		FILESPEC[PROTWORD]_0; FILESPEC[PROTECTION]_MAILPROT;
		FILESPEC[SFDPTR] _ .SAVESFDPTR;
		IFSKIP ENTER(MAIL,FILESPEC[FILENAME])
		    THEN LEAVE R;		!SUCCESS--JUMP OUT
		END;
	IF .FILESPEC[ERRORCODE] NEQ 3		!IF ANYTHING BUT 3
	    THEN RETURN 0;			!THEN GIVE UP
	IF .J EQL 15 THEN INFMES(.SENDPPN);	!IF THIS IS THE FIRST TIME,
						!THEN INFORM MESSAGE READER WE ARE
						!TRYING TO TELL HIM A MESSAGE.
	SLEEP(1);				!(CODE 3 IS FILE-BEING-MODIFIED)
	END;					!WHICH WE WANT TO BE NON-FATAL
					!HIM A MESSAGE
   RETURN 0				!TRIED 15 TIMES ON ERROR CODE 3
   END;
!HERE IF THE FILE HAS BEEN SUCCESSFULLY OPENED.
!DO VARIOUS THINGS TO MASSAGE THE FILE SO THAT WE CAN JUST APPEND THE
!MESSAGE TO THE END.

!IF THE FILE ALREADY EXISTED, WE READ/WRITE THE LAST BLOCK SO THAT SPACE
!DOESN'T GET WASTED (THIS IS A BUG IN TOPS-10: ONE CANNOT APPEND TO THE
!END OF A BLOCK WRITTEN IN BUFFERED MODE...).
!IF THE FILE DID NOT EXIST, WE OUTPUT THE INITIAL FILE HEADER.

INBUF(MAIL,1); OUTBUF(MAIL,1);
IFSKIP OUT(MAIL) THEN (IOERROR(); RETURN 0);
IF .UPDATE
    THEN                    !UPDATE MODE: READ AND REWRITE LAST BLOCK SO SPACE DOESN'T GET WASTED
	BEGIN REGISTER S,T;
	S _ -EXTENDLH(FILESPEC[6]); %FILE SIZE%
	T _ .S/128;         !LAST BLOCK IN FILE
	IF .S MOD 128 NEQ 0
	    THEN
	        BEGIN
	        USETI(MAIL,1,T);  !READ LAST BLOCK
	        IFSKIP IN(MAIL) THEN (IOERROR(); RETURN 0);
	        USETO(MAIL,1,T);
	        DECR I FROM (.S MOD 128) TO 1
	            DO PUTWD(READWD());
	        END
	    ELSE
	        (USETO(MAIL,1,T); OUTCNT_0)
	END
    ELSE
	BEGIN				!CREATE MODE: OUTPUT INITIAL FILE INFO
	PUTWD(NSENDER*2+1);		!NUMBER OF HEADER WORDS
	PUTWD(.DATEMESSAGE);		!DATE OF EARLIEST MESSAGE (I.E. THIS ONE)
	DECR I FROM (NSENDER-1)*2 TO 1 DO PUTWD(0);
	PUTWD(.MYNAME[0]);		!FIRST HALF OF SENDERS NAME
	PUTWD(.MYNAME[1]);		!SECOND HALF OF SENDERS NAME
	PUTWD(0);	               !NO FLAGS (LH)
	END;
1
END;
	                    %
ROUTINE TO APPEND MESSAGE TO END OF FILE.  AFTER OUTPUTTING HEADER, JUST
DUMP EVERYTHING OUT.
	                    %
ROUTINE APPENDMESSAGE=
BEGIN REGISTER PTR;
!NOW OUTPUT THE HEADER TO THE MESSAGE.  FIRST WORD IS (LH) NUMBER OF
!HEADER WORDS (RH) SIZE OF MESSAGE INCLUDING HEADER WORDS.  SECOND WORD
!IS DATE TO DELIVER MESSAGE, THIRD IS SENDERS PPN, LAST IS FLAGS (AT THIS
!POINT ALL ARE ZERO)

PUTWD(3^18+.TEXTLIST[ITEMCOUNT]+3); !LH: # HEADER WORDS; RH: SIZE OF MESSAGE
PUTWD(.DATEMESSAGE);		!WHEN TO SEND THE MESSAGE
PUTWD(.SENDERPPN);		!WHO SENT THE MESSAGE
PUTWD(.MAILFLAGS);		!FLAGS

!NOW COPY THE ACTUAL MESSAGE TEXT FROM TEXTLIST TO THE OUTPUT BUFFER.
INITSCAN(TEXTLIST<ADDR>);
UNTIL (PTR_NEXTITEM(TEXTLIST)) EQL 0
DO PUTWD(@.PTR);
IFSKIP OUT(MAIL) THEN 0 ELSE 1
END;
	                    %
THIS ROUTINE DOES THE FINAL FIXUP TO THE MESSAGE.  THE FIRST BLOCK IS
RE-READ TO GET THE DATE OF THE EARLIEST MESSAGE IN THE FILE.  IF NECESSARY,
THE DATE IS CHANGED.  THE NAME OF THE USER DOING THE TELL IS ADDED TO THE
LIST OF USERNAMES IN THE BEGINNING OF THE FILE (IF THERE IS ROOM); THEN
THE BLOCK IS WRITTEN OUT AGAIN.
	                    %

ROUTINE FIXUP=
BEGIN
MACRO	EARLYDATE=((.MAILOBUFH)+3)<0,36>$,
	FILEFLAGS=(.MAILOBUFH+10)$,
	SENDERS=(.MAILOBUFH+4)$;

IF .UPDATE          !IF FILE WAS CREATED BY APPENDMESSAGE, THIS IS ALL DONE
    THEN
	BEGIN REGISTER S; LABEL L;
	USETI(MAIL,1); IFSKIP IN(MAIL) THEN (IOERROR(); RETURN 0);
	USETO(MAIL,1);
	%COPY INPUT BUFFER TO OUTPUT BUFFER%
	S<LH>_.MAILIBUFH+2;  S<RH>_.MAILOBUFH+2;
	BLT (S,.MAILOBUFH+129);    !ZAP GOES THE BUFFER...
	IF .DATEMESSAGE LSS .EARLYDATE THEN EARLYDATE_.DATEMESSAGE;
	IF .DATEMESSAGE LEQ .NOW	    !IF SHOULD DELIVER MESSAGE NOW
	    THEN			    !THEN ADD SENDER NAME TO FILE HEADER FOR LOGIN
		BEGIN P3_0;		    !P3 WILL POINT TO A EMPTY SLOT
		IF (L: INCR S FROM SENDERS<ADDR> TO SENDERS<ADDR>+(NSENDER-1)*2 BY 2 DO
			IF (@.S EQL .MYNAME[0]) AND (@(.S+1) EQL .MYNAME[1])
			    THEN LEAVE L WITH 0
			    ELSE IF @.S EQL 0 THEN P3_.S)
			THEN			!NAME NOT FOUND...
			    IF .P3 EQL 0	!ROOM?
				THEN MORESENDERS_1
				ELSE ((.P3)<0,36>_.MYNAME[0]; (.P3+1)<0,36>_.MYNAME[1]);
		END;
	MAILOBUFH[1]_.MAILOBUFH[1]+.MAILIBUFH[2];	!UPDATE POINTER SO MONITOR TAKES BUFFER
	IFSKIP OUT(MAIL) THEN RETURN 0;
	END;
RELEASE(MAIL);            !SUCCESS! CLOSE OUT THE FILE

1
END;
	OWN WAKEUPLINE[12], BP, PTYNUM, TRMOPBLK[3];
	ROUTINE SHOVEIT=REPLACEI(BP,.P1);
	MACRO TRMOP(FCN,ARG)=
		BEGIN
		TRMOPBLK[0]_FCN; TRMOPBLK[2]_ARG; P1<RH>_TRMOPBLK<ADDR>; P1<LH>_3;
		IFSKIP CALLI(P1,#116) THEN ELSE P1_0;
		.P1
		END$;
	MACRO TRMNO(JOBN)=BEGIN P1_JOBN; CALLI (P1,#115); JFCL(0,0); .P1 END$;

ROUTINE TELLHIM(RECPPN)=
IF .DATEMESSAGE LEQ .NOW
    THEN
	BEGIN
	LOCAL T;
	P3_SHOVEIT<ADDR>; BP_WAKEUPLINE<36,7>;

	PRINT ('?G?G?M?J[You have a message from '); PRINTNAME(MYNAME<ADDR>);
	PRINT (']?M?J'); PRINTCHR(0);
	PTYNUM _ GETTAB(#11,#22)^(-18);
	DECR JOB FROM GETTAB(#12,#20) TO 1 DO
	    BEGIN
	    T_GETTAB(#2,.JOB);
	    IF .T<0,18+18*INDPPN> EQL .RECPPN<0,18+18*INDPPN> AND .JOB NEQ .MYJOB
		THEN
		    BEGIN
		    TRMOPBLK[1] _ TRMNO(.JOB);
		    IF .TRMOPBLK[1] GTR 0 AND .TRMOPBLK[1]-#200000 LSS .PTYNUM
			THEN
			    BEGIN
			    IF TRMOP(#1013,0) EQL 0 %TTY GAG?%
				THEN
				    IF TRMOP(#1001,0) EQL 0 %YES--USER LEVEL?%
					THEN RETURN;
			    IF (NOT CSLHACK) OR (TRMOP(#3005,0) EQL 0) %SET TTY NO SEND%
				THEN TRMOP(7,WAKEUPLINE<ADDR>);
			    END;
		    END;
	    END;
	END;

ROUTINE INFMES(RECPPN)=
BEGIN
	LOCAL T;
	P3_SHOVEIT<ADDR>;  BP_WAKEUPLINE<36,7>;
	PRINT('?G?G?M?J['); PRINTNAME(MYNAME<ADDR>);
	PRINT(' is trying to tell you a message]?M?J'); PRINTCHR(0);
	DECR JOB FROM GETTAB(#12,#20) TO 1
	  DO
	    BEGIN
	    T_GETTAB(#2,.JOB);
	    IF .T<0,18+18*INDPPN> EQL .RECPPN<0,18+18*INDPPN> AND .JOB NEQ .MYJOB
		AND GETTAB(#3,.JOB) EQL SIXBIT 'TELL'
		  THEN
		    BEGIN
		    TRMOPBLK[1]_TRMNO(.JOB);
		    TRMOP(7,WAKEUPLINE<ADDR>);
		    END;
	    END;
END;
				%
ROUTINE TO RETURN THE FILE SPECIFICATION CORRESPONDING TO A PPN.
				%

GLOBAL ROUTINE MAILSPEC(SENDPPN)=
BEGIN

ZEROSPEC();			!CLEAR OUT FILE SPECIFICATION
FILESPEC[FILEDEVICE]_MAILDEV;	!DEVICE FOR MAIL
FILESPEC[EXTENSION]_SIXBIT "MAI";
FILESPEC[FILEPPN]_MAILPPN;
FILESPEC[SFDPTR]_.FILESPEC[FILEPPN];

!THE FILE NAME CURRENTLY IS JUST THE PROGRAMMER NUMBER IN SIXBIT.
IF INDPPN THEN FILESPEC[FILENAME]_.SENDPPN
    ELSE
	BEGIN
	LOCAL BPFNM,BPNUM;
	BPFNM_FILESPEC[FILENAME]<36,6>; BPNUM_SENDPPN<18,3>;
	DO (REPLACEI(BPFNM,SCANI(BPNUM)+#20)) WHILE .BPFNM<30,6> NEQ 0;
	END;
END;

GLOBAL ROUTINE ALIASCOMMAND=
BEGIN
	REGISTER STRNAME T;
	LABEL LOOP;
	INITSTORAGE(PPNLIST,1,1);
LOOP:	REPEAT
	    BEGIN
	    INITSTORAGE(TELLIST,3,3);
	    DO
		(TELLPARSE(1); INITSCAN(TELLIST))
	    UNTIL
		(T_NEXTITEM(TELLIST)) NEQ 0;
	    NAMEERROR_0;
	    NAMEERROR_.NAMEERROR OR
		(IF .T[PPNFLAG] THEN PPNSEARCH ELSE NAMESEARCH)(.T,2);
	    IF NOT .NAMEERROR AND .PPNLIST[ITEMCOUNT] GTR 0
	      THEN
		BEGIN
		INITSCAN(PPNLIST);
		T_@NEXTITEM(PPNLIST);
		MYPPN_.T[PPNOFNAME];
		RETURN .VREG
		END;
	    END;
END;
