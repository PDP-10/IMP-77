!PARAMETER FILE FOR TELL.  THIS FILE IS REQUIRE'D BY ALL TELL SOURCES.
%
TELL WAS WRITTEN BY:
	STEVE FORTUNE
	COORDINATED SCIENCE LAB
	UNIVERSITY OF ILLINOIS
	URBANA, ILLINOIS 61801
IT WAS FURTHER DEVELOPED BY
	PETER DEWOLF
ALSO FROM CSL
%
SWITCHES NOLIST;

!THE FIRST TWO PARAMETERS DEFINE WHERE THE MESSAGE FILES RESIDE.
BIND	MAILDEV=SIXBIT 'DSKB',
	MAILPPN=#3000004;

BIND	NSENDER=3,              !NUMBER OF NAMES STORED IN MESSAGE FILE FOR LOGIN
	INDPPN=0,               !1 IF SAME PROG # IN DIFFERENT PROJECTS IS
	                        !DIFFERENT PERSON, 0 IF SAME PERSON

	MAILPROT=#177,		!PROTECTION OF MAIL FILES
	COMPATIBLE=0,		!1 IF JUST CHANGING TO NEW SYSTEM.  WHEN RUNNING
				!MESSAGE, WILL DO A RUN UUO TO SYS:MESSAGE TO
				!PRINT ANY OLD-STYLE MESSAGES; ALSO IF TELL.INI IS
				!FOUND WILL TELL USER TO SWITCH TO SWITCH.INI
	MAXLINES=100,		!IF A MESSAGE IS GTR THAN MAXLINES LONG,
				!THE USER IS ASKED IF HE WANTS TO SEE IT
	QBDFLT=1;		!DEFAULT IS TO TYPE MESSAGE IF NO /QUERY:BEFORE
				!(SEE DISPOSETABLE FOR OPTIONS, INDICES)
BIND	CSLHACK=1;		!CSL HACKS:(1) USE CSL'S 23 WORD ACCT.SYS ENTRY
				!(2) CHECK 'TTY NO SEND' SETTING
				!(3) CHECK PRIV BIT FOR GODLINESS
	                %
	            REGISTERS
	                %
REGISTER    P1=4,       !THESE REGISTERS ARE USED TO PASS PARAMETERS
	    P2=5,       !HOLD GLOBAL VALUES, ETC.  IN GENERAL P3 IS MOST
	    P3=6;       !PRESERVED, P1 IS LEAST PRESERVED.  SEE ALSO OUTPUT
	                !MACROS FOR CONVENTIONS THERE.
	                %
	            FLAGS OF GLOBAL USE
	                %

MACRO	    DSKOPEN=FLAGWORD<35,1>$,     !1 IF READING FROM DISK INSTEAD OF TTY
	    INDIRECTOK=FLAGWORD<34,1>$,  !1 IF "@" IS BELIEVED AS INDIRECT FILE SPEC
	    CCL=FLAGWORD<33,1>$,         !1 IF ENTERED VIA CCL
	    DATEERROR=FLAGWORD<32,1>$,   !(TELL) 1 IF USER SCREWED DATE
	    ITOLD=FLAGWORD<31,1>$,       !(TELL) 1 IF "I TOLD" HAS BEEN PRINTED
	    IAMBATCH=FLAGWORD<30,1>$,	 !1 IF THIS IS A BATCH JOB
	    COPIED=FLAGWORD<29,1>$,	 !(TELL) 1 IF COPIED FIRST PART OF MESSAGE TEXT
	    HAVEMESSAGE=FLAGWORD<28,1>$, !(TELL) 1 IF WE ARE PASSED MESSAGE USER WANTS TO SEND 
	    SWITCHSCAN=FLAGWORD<27,1>$,	 !WE ARE SCANNING SWITCH.INI NOW
	    INMESSAGE=FLAGWORD<26,1>$,	 !1 IF WE CALLED TELL FROM MESSAGE
					 !(SENDING MAIL TO ONESELF IS THEN A SPECIAL CASE)
	    INWHO=FLAGWORD<25,1>$,	 !1 IF WE ARE DOING A WHO COMMAND
	    ASKQUEST=FLAGWORD<24,1>$,	 !1 IF HAD TO ASK QUESTIONS
	    NEVREM=FLAGWORD<23,1>$,	 !1 IF CURRENTLY REMOVING USERS FROM
					 !PPNLIST WHICH ARE NEVER TO BE TOLD.
	    DOTFLAG=FLAGWORD<22,1>$;	 !1 IF A DOT WAS TYPED IN A FILE-SPEC


	                %
	    FLAGS WHICH REFLECT SWITCH SETTINGS
	                %
MACRO	    CCPRT=FLAGWORD<0,1>$,       !1 IF REQUEST CC PRINTING
	    QUERYBEFORE=FLAGWORD<1,1>$, !1 IF /QUERY:BEFORE (A MESSAGE)
	    QUERYAFTER=FLAGWORD<2,1>$,	!1 IF /QUERY:AFTER (A MESSAGE)
	    HOLDPRINT=FLAGWORD<3,1>$,	!1 IF /HOLD (PRINT MESSAGES ON HOLD)
	    IAMSMART=FLAGWORD<4,1>$,	!1 IF /SMART
	    IAMGOD=FLAGWORD<5,1>$,	!1 IF SUPER PRIVILEGED
	    COPYFLAG=FLAGWORD<6,1>$,	!1 IF /DIS:COPY:FILE-SPEC SEEN
	    UNREAD=FLAGWORD<7,1>$;	!1 IF /UNREAD


!IO CHANNEL ASSIGNMENTS
BIND	    DSK=1,                      !USED BY OPENSPEC FOR INDIRECT FILES
	                                !AND READING SYS:ACCT.SYS
	    MAIL=2,                     !FOR READING/WRITING MESSAGE FILE
	    MES=3,			!MESSAGE USES THIS TO WRITE THE NEW MAIL FILE
					!CAN'T USE 2 BECAUSE MESSAGE MIGHT CALL TELL
	    CFILE=4;			!CHAN USED FOR COPY OPTION OF DISPOSE IN MESSAGE
			%
CONTROL MACROS AND MISCELLANEOUS
			%

MACRO	REPEAT=WHILE 1 DO$,
	LH=18,18$,
	RH=0,18$,
	ADDR=0,0$;


MACRO		ERROR(CAT,LIT)=ERR(CAT,PLIT LIT)$,
		ERRORC(CAT,LIT)=ERRC(CAT,PLIT LIT)$;
		BIND	SOFT=1,
			HARD=2,
			SYSTEM=3;

MACHOP		TTCALL=#051;
MACRO	        INCHWL(CH)=TTCALL(4,CH)$;



MACHOP	        OPEN=#050,
	        CALLI=#047,
		RENAME=#055,
	        IN=#056,
		STATO=#061,
	        GETSTS=#062,
	        OUT=#057,
		INBUF=#064,
		OUTBUF=#065,
	        CLOSE=#070,
	        RELEASE=#071,
	        USETI=#074,
	        USETO=#075,
	        LOOKUP=#076,
	        ENTER=#077,
	        LSHC=#246,
	        BLT=#251,
		JRST=#254,
	        JFCL=#255,
		HLRE=#574;

MACRO	        CORE(AC)=CALLI(AC,#11)$,
		DEVCHR(CHAN)=(REGISTER QQQ; QQQ_CHAN; CALLI(QQQ,4); .QQQ)$,
		RESET=(CALLI(0,0); JFCL(0))$,
	        LOGOUTUUO=(CALLI(1,#17); CALLI(0,#17); JFCL(0))$,
		GETDATE(WHERE)=CALLI(WHERE,#14)$,
		GETMSTIME(WHERE)=CALLI(WHERE,#23)$,
		GETTAB(TABLE,INDEX)=BEGIN REGISTER G; G_INDEX^18+TABLE; CALLI(G,#41); G_0; .G END$;


EXTERNAL        ?.JBFF,?.JBHRL,?.JBREL;
		BIND JOBFF=?.JBFF,JOBHRL=?.JBHRL,JOBREL=?.JBREL;



MACRO	        EXTENDLH(A)=
	        (HLRE(VREG,A))$;
MACRO	        SLEEP(TIME)=
	        BEGIN REGISTER R; R_TIME; CALLI (R,#31) END$;

MACRO		RUN(BLOCK)=
		BEGIN REGISTER R; R_BLOCK; CALLI (R,#35); JRST(4,0) END$;


BIND		BIGGEST=#377777777777;
	                %
STRING AND TELETYPE OUTPUT ROUTINES:  SINCE MANY ROUTINES EXIST FOR
OUTPUTTING STRING, NAMES, NUMBERS ETC. ETC. TO BOTH DISK AND TELETYPE,
THE FOLLOWING CONVENTIONS ARE USED:
IF A SUBROUTINE/MACRO  NAME CONTAINS THE STRING "TYPE", THE SUBROUTINE/MACRO
GOES STRICTLY TO THE TTY.  IF THE NAME CONTAINS THE STRING "PRINT", THEN
GLOBAL REGISTER P3 IS ASSUMED TO CONTAIN THE ADDRESS OF A CHARACTER 
OUTPUT ROUTINE.  THE CHARACTER IS IN REGISTER P1.  THIS CONVENTION MAY
BE SLIGHTLY CONFUSING, BUT IT IS CONSISTENTLY USED.
NOTE: A SUBROUTINE WHICH GOES STRICTLY TO TTY (I.E. HAS TYPE IN THE NAME)
MAY STILL DESTROY P3 IF IT CALLS A ROUTINE WHICH IS GENERAL.  CALLERS SHOULD
MAKE NO ASSUMPTIONS ABOUT P3.

IN GENERAL, THE CONVENTIONS FOR P1-P3 FOR OUTPUT ROUTINES ARE:
P1	CONTAINS ONE CHARACTER
P2	HAS A POINTER,VALUE, ETC.
P3	IS THE ADDRESS OF THE TYPEOUT ROUTINE (CHARACTER-AT-A-TIME)
	            %

!OUTPUT TO TTY MACROS
MACRO	TYPECHR(ACHAR)=BEGIN REGISTER QQQ; QQQ_ACHAR; TTCALL(1,QQQ); END$,
	TYPEADR(ADR)=BEGIN REGISTER QQQ; QQQ_ADR;  TTCALL(3,0,QQQ); END$,
	TYPE(LIT)=TTCALL(3,PLIT ASCIZ LIT)$,

!OUTPUT TO EITHER TTY OR DISK DEPENDING ON CONTENTS OF P3
	PRINTCHR(ACHAR)=BEGIN P1_ACHAR; (.P3)(); END$,
	PRINTADR(ADR)=BEGIN P2_ADR; PRTSTR(); END$,
	PRINT(STRING)=BEGIN P2_PLIT ASCIZ STRING; PRTSTR(); END$,
	PRINTOCTAL(NUMBER)=BEGIN P2_NUMBER; PRTOCT() END$,
	PRINTDEC(NUMBER)=BEGIN P2_NUMBER; PRTDEC() END$,
	PRINTSIXBIT(WORD)=BEGIN P2_WORD; PRTSXB() END$,
	PRINTNAME(NAMEPTR)=BEGIN P2_NAMEPTR; PRTNM() END$;



!MACRO TO FIND A NAME WITHIN A TABLE.  WORD IS A POSSIBLY ABBREVIATED
!SIXBIT STRING, TABLE IS ADDRESS OF TABLE.
MACRO	MATCHNAME(WORD,TABLE)=
	BEGIN
	P1_WORD; P2_TABLE; MTCHNM()
	END$;
!THE ACTION MACRO IS USED IN STATE TRANSITION TABLES.  CL IS PRESUMABLY
!A CHARACTER CLASS (0 LE CL LE 17)
MACRO	        ACTION(TABLE,ST,CL)=
	        .(.TABLE[.ST]<0,18>+.CL/6+@SIXBITBPTAB[.CL MOD 6])$;
BIND	        SIXBITBPTAB=PLIT(
	        0<30,6>,0<24,6>,0<18,6>,0<12,6>,0<6,6>,0<0,6>);


!THE X MACRO IS USED TO DEFINE A STATE TABLE.  THERE SHOULD BE 18 ARGUMENTS
!TO X, ONE FOR EACH CHARACTER CLASS.  THE ARGUMENTS MAY BE EITHER NEXT-STATES OR 
!FUNCTION INDICES; THEY ARE LIMITED IN SIZE TO 6 BITS.
MACRO   X(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R)=PLIT(
        A^30+B^24+C^18+D^12+E^6+F,
        G^30+H^24+I^18+J^12+K^6+L,
        M^30+N^24+O^18+P^12+Q^6+R)$;
	                %
FORMAT OF MAIL FILE.  THE MAIL FILE EXISTS FOR EACH USER.

	=================================================
	!   CURRENTLY ZERO      ! # WORDS IN HEADER (7) !
	=================================================
	!   EARLIEST MESSAGE DATE (UNIVERSAL DATE/TIME) !
	=================================================
	!   USER NAME IN SIXBIT OF SENDER OF MAIL INFO  !
	!   (REPEATED TWICE MORE, TOTAL OF SIX WORDS.   !
	!   USED BY LOGIN TO PRINT SENDER'S NAME.)	!
	=================================================
	!M!H!			!                 	!
	=================================================

M	(BIT 0) MORESENDERS.  IF THIS BIT IS A 1, THEN THERE HAVE BEEN MORE
	THAN THREE PEOPLE TO SEND MAIL TO THIS USER SINCE HE LAST LOOKED AT
	HIS MAIL (USED BY LOGIN)
H	(BIT 1) ANYONHOLD.  IF THIS BIT IS A 1, THEN THERE ARE SOME MESSAGES
	IN THE FILE ON HOLD.

AFTER THE FLAG WORD ARE THE MESSAGE ENTRIES.
THE FORMAT OF EACH ENTRY IS:

	=================================================
	! # HEADER WORDS (3)	! MESSAGE SIZE (*)	!
	=================================================
	! DATE TO DELIVER MESSAGE (UNIVERSAL FORMAT)	!
	=================================================
	! PROJECT-PROGRAMMER NUMBER OF SENDER		!
	=================================================
	!H!U!       --UNUSED--				!
	=================================================

(*) THE SIZE OF THE FILE INCLUDES THE HEADER WORDS (BUT NOT THE WORD
CONTAINING THE WORD COUNT)

H	(BIT 0) IS THE "HOLD" FLAG; IF ON THIS MESSAGE IS ON HOLD.
U	(BIT 1) IS THE "UNREAD" FLAG; IF ON THIS MESSAGE HAS NOT BEEN READ
	                    %

MACRO	MORESENDERS=FILEFLAGS<35,1>$,
	ANYONHOLD=FILEFLAGS<34,1>$;
                        %
CORE ALLOCATION MACROS.  THE TELL SYSTEM SETS UP A DYNAMIC LIST FOR
INTERNAL DATA STRUCTURES.  THERE ARE TWO PARTS TO A DYNAMIC LIST: THE
LIST HEADER AND THE LIST ITSELF.  THE FORMAT OF THE LIST HEADER IS

        =========================================================
        !   # ITEMS IN LIST         ! ADDR FIRST BLOCK IN LIST	!
        =========================================================
        !   BLOCK SIZE IN WORDS     ! ADDRESS CURRENT BUFFER	!
        =========================================================
        !   ITEM SIZE IN WORDS      ! # WORDS LEFT THIS BUFFER  !
        =========================================================
	!   CURR BUF BEING SCANNED  ! ADDR WITHIN CURRENT BLOCK !
	=========================================================
	!			    ! # WORDS LEFT TO SCAN      !
	=========================================================

FOR REASONS OF STORAGE EFFICIENCY, STORAGE IS ALLOCATED IN BLOCKS;
WHERE EACH BLOCK CONSISTS OF ANY NUMBER OF ITEMS (INCLUDING 1). 
FORMAT OF A BLOCK:

        =========================================================
        !           0               !    LINK TO NEXT BLOCK     !
        =========================================================
        !     ITEM 1 (ANY NUMBER OF WORDS)                  	!
        =========================================================
        !     ITEM 2 (REPEAT FOR BLOCKSIZE/ITEMSIZE ITEMS)      !
        =========================================================


IT IS THE DUTY OF THE ROUTINE USING THE STORAGE ALLOCATION FACILITY TO
SET UP THE LIST HEADER; INITIALIZATION CAN BE DONE AT RUN TIME USING
THE INITSTORAGE MACRO.  THE LIST CAN BE SCANNED WHILE IT IS BEING 
CONSTRUCTED; THUS THE FOURTH WORD OF THE HEADER IS THE SCAN POINTER.
RELEVANT MACROS, ROUTINES, AND STRUCTURE DECLARATIONS:

STRCORE     THIS STRUCTURE DEFINES THE LIST HEADER; IT SHOULD BE MAPPED
            ON A VARIABLE WHICH CONTAINS THE ADDRESS OF THE HEADER.
STRCOREBLK  THIS STRUCTURE ALSO DEFINES THE LIST HEADER; HOWEVER IT SHOULD BE
	    MAPPED ON THE HEADER ITSELF, NOT A VARIABLE CONTAINING THE
	    ADDRESS OF THE HEADER.
INITSTORAGE THIS MACRO INITIALIZES THE LIST HEADER.  THE FIRST ARGUMENT IS
            THE ADDRESS OF THE HEADER; THE SECOND IS THE BLOCK SIZE; THE
            THIRD THE CHUNKSIZE. THIS MACRO SHOULD BE EXECUTED BEFORE
            ALLOCATE IS CALLED.
ALLOCATE    THIS ROUTINE ALLOCATES STORAGE FOR ONE ITEM FROM THE CURRENT
            BLOCK; A NEW BLOCK WILL BE ALLOCATED (CORE UUO) IF NEED BE.
            THE ROUTINE RETURNS THE ADDRESS OF THE ALLOCATED STORAGE.
INITSCAN    THIS ROUTINE INITIALIZES THE LIST HEADER TO SCAN THE LIST.  IT
            SHOULD BE CALLED BEFORE NEXTITEM IS.
	    THE ARGUMENT SHOULD BE THE ADDRESS OF THE 4-WORD HEADER.
NEXTITEM    THIS ROUTINE RETURNS THE ADDRESS OF THE NEXT ITEM ON THE LIST.

                                %
STRUCTURE   STRCORE[I,J,P,S] = [1]
                CASE .I OF
                    SET
                    (@.STRCORE+.J)<.P,.S>;          !WITHIN HEADER
                    (.(@.STRCORE+.J)<.P,.S>-1)<0,18>   !THE LINK TO NEXT BLOCK
                    TES;
STRUCTURE   STRCOREBLK[I,J,P,S] = [5]
	        CASE .I OF
	            SET
	            (.STRCOREBLK+.J)<.P,.S>;
	            (.(.STRCOREBLK+.J)<.P,.S>-1)<0,18>
	            TES;

MACRO       BLOCKSIZE=0,1,18,18$,
	    ITEMCOUNT=0,0,18,18$,
            HEADER=0,0,0,18$,
            CURRENT=0,1,0,18$,
            ITEMSIZE=0,2,18,18$,
            FREE=0,2,0,18$,
            LINK=1,1,0,18$,
            SCANCURR=0,3,18,18$,
	    SCANADDR=0,3,0,18$,
	    SCANLEFT=0,4,0,18$,
	    SCANLINK=1,3,18,18$;
BIND HEADERSIZE=5;			!SIZE OF LIST HEADER


MACRO       INITSTORAGE(LISTHDR,ITMSZ,BLKSZ)=
              BEGIN
                REGISTER STRCORE QQQ;
                QQQ_(LISTHDR)<0,0>;
                QQQ[HEADER]_0; QQQ[BLOCKSIZE]_BLKSZ;  QQQ[ITEMSIZE]_ITMSZ;
                QQQ[ITEMCOUNT]_QQQ[CURRENT]_QQQ[FREE]_0;
              END$;

	                %
NAME BLOCKS:  THESE EXIST IN LOTS OF DIFFERENT PLACES AND IN SLIGHTLY
DIFFERENT FORMATS.  THE NORMAL FORMAT IS:

	=================================================
	!  WORD 1 OF NAME (NM1) OR PPN			!
	=================================================
	!  WORD 2 OF NAME (NM2) OR MASK FOR PPN		!
	=================================================
	!D!P!G                  !  EQULIST		!
	=================================================

	D IS DELETE FLAG (1 TO REMOVE THIS NAME, 0 TO ADD IT)
	P IS PPN FLAG (1 IF THIS IS REALLY A PPN, 0 IF NAME)
	G IF THIS IS A GROUP NAME (AND EQULIST IS DEFINED)
	EQULIST IS A POINTER TO THE NAMES/PPN'S THIS GROUP NAME IS BOUND
	TO (WHICH MAY THEMSELVES BE GROUP NAMES).

WORD 3 MAY ALSO CONTAIN THE PPN, IF THIS IS PART OF THE HIGH SEGMENT NAME
TABLE.
	                %

STRUCTURE       STRNAME[I,P,S]=
	        (@.STRNAME+.I)<.P,.S>;
	        MACRO NM1=0,0,36$,
	              NM2=1,0,36$,
	              NAMEFLAGS=2,0,36$,
	              DELFLAG=2,35,1$,
	              PPNFLAG=2,34,1$,
	              GROUPFLAG=2,33,1$,
	              EQULIST=2,0,18$,
	              PPNOFNAME=2,0,36$,
		      PROGNUMOFNAME=2,0,18$,
		      PROJNUMOFNAME=2,18,18$,
	              PROJNUM=0,18,18$,   PROGNUM=0,0,18$,
	              PROJMASK=1,18,18$,  PROGMASK=1,0,18$;
	                %
FILE SPECIFICATION BLOCK:  THIS BLOCK IS USED ALMOST EVERYWHERE A 
SPECIFICATION IS BUILT/LOOKED UP/PRINTED OR WHATEVER.

	=========================================
	!OPEN BITS          !   STATUS      	!
	=========================================
	! DEVICE NAME IN SIXBIT             	!
	=========================================
	! OUT BUF HEADER    ! INPUT BUF HEADER	!
	=========================================
	! FILE NAME IN SIXBIT               	!
	=========================================
	! EXTENSION         !  ERROR CODE   	!
	=========================================
	!  --GARBAGE--                      	!
	=========================================
	!  PPN OR POINTER TO SFD LIST (.+2) 	!
	=========================================
	!  PPN (EVEN IF NO SFDS)            	!
	=========================================
	!   SFD 1                           	!
	!   SFD 2                           	!
	!   SFD 3                           	!
	!   SFD 4                           	!
	!   SFD 5                           	!
	!   GUARANTEED ZERO WORD            	!
	=========================================


IF THIS LOOKS FAMILIAR, IT IS.  THE FILE SPECIFICATION BLOCK IS USED
FOR OPENS/LOOKUPS/ENTERS ETC. DIRECTLY.
	                %
STRUCTURE   STRFILE[I,P,S]=
	    (.STRFILE+.I)<.P,.S>;
	    MACRO   FILESTATUS=0,0,36$,

	            FILEDEVICE=1,0,36$,
	            FILEBUFS=  2,0,36$,
	            FILENAME=  3,0,36$,
	            EXTENSION= 4,18,18$,
	            ERRORCODE= 4,0,18$,
		    PROTWORD=  5,0,36$,
		    PROTECTION=5,27,9$,
	            SIZEWORD=   6,0,36$,
	            SFDPTR=     6,0,36$,
	            FILEPPN=   7,0,36$,
	            FILEPROJNUM=7,18,18$,
	            FILEPROGNUM=7,0,18$,
	            SFDLIST=    8,0,36$;

                    %

THE INPUT-CHARACTER-AT-A-TIME ROUTINE RETURNS BOTH THE ASCII EQUIVALENT
OF THE CHARACTER AND AN INTERNAL BSU CLASS.  A FULL WORD IS USED FOR
THE CHARACTERS; THE LEFT HALF IS THE ASCII VALUE; THE RIGHT HALF IS THE
CLASS.  
                    %

STRUCTURE   STRCHAR[P,S]=.STRCHAR<.P,.S>;
MACRO       ASCII=18,18$,
            CLASS=0,18$;


                    %
THE FOLLOWING ARE THE BSU CLASSES.  THE NUMERIC VALUES ARE USED IN STATE
TABLES ALL OVER THE PLACE, SO CHANGE ONLY AT THE RISK OF MUCH CONFUSION.
                    %
BIND        BLANK=0,
            ALPHA=1,        !A-Z AND "#" (QUOTED SPACE)
            NUMER=2,        !0-9
            SLASH=3,        !"/"
            LPAR=4,         !"("
            RPAR=5,         !")"
            STAR=6,         !"*"
            PLSMN=7,        !"+" OR "-"
            COMMA=8,        !","
            EQUAL=9,        !"="
            LBRAK=10,       !"["
            RBRAK=11,       !"]"
            COLON=12,       !":"
            DOT=13,         !"."
            QMARK=14,       !"?"
            OTHER=15,       !ANYTHING ELSE
            EOL=16,         !ANY OF THE BREAKS (EXCEPT ^G) LF,VT,FF,ESC
            EOF=17;         !END OF FILE (^Z OR PHYSICAL)
SWITCHES LIST;
