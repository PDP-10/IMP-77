MODULE TELSUB(RESERVE(4,5,6))=
BEGIN

REQUIRE DSK:TELPRM.BLI;



FORWARD	    ERR,ERRC,ERRFIN,
	    MTCHNM,	    !FINDS SIXBIT COMMAND IN TABLE
	    PPNPRINT,       !YOUR TYPICAL PPN PRINT ROUTINE
	    TYPEFILE,       !PRINTS A FILE SPECIFICATION
	    TTYTYPE,        !OUTPUT CHARACTER IN P1 TO TTY
	    PRTSTR,         !OUTPUT STRING IN P2 TO ROUTINE IN P3
	    PRTNM,	    !PRINTS 12-CHAR NAME IN A FANCY MANNER
	    CHARBSU,        !RETURNS A CHAR IN BSU FORMAT
	    RESCAN,         !RESCAN LAST CHARACTER
	    NEXTCHAR,       !NEXT CHARACTER
	    LERERROR,       !PRINTS LOOKUP/ENTER/RENAME ERROR MESSAGES
	    TYPEHEAD,
	    PRTSXB,
	    PRTOCT;         !YOU GUESSED IT


GLOBAL	    FLAGWORD,       !THIS IS WHERE ALL THE FLAGS LIVE (US, USSR, ...)
	    FILESPEC[14],   !PEOPLE USE THIS TO BUILD FILE SPECIFICATIONS
	    COPYSPEC[14];   !COPY OF FILESPEC FROM /DIS:COPY

MAP	    STRFILE FILESPEC;

EXTERNAL    NAMETABLE,NAMEND,TELLPARSE,TELLIST,GROUPLIST,MYJOB;
EXTERNAL    NAMEPARSE,DISPOPTION,MYPPN;
MAP	STRCOREBLK TELLIST:GROUPLIST;

GLOBAL ROUTINE STOP=
BEGIN
	REGISTER Q;
	Q_-1*.MYJOB;
	IFSKIP CALLI(Q,#61) %JOBSTS%
	    THEN 0
	    ELSE Q<34,1>_1;	!ASSUME LOGGED IN
	IF NOT .Q<34,1> THEN TYPE('.KJOB?M?J.');
	LOGOUTUUO;		!DIE
END;
				%
FILE HANDLING ROUTINES:  THERE ARE MANY DIFFERENT ROUTINES TO DO VARIOUS
SORTS OF NIFTY THINGS. (ALL USE THE GLOBAL BLOCK FILESPEC FOR STORAGE)
GETSPEC	    BUILDS A FILE SPECIFICATION USING THE CHARBSU ROUTINE.  IF CHARBSU
	    IS POINTED AT A DISK FILE, THEN THE FILE SPEC CAN COME FROM A DISK
	    FILE.
ZEROSPEC    SIMPLY ZEROS THE FILE SPECIFICATION BLOCK (CALL BEFORE BUILDING
	    A FILE SPEC)
OPENSPEC    OPENS THE FILE SPECIFICATION BUILD BY GETSPEC, RETURNING 1 IF 
	    SUCCESFUL, 0 PLUS AN ERROR MESSAGE IF NOT.
TYPEFILE    PRINTS THE FILE SPECIFICATION IN DEC-10 STANDARD FORMAT.
LERERROR    PRINTS LOOKUP/ENTER/RENAME ERROR CODES
CHKACC    CHECKS ACCESS TO FILE (ALREADY LOOKED UP IN FILESPEC)
				%

GLOBAL ROUTINE ZEROSPEC=
BEGIN
REGISTER S;
S<LH>_FILESPEC<0,0>; S<RH>_(FILESPEC+1)<0,0>;
FILESPEC_0; BLT(S,FILESPEC+13);
END;

	            %
THIS ROUTINE TRIES TO OPEN THE FILE POINTED TO BY FILESPEC.  IF IT IS SUCCESSFUL
IT RETURNS 1, OTHERWISE IT PRINTS AN ERROR MESSAGE AND RETURNS 0.  FILESPEC
MUST BE COMPLETELY SET UP BEFORE THIS ROUTINE IS CALLED.
THE ARGUMENT IS A 1 IF FILE-NOT-FOUND IS NOT TO PRINT AN ERROR MESSAGE;
0 IF FILE-NOT-FOUND IS CONSIDERED AN ERROR.
	            %
GLOBAL ROUTINE OPENSPEC(NOTFOUNDOK)=
IFSKIP OPEN(DSK,FILESPEC[FILESTATUS])
    THEN
	IFSKIP LOOKUP(DSK,FILESPEC[FILENAME])
	    THEN 1
	    ELSE
		(IF .FILESPEC[ERRORCODE] NEQ 0 OR NOT .NOTFOUNDOK
		    THEN (ERRORC(SOFT,'LFL LOOKUP'); LERERROR());
		 0)
    ELSE
	(ERRORC (SOFT,'OFD OPEN failure device ');PRINTSIXBIT(.FILESPEC[FILEDEVICE]); ERRFIN(); 0);

GLOBAL ROUTINE CHKACC(ACCESS,CHANNEL)=
BEGIN OWN CHKACBLOCK[3],PATHBLOCK[3];
	REGISTER TT;
	CHKACBLOCK[0]<18,18>_.ACCESS;
	CHKACBLOCK[0]<0,18>_.FILESPEC[PROTECTION];
	TT_3^18+PATHBLOCK<ADDR>;
	PATHBLOCK[0]_.CHANNEL;
	CHKACBLOCK[1]_IFSKIP CALLI(TT,#110) THEN .PATHBLOCK[2] ELSE .FILESPEC[FILEPPN];
	CHKACBLOCK[2]_.MYPPN;
	TT_CHKACBLOCK<ADDR>;
	IFSKIP CALLI(TT,#100)
	    THEN RETURN NOT .TT
	    ELSE RETURN 0
END;
	                %
THIS ROUTINE TYPES A LOOKUP/RENAME/ENTER ERROR MESSAGE CODE AND TEXT STRING,
FOLLOWED BY THE FILE NAME.  THE REQUIRED INFORMATION IS ASSUMED TO BE IN
THE GLOBAL BLOCK FILESPEC.
	                %
GLOBAL ROUTINE LERERROR=
BEGIN
BIND UUOERRTAB=PLIT(
PLIT ASCIZ 'file not found',
PLIT ASCIZ 'No UFD for',
PLIT ASCIZ 'protection failure ',
PLIT ASCIZ 'file being modified',
PLIT ASCIZ 'file already exists',
PLIT ASCIZ 'internal TELL error',
PLIT ASCIZ 'RIB error');
TYPE (' failure ('); PRINTOCTAL(.FILESPEC[ERRORCODE]); TYPE (') ');
IF .FILESPEC[ERRORCODE] GEQ .UUOERRTAB[-1]
	THEN TYPE (' unknown error')
	ELSE TYPEADR (.UUOERRTAB[.FILESPEC[ERRORCODE]]);
TYPECHR(" "); TYPEFILE();  ERRFIN()
END;





	                %
ROUTINE TO TYPE A FILE SPECIFICATION.  THE FILE SPECIFICATION IS ASSUMED 
TO BE IN THE GLOBAL BLOCK FILESPEC.
	                %
GLOBAL ROUTINE TYPEFILE=
BEGIN
PRINTSIXBIT(.FILESPEC[FILEDEVICE]); TYPECHR(":");
PRINTSIXBIT(.FILESPEC[FILENAME]);
IF .FILESPEC[EXTENSION] NEQ 0
	THEN (TYPECHR("."); PRINTSIXBIT(.FILESPEC[EXTENSION]^18));
IF .FILESPEC[FILEPPN] NEQ 0
    THEN
	BEGIN REGISTER S;
	TYPECHR("["); PRINTOCTAL(.FILESPEC[FILEPROJNUM]); TYPECHR(",");
	PRINTOCTAL(.FILESPEC[FILEPROGNUM]);
	S_FILESPEC[SFDLIST];
	UNTIL @.S EQL 0 
	DO (TYPECHR(","); PRINTSIXBIT(@.S); S_.S+1);
	TYPECHR("]")
	END
END;
			%
THIS ROUTINE PARSES FILE SPECIFICATIONS; IT IS CALLED FROM A
VARIETY OF PLACES.  THE FILESPECIFICATION IS RETURNED IN
FILESPEC READY FOR AN OPEN/LOOKUP/ENTER WHAT HAVE YOU.  BUFFER
HEADERS AND FILE STATUS ARE NOT SET UP.  THE LAST CHARACTER
(WHICH TERMINATED THE FILE SPEC SCAN) WILL BE RETURNED WHEN
NEXTCHAR/CHARBSU IS NEXT CALLED.  THIS ROUTINE DOES NOT 
UNDERSTAND SWITCHES, CALLER MUST DO THIS.
			%

GLOBAL ROUTINE READSPEC=
BEGIN

!STATE TRANSITION TABLE TO PARSE FILE SPECIFICATIONS.
BIND FILTRANSTAB=PLIT(
!  SP  A-Z 0-9  /   (   )   *  +-   ,   =   [   ]   :   .   ?      EOL   EOF
X ( 0,  1,  1, 63, 63, 63, 63, 63, 63, 63,  4, 63, 63, 63, 63, 63, 63, 63),	!0 DELETE BLANKS
X (63,  1,  1, 63, 63, 63, 63, 63, 63, 63,  4, 63,  2,  3, 63, 63, 63, 63),	!1 PARSE FILE/DEVICE
X (63,  2,  2, 63, 63, 63, 63, 63, 63, 63,  4, 63,  2,  3, 63, 63, 63, 63),	!2 PARSE DEVICE
X (63,  3,  3, 63, 63, 63, 63, 63, 63, 63,  4, 63, 63, 63, 63, 63, 63, 63),	!3 PARSE EXTENSION
X ( 4, 63,  4, 63, 63, 63, 63, 63,  5, 63, 63, 63, 63, 63, 63, 63, 63, 63),	!4 PROJECT NUMBER
X ( 5, 63,  5, 63, 63, 63, 63, 63,  6, 63, 63, 63, 63, 63, 63, 63, 63, 63),	!5 PROG NUMBER
X ( 6,  6,  6, 63, 63, 63, 63, 63,  6, 63, 63, 63, 63, 63, 63, 63, 63, 63));	!6 SFD LISTS


!ACTION TABLE FOR EACH OF ABOVE STATES
BIND FILEACTTAB=PLIT(
!  SP  A-Z 0-9  /   (   )   *  +-   ,   =   [   ]   :   .   ?      EOL   EOF
X ( 0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0),	!0
X ( 4,  1,  1,  4,  4,  4,  4,  4,  4,  4,  4,  4,  3,  4,  4,  4,  4,  4),	!1
X ( 4,  1,  1,  4,  4,  4,  4,  4,  4,  4,  4,  4,  3,  4,  4,  4,  4,  4),	!2
X ( 5,  1,  1,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5),	!3
X ( 0,  6,  2,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6),	!4
X ( 0,  7,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7),	!5
X ( 0,  1,  1,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8));	!6
!
!DESCRIPTION OF ROUTINES
!0 -- NULL ROUTINE
!1 -- CONCATENATES THIS CHARACTER TO LAST
!2 -- BUILDS OCTAL NUMBER
!3 -- STORES STRING AS DEVICE NAME
!4 -- STORES STRING AS FILE NAME
!5 -- STORES STRING AS EXTENSION
!6 -- STORES PROJECT NUMBER
!7 -- STORES PROGRAMMER NUMBER
!8 -- STORES A SFD NAME

OWN	CNT,SFDCNT,BP,TEMP,NUMBER,STATE,PFLAG;
REGISTER	STRCHAR C;
ROUTINE SCANINI=(CNT_6; BP_TEMP<36,6>; TEMP_NUMBER_0);

ZEROSPEC();			!START BY ZEROING FILE SPEC BLOCK
FILESPEC[FILEDEVICE]_SIXBIT 'DSK'; !DEFAULT
FILESPEC[FILEPPN]_.MYPPN;	!DEFAULT

PFLAG_STATE_0; SFDCNT_-1; DOTFLAG_0;
SCANINI();


UNTIL .STATE EQL 63		!ESCAPE
DO
    BEGIN
    C_CHARBSU();		!NEXT CHARACTER + BSU REPRESENTATION
    CASE ACTION(FILEACTTAB,STATE,C[CLASS]) OF SET

	%0 -- NULL%	;

	%1 -- CONC CHAR%	IF (CNT_.CNT-1) GEQ 0 THEN REPLACEI(BP,.C[ASCII]-#40);

	%2 -- BUILD NUM%	NUMBER _ .NUMBER * #10 + .C[ASCII] - #60;

	%3 -- DEVICE%		(FILESPEC[FILEDEVICE]_.TEMP; SCANINI());

	%4 -- FILE NAME%	(FILESPEC[FILENAME]_.TEMP; SCANINI());

	%5 -- EXTENSION%	(FILESPEC[EXTENSION]_.TEMP<LH>; DOTFLAG_1; SCANINI());

	%6 -- PROJ NUM%		(FILESPEC[FILEPROJNUM]_.NUMBER; PFLAG_-1; SCANINI());

	%7 -- PROG NUM%		(FILESPEC[FILEPROGNUM]_.NUMBER; PFLAG_-1; SCANINI());

	%8 -- SFD NAME%		BEGIN
				IF (SFDCNT_.SFDCNT + 1) LEQ 4
				    THEN (FILESPEC[SFDLIST]+.SFDCNT)<0,36>_.TEMP;
				SCANINI()
				END
    TES;
    STATE_ACTION(FILTRANSTAB,STATE,C[CLASS]);
    END;


!FIXUP SFD POINTER TO BE REAL PPN IN CASE NO SFDS
FILESPEC[SFDPTR] _ IF .FILESPEC[SFDLIST] NEQ 0
			THEN FILESPEC[SFDLIST]<ADDR>-3
			ELSE IF .PFLAG LSS 0
			    THEN  .FILESPEC[FILEPPN]
			    ELSE 0;

RESCAN(.C[ASCII])		!LET CALLER HANDLE
END;
	                        %
CORE ALLOCATION ROUTINES:  TELL SETS UP INTERNAL DYNAMIC LINKED LISTS 
ANYWHERE A VARIABLE AMOUNT OF STORAGE IS REQUIRED.  THERE ARE TWO ROUTINES:
ALLOCATE    WILL RETURN THE ADDRESS OF WHERE TO PUT A NEW BLOCK OF DATA.
NEXTITEM    WILL RETURN THE NEXT ITEM ON THE LINKED LIST.
BOTH ROUTINES REQUIRE AS ARGUMENTS THE ADDRESS OF THE LIST HEADER (SEE
TELPRM FOR DETAILS ON FORMAT).  THE LIST HEADER MAY BE SET UP BY THE
INITSTORAGE OR INITSCAN MACROS.
	                        %



GLOBAL ROUTINE ALLOCATE(LIST)=
BEGIN REGISTER T;
MAP STRCORE LIST;

IF .LIST[FREE] LSS .LIST[ITEMSIZE]		!ENOUGH ROOM THIS BLOCK?
	THEN
	    BEGIN                       	!NOT ENOUGH SPACE IN THIS BLOCK, GET ANOTHER
	    T _ .JOBFF<0,18>+1;  JOBFF<0,18>_.T+.LIST[BLOCKSIZE];
	    IF .JOBFF<0,18> GTR .JOBREL<0,18>
	        THEN
	            BEGIN REGISTER C;
	            C _ .JOBFF<0,18>;
	            IFSKIP CORE(C) 
	                THEN %OK%
	                ELSE ERROR(HARD,'ISC Insufficient core ');
	            END;
	    IF .LIST[HEADER] EQL 0		!LINK THIS BLOCK
		THEN LIST[HEADER]_.T		!FIRST BLOCK IN LIST
		ELSE LIST[LINK]_.T;		!NOT FIRST, POINT TO THIS ONE FROM LAST
	    LIST[CURRENT]_.T; LIST[LINK]_0;	!POINT LIST HEADER AT THIS ONE	
	    LIST[FREE]_.LIST[BLOCKSIZE];	!NUMBER OF FREE WORDS
	    T<LH>_.LIST[CURRENT]; T<RH>_.LIST[CURRENT]+1;
	    (.LIST[CURRENT])<0,36>_0; BLT(T,.LIST[CURRENT]+.LIST[BLOCKSIZE]-1);
	    END;
T_.LIST[CURRENT]+(.LIST[BLOCKSIZE]-.LIST[FREE]);
LIST[FREE]_.LIST[FREE]-.LIST[ITEMSIZE];
LIST[ITEMCOUNT]_.LIST[ITEMCOUNT]+1;
.T
END;


			%
ROUTINE TO INITIALIZE LIST HEADER FOR A SCAN OF DYNAMIC LIST.  IT SETS UP
SCANADDR	CURRENT ADDRESS TO FETCH AN ITEM
SCANCURR	POINTER TO CURRENT BLOCK (SCANADDR IS WITHIN BLOCK POINTED TO
		BY SCANCURR)
SCANFREE	THE NUMBER OF WORDS LEFT IN THIS BLOCK.
			%

GLOBAL ROUTINE INITSCAN(LIST)=
BEGIN MAP STRCORE LIST;
LIST[SCANADDR] _ LIST[SCANCURR] _ .LIST[HEADER];	!CURRENT BLOCK, FIRST ADDRESS
LIST[SCANLEFT] _ IF .LIST[SCANCURR] EQL .LIST[CURRENT]	!LAST BUFFER?
			THEN .LIST[BLOCKSIZE]-.LIST[FREE] !YES -- ONLY PARTIALLY FULL
			ELSE .LIST[BLOCKSIZE];		!NO --  COMPLETELY FULL
END;





			%
THIS ROUTINE RETURNS THE ADDRESS OF THE NEXT ITEM ON A LIST, OR 0 IF THERE
IS NO NEXT ITEM.  BEFORE CALLING THIS ROUTINE, THE INITSCAN ROUTINE MUST BE
EXECUTED.
			%
GLOBAL ROUTINE NEXTITEM(LIST)=
BEGIN REGISTER A;
MAP STRCORE LIST;

IF .LIST[SCANCURR] EQL 0			!END OF LIST (OR EMPTY LIST?)
    THEN 0                      		!HAVE REACHED END OF LIST
    ELSE					!NO
	BEGIN
	A_.LIST[SCANADDR];			!NEXT ADDRESS ON LIST
	LIST[SCANADDR]_.LIST[SCANADDR]+.LIST[ITEMSIZE];
	IF (LIST[SCANLEFT]_.LIST[SCANLEFT] - .LIST[ITEMSIZE]) LEQ 0
	    THEN				!FINISHED BUFFER, GET NEXT
		BEGIN
		LIST[SCANADDR]_LIST[SCANCURR]_.LIST[SCANLINK];
		LIST[SCANLEFT] _ IF .LIST[SCANCURR] EQL .LIST[CURRENT]
		    THEN .LIST[BLOCKSIZE] - .LIST[FREE]
		    ELSE .LIST[BLOCKSIZE];	!LAST BUFFER MAY BE ONLY PARTIALLY FULL
		END;
	.A
	END
END;
	                    %
SWITCH HANDLING ROUTINE:  THIS ROUTINE IS CALLED ALMOST EVERYWHERE IF A "/"
IS SEEN.  IT PARSES THE SWITCH AND TAKES APPROPRIATE ACTION.  NOTE THAT NO
SWITCH TABLE IS PASSED; THIS IS BECAUSE ALL SWITCHES IN THE TELL SYSTEM MAY
BE USED ANYWHERE AND ARE CONSIDERED GLOBAL IN SCOPE.
	                    %

GLOBAL ROUTINE SWITCHRTN=
BEGIN

!STATE TRANSITION TABLE:  THE TABLE HANDLES CONSTRUCTIONS LIKE 
!/SWITCH, /SWITCH:VALUE, OR EVEN /SWITCH:(VALUE1,VALUE2,...,VALUEN).
!THE ARRAY "SWITCH" GETS IN ITS FIRST LOCATION THE ACTUAL SWITCH, THE REST
!ARE THE VALUES. THE NUMBER OF VALUES, INCLUDING THE SWITCH ITSELF, IS
!IN SWTCNT.
BIND	NEXTSTATE=PLIT(
!  SP  A-Z 0-9  /   (   )   *  +-   ,   =   [   ]   :   .   ?      EOL  EOF
X (63,  1,  1,  0, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63),	!0 -- SCAN SWITCH
X (63,  1,  1,  0,  4, 63, 63, 63, 63, 63, 63, 63,  2, 63, 63, 63, 63, 63),	!1 -- SCAN SWITCH
X (63,  3,  3,  0,  4, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63),	!2 -- PROCESS VALUES
X (63,  3,  3,  0, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63),	!3 -- PROCESS SINGLE VALUE
X ( 4,  5,  5,  0, 63, 63, 63, 63,  4, 63, 63, 63, 63, 63, 63, 63, 63, 63),	!4 -- SCAN FOR MULTIPLE VALUES
X ( 4,  5,  5,  0, 63,  6, 63, 63,  4, 63, 63, 63, 63, 63, 63, 63, 63, 63),	!5 -- BUILD A MULTIPLE VALUE
X (63, 63, 63,  0, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63),	!6 -- SCAN PAST CLOSING ")"

!NOTE: ONLY GET INTO STATES 7-9 IF /GROUP SEEN IN SWITCH.INI.  SPECIAL VARIABLE
!"FORCE" IS SET TO GET US HERE.
X ( 7,  8,  8,  0,  7,  0, 63, 63,  8, 63, 63, 63, 63, 63,  8, 63, 63, 63),	!7 -- SCAN FOR GROUP NAME
X ( 9,  8,  8,  0, 63, 63, 63, 63,  8,  9, 63, 63,  9,  8, 63, 63, 63, 63),	!8 -- BUILD GROUP NAME
X ( 9, 63, 63,  0, 63,  6, 63, 63,  9, 63, 63, 63, 63, 63, 63, 63, 63, 63)	!9 -- GET GROUP LIST
);

!ACTION TABLE
BIND ACTIONTAB=PLIT(
!  SP  A-Z 0-9  /   (   )   *  +-   ,   =   [   ]   :   .   ?      EOL  EOF
X ( 3,  1,  1,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3),	!0
X ( 3,  1,  1,  3,  2,  3,  3,  3,  3,  2,  3,  3,  2,  3,  3,  3,  3,  3),	!1
X ( 3,  1,  1,  3,  0,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3),	!2
X ( 3,  1,  1,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3),	!3
X ( 0,  1,  1,  3,  3,  3,  3,  3,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3),	!4
X ( 2,  1,  1,  3,  3,  3,  3,  3,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3),	!5
X ( 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0),     !6
X ( 0,  1,  1,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0),	!7
X ( 4,  1,  1,  0,  0,  0,  0,  1,  0,  4,  0,  0,  4,  1,  0,  0,  0,  0),	!8
X ( 4,  5,  5,  5,  5,  5,  5,  4,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5)	!9
);

!A WORD ABOUT THE ROUTINES:
!0  IS THE NULL ROUTINE
!1  CONCATENATES THIS CHARACTER ONTO "TEMP"
!2  PUSHES THE CURRENT SWITCH OR VALUE ONTO THE STACK IN "SWITCH"
!3  PROCESSES THE SWITCH AND VALUES WHICH HAVE BEEN PUSHED ON "SWITCH"
!4  CALLS NAMEPARSE TO PROCESS THE NAMES AND +- CONVENTIONS.
!5  PUTS THE GROUP NAME JUST DEFINED ONTO "GROUPLIST" FOR LATER ACCESS.
!VALUED SWITCH PROCESSING
!
!DISPOSE TABLE COPIED FROM TELMES (SINCE BLISS CAN'T DO A GLOBAL BIND TO A
!PLIT FOR SOME REASON)
!
BIND DISPOSETABLE=PLIT(
SIXBIT	'HELP',			!0
SIXBIT  'TYPE',			!1 TYPE MESSAGES
SIXBIT	'SAVE',			!2 SAVE MESSAGES
SIXBIT  'HOLD',			!3 PUT MESSAGES ON HOLD
SIXBIT	'REPLY',		!4 RESPOND TO THIS MESSAGE
SIXBIT	'DELETE',		!5 DELETE THIS MESSAGE
SIXBIT	'FORWAR',		!6 FORWARD IT TO SOMEONE
SIXBIT	'COPY',			!7 COPY TO DISK/LPT ETC.
SIXBIT	'EXIT');		!8 EXIT NOW

OWN	RSCAN;			!KLUDGE TO LET /DIS:COPY:FILE-SPEC WORK

ROUTINE DISPRTN=		!SETS ABOVE SWITCHES
BEGIN
	DISPOPTION_.P1;		!SET THE DISPOSE OPTION TO BE WHAT USER TYPED
	IF .P1 EQL 7 %COPY%
	  THEN
	    BEGIN REGISTER S;
	    READSPEC();		!READ THE FILE-SPEC THAT FOLLOWS
	    IF .DOTFLAG EQL 0 THEN FILESPEC[EXTENSION]_SIXBIT "MAI";
	    S<LH>_FILESPEC<0,0>; S<RH>_COPYSPEC<0,0>;
	    BLT(S,COPYSPEC+13);	!SAVE THE FILE-SPEC IN A SAFE PLACE
	    COPYFLAG_RSCAN_-1;	!INDICATE FOR LATER THAT WE ARE COPYING BY DEFAULT
	    END
	  ELSE
	    COPYFLAG_0;		!NOT COPYING BY DEFAULT
END;





!
!QUERY TABLE.  SETS THE VALUE OF THE /QUERY SWITCH
!
BIND QUERYTABLE=PLIT(
SIXBIT	'NEVER',		!NEVER QUERY 
SIXBIT	'AFTER',		!QUERY AFTER MESSAGE PRINTED
SIXBIT	'BEFORE',		!QUERY BEFORE MESSAGE PRINTED
SIXBIT	'BOTH',			!QUERY BOTH BEFORE AND AFTER
SIXBIT	'N',			!NEVER QUERY
SIXBIT	'NONE');		!NEVER QUERY

ROUTINE QUERYRTN=
BEGIN
CASE .P1 OF SET
%0 NEVER%	QUERYBEFORE_QUERYAFTER_0;
%1 AFTER%	(QUERYAFTER_1; QUERYBEFORE_0);
%2 BEFORE%	(QUERYBEFORE_1; QUERYAFTER_0);
%3 BOTH%	QUERYAFTER_QUERYBEFORE_1;
%4 N%		QUERYBEFORE_QUERYAFTER_0;
%5 NONE%	QUERYBEFORE_QUERYAFTER_0;
TES;
END;
			%
THIS ROUTINE HANDLES THE SWITCHES WE HAVE SO PAINSTAKINGLY COMPILED (WITH THE
EXCEPTION OF THE /GROUP SWITCH, WHICH BY ITS VERY NATURE IS A SPECIAL KLUDGE).
WHEN THIS ROUTINE IS CALLED, THE ARRAY SWITCH HAS THE SWITCH AND POSSIBLE 
VALUES.  SWITCH[0] IS THE INDEX INTO SWTAB OF THE SWITCH; SWITCH[1] THROUGH
SWITCH[.SWTCNT-1] ARE THE VALUES(S) FOR THE SWITCH IN SIXBIT.
			%


FORWARD VALUEDSWITCH;
BIND	SWTAB=PLIT(
SIXBIT 'GROUP',		!0 -- GROUP DEFINITION ***MUST BE INDEX 0***
SIXBIT 'CC',		!1 -- PRINT CC:LIST
SIXBIT 'NOCC',		!2 -- DON'T PRINT CC:LIST
SIXBIT 'QUERY',		!3 -- PROMPT WHEN TYPING MESSAGES
SIXBIT 'DISPOS',	!4 -- WHAT TO DO AFTER TYPING MESSAGE
SIXBIT 'HOLD',		!5 -- PRINT MESSAGES ON HOLD
SIXBIT 'SAVE',		!6 -- SAME AS /DISPOSE:SAVE
SIXBIT 'SMART',		!7 -- I AM A KNOWLEDGEABLE USER
!EDIT-2 IN SWTAB
!SIXBIT 'UNREAD';)	!8 --WANTS TO SEE ONLY UNREAD MESSAGES
SIXBIT 'UNREAD',	!8 -- WANTS TO SEE ONLY UNREAD MESSAGES
SIXBIT 'BATCH');	!9 -- NO INTERRACTIVE USER


REGISTER STRCHAR C,SWTCNT,CHRCNT,STATE;
OWN    TEMP[2],BP,FORCE;
!EDIT-2
!OWN	SWITCH[10];
OWN	SWITCH[11];

ROUTINE DOSWITCH=
BEGIN

IF .SWTCNT GTR 9					!TOO MANY VALUES?
    THEN
	(SWTCNT_9; ERRORC(SOFT,'TMV Too many values for switch ');
	 PRINTSIXBIT(.SWTAB[.SWITCH[0]]); ERRFIN());

CASE .SWITCH[0]+2 OF SET
	(ERRORC (SOFT,'ASW Ambiguous switch:');		!-2 FROM MATCHNAME
	PRINTSIXBIT(.SWITCH[1]); ERRFIN());
	(ERRORC (SOFT,'UNS Unknown switch:');		!-1 FROM MATCHNAME
	PRINTSIXBIT(.SWITCH[1]); ERRFIN());
	ERROR(SOFT,'GLS /GROUP legal in SWITCH.INI only'); !0 IS (ILLEGAL) GROUP SWITCH
	CCPRT_1;					!1 /CC
	CCPRT_0;					!2 /NOCC
	VALUEDSWITCH(QUERYTABLE,QUERYRTN);		!3 /QUERY
	VALUEDSWITCH(DISPOSETABLE,DISPRTN);		!4 /DISPOSE
	HOLDPRINT_1;					!5 /HOLD
	DISPOPTION_2;					!6 /SAVE
	IAMSMART_1;					!7 /SMART
	UNREAD_1;					!8 /UNREAD
!EDIT-2 IN DOSWITCH
	IAMBATCH_1;					!9 /BATCH
TES;
SWTCNT_0;
END;

ROUTINE SCANINI=
	BEGIN CHRCNT_12; BP_(TEMP-1)<0,6>; TEMP[0]_TEMP[1]_0;  END;


!ROUTINE TO ADD A SWITCH OR VALUE TO THE SWITCH ARRAY.  CHECKS FOR
!TOO MANY AND NEAT THINGS LIKE THAT. ALSO, IF SWITCH IS /GROUP,
!SETS FORCE TO 7 TO HANDLE USER NAMES.

ROUTINE PUSHSWITCH=
BEGIN
IF .SWTCNT LEQ 9					!IF ROOM
    THEN
	BEGIN
	IF .SWTCNT EQL 0				!ACTUALLY SWITCH, NOT VALUE?
	    THEN
		BEGIN
		SWITCH[0]_MATCHNAME(.TEMP,SWTAB);
		IF .SWITCH[0] LSS 0 THEN (SWITCH[1]_.TEMP; SWTCNT_1);
		IF .SWITCH[0] EQL 0 AND .SWITCHSCAN	!CHECK FOR /GROUP
		    THEN (INITSTORAGE(TELLIST,3,30); FORCE_7); !IF SO, MAKE STATE 7 AND CLEAR LIST
		END
	    ELSE
		SWITCH[.SWTCNT]_.TEMP;			!NOT SWITCH, BUT VALUE
	END;
SWTCNT_.SWTCNT+1;
SCANINI()
END;


!ROUTINE TO PROCESS MULTIPLE VALUED SWITCHES. FIRST ARGUMENT IS A TABLE
!OF POSSIBLE VALUES; SECOND ARGUMENT IS ROUTINE TO CALL TO SET PARAMETERS,
!IF VALUE IS KNOWN.  P1 WILL CONTAIN INDEX OF SWITCH VALUE IN TABLE.
ROUTINE VALUEDSWITCH(TABLE,RTN)=
BEGIN

DECR J FROM .SWTCNT-1 TO 1 DO
    BEGIN
    P1_MATCHNAME(.SWITCH[.J],.TABLE);		!FIND INDEX IN TABLE
    IF .P1 GEQ 0
	THEN (.RTN)()				!REALLY THERE--GO CALL ROUTINE
	ELSE
	    BEGIN				!ERROR--UNKNOWN OR AMBIGUOUS SWITCH
	    IF .P1 EQL -2 THEN ERRORC(SOFT,'AVS Ambiguous value "')
			  ELSE ERRORC(SOFT,'UVS Unknown value "');
	    PRINTSIXBIT(.SWITCH[.J]); TYPE ('" for switch ');
	    PRINTSIXBIT (.SWTAB[.SWITCH[0]]); ERRFIN();
	    END;
    END;
END;
STATE_0; SWTCNT_0; SCANINI(); FORCE_0;
UNTIL .STATE EQL 63                 !63 IS ESCAPE
    DO
	BEGIN
	RSCAN_0;		!IF NON-0, WE SHOULD NOT RESCAN THE CHARACTER
				!THAT WE THINK IS THE TERMINATOR--MORE HAS
				!ACTUALLY BEEN SCANNED, AND THE CORRECT
				!TERMINATOR IS SET UP
	C_CHARBSU();                !NEXT INPUT CHARACTER + BSU REPRESENTATION
	CASE ACTION(ACTIONTAB,STATE,C[CLASS])
	  OF SET
	    %0  THE NULL ROUTINE % ;
	    %1  CONCATENATE A CHAR%  IF (CHRCNT_.CHRCNT-1) GEQ 0 THEN REPLACEI(BP,.C[ASCII]-#40);

	    %2 PUSH SWITCH/VALUE %	PUSHSWITCH();

	    %3 PROCESS SWITCHES  %	(PUSHSWITCH(); DOSWITCH());

	    %4  GET LIST OF USER NAMES%     NAMEPARSE();

	    %5  ADD GROUP TO GROUPLIST%     BEGIN MACRO T=SWTCNT$,B=CHRCNT$; MAP STRNAME T;
					    T_ALLOCATE(GROUPLIST);		!ROOM FOR ANOTHER GROUP
					    T[NM1]_.TEMP[0]; T[NM2]_.TEMP[1];
					    T[NAMEFLAGS]_0; T[GROUPFLAG]_1;	!CLEAR ALL FLAGS BUT GROUPFLAG
					    B<RH>_.T+3; B<LH>_TELLIST<ADDR>;
					    BLT(B,(HEADERSIZE-1)+3,T);		!COPY LIST HEADER
					    SWTCNT_0; SCANINI()
					    END
	    TES;
	IF .RSCAN NEQ 0 THEN C_CHARBSU();
	STATE_ACTION(NEXTSTATE,STATE,C[CLASS]);
	IF .FORCE NEQ 0 THEN (STATE_.FORCE; FORCE_0);
	END;

RESCAN(.C[ASCII]);		!LET CALLING ROUTINE HANDLE TERMINATOR
END;
	                    %
TTY HANDLING ROUTINES.  THERE ARE TWO LEVELS OF TTY ROUTINES: THE LOWER LEVEL
RETURNS JUST THE ASCII REPRESENTATION OF THE INPUT STREAM, IGNORING NULLS.
THE TOP LEVEL RETURNS BOTH THE ASCII REPRESENATION AND AN INTERNAL CHARACTER
CLASS (SEE TELPRM.BLI FOR VALUES).  THE TOP LEVEL ALSO MASSAGES THE DATA,
DELETING CARRIAGE RETURNS, TRANSLATING FORM FEEDS, VERTICAL TABS, ETC. TO
LINE FEEDS.  THE INTENTION IS THAT THE TOP LEVEL BE USED FOR COMMAND SCANNING;
THE LOWER LEVEL FOR MESSAGE TEXTS.  THE LOW LEVEL WILL TREAT "@" AS A INDIRECT
FILE COMMAND IF THE FLAG INDIRECTOK IS SET; THE CHARACTERS IMMEDIATELY
FOLLOWING THE "@" SHOULD BE A FILE SPECIFICATION.
	                    %


GLOBAL 	DSKBUFH[3];
OWN	REREAD;
BIND	DSKPTR=(DSKBUFH+1)<0,36>,
	DSKCNT=(DSKBUFH+2)<0,36>;
	            %
ROUTINE TO CLEAR TO END-OF-LINE.  MAKE SURE THAT THERE IS SOMETHING IN THE
BUFFER (I.E. A LINE FEED, OR OTHER CHARACTER) BEFORE CALLING; OTHERWISE
THE TERMINAL WILL HANG IN TI STATE.
	            %
GLOBAL ROUTINE CLREOL=
BEGIN REGISTER STRCHAR C;
DO
    C_CHARBSU()
UNTIL
    .C[CLASS] EQL EOL OR .C[CLASS] EQL EOF;
END;


	            %
ROUTINE TO READ IN SIXBIT WHAT THE USER TYPED.
	            %
GLOBAL ROUTINE SIXREAD=
BEGIN
	REGISTER STRCHAR C;
	LOCAL T,BP,COUNT;

BP_T<36,6>; T_0;			!BYTE POINTER TO REGISTER
DO
    C_CHARBSU()				!READ A CHARACTER
UNTIL
    .C[CLASS] NEQ BLANK;		!UNTIL WE GET SOMETHING BESIDES A BLANK
COUNT_6;
UNTIL					!NOW STORE UNTIL WE GET A BREAK
    .C[CLASS] NEQ ALPHA			!ACCEPT ONLY A-Z IN COMMAND NAME
DO
    (IF (COUNT_.COUNT-1) GEQ 0 THEN REPLACEI(BP,.C[ASCII]-#40); C_CHARBSU());
REREAD_.C[ASCII];
.T
END;

	            %
ROUTINE TO RESCAN THE LAST CHARACTER.  CALL WITH ARGUMENT THE CHARACTER
WHICH IS TO BE RETURNED ON NEXT CALL TO CHARBSU OR NEXTCHAR.
	            %

GLOBAL ROUTINE RESCAN(C)=REREAD_.C;


GLOBAL ROUTINE YES=
BEGIN
	LOCAL A,STRCHAR C;
	BIND YESTAB=PLIT(SIXBIT 'YES',SIXBIT 'NO');
	DO
	    BEGIN
	    A_SIXREAD();
	    IF .A EQL 0
	      THEN
		BEGIN
		C_CHARBSU();
		IF .C[ASCII] EQL #15 %CR%
		    THEN (CLREOL(); RETURN 0);  !IF JUST A CR, NO.
		IF .C[CLASS] EQL EOL
		    THEN RETURN 0;		!IF JUST ANY BREAK, NO.
		CLREOL();
		A_-1;				!NO SIXBIT WORD!
		END
	      ELSE
		BEGIN
		CLREOL();
		A _ CASE MATCHNAME(.A,YESTAB)+2
		    OF SET
		    -1;	!AMBIGUOUS
		    -1;	!UNKNOWN
		    1;	!YES
		    0;	!NO
		    TES;
		END;
	    IF .A LSS 0 THEN TYPE('??Please answer YES or NO: ');
	    END
	UNTIL
	    .A GEQ 0;
	.A
END;


!EDIT-1 INCLUSION OF A ROUTINE ONLY ALLOWING YES AND NO RESPONSES
GLOBAL ROUTINE YESCHECK=
BEGIN
	LOCAL A,STRCHAR C;
	BIND YESTAB=PLIT(SIXBIT 'YES',SIXBIT 'NO');
	DO
	    BEGIN
	    A_SIXREAD();
	    IF .A EQL 0
	      THEN
		BEGIN
		C_CHARBSU();
		IF .C[ASCII] EQL #15 %CR%
		    THEN CLREOL();  !IF JUST A CR, NOT ENOUGH.
		IF  NOT .C[CLASS] EQL EOL THEN CLREOL();
		A_-1;				!NO SIXBIT WORD!
		END
	      ELSE
		BEGIN
		CLREOL();
		A _ CASE MATCHNAME(.A,YESTAB)+2
		    OF SET
		    -1;	!AMBIGUOUS
		    -1;	!UNKNOWN
		    1;	!YES
		    0;	!NO
		    TES;
		END;
	    IF .A LSS 0 THEN TYPE('??Please answer YES or NO: ');
	    END
	UNTIL
	    .A GEQ 0;
	.A
END;
!THIS IS THE TOP LEVEL ROUTINE; IT RETURNS TWO PARAMETERS MAPPED BY THE STRUCTURE
!STRCHAR: THE CHARACTER CLASS (EOL, EOF, ETC. -- SEE TELPRM.BLI) AND THE FIXED
!UP ASCII VALUE OF THE CHARACTER.  "FIX UPS" INCLUDE MAKING LOWER CASE UPPER,
!AND DELETING CARRIAGE RETURNS.

GLOBAL ROUTINE CHARBSU=
BEGIN
REGISTER STRCHAR C,IDX;

MACRO XX(A,B,C,D,E,F,G,H,J,K,L,M,N,O)=
A^31+B^26+C^21+D^16+E^11+F^6+G^1,H^31+J^26+K^21+L^16+M^11+N^6+O^1$;
BIND CLASSCHAR=PLIT(

!  NULL   ^A    ^B    ^C    ^D    ^E    ^F    ^G    ^H    ^I    ^J    ^K    ^L    ^M
!   ^N    ^O    ^P    ^Q    ^R    ^S    ^T    ^U    ^V    ^W    ^X    ^Y    ^Z    ALT
!   ^\    ^]    ^^    ^_    SP    !     "     #     $     %     &     '     (     )
!   *     +     ,     -     .     /     0     1     2     3     4     5     6     7
!   8     9     :     ;     <     =     >     ?     @     A     B     C     D     E     
!   F     G     H     I     J     K     L     M     N     O     P     Q     R     S
!   T     U     V     W     X     Y     Z     [     \     ]     ^     _           a
!   b     c     d     e     f     g     h     i     j     k     l     m     n     o
!   p     q     r     s     t     u     v     w     x     y     z     {     |     }

XX (OTHER,OTHER,OTHER,OTHER,OTHER,OTHER,OTHER,OTHER,OTHER,BLANK,EOL  ,EOL,  EOL,  OTHER),
XX (OTHER,OTHER,OTHER,OTHER,OTHER,OTHER,OTHER,OTHER,OTHER,OTHER,OTHER,OTHER,EOF  ,EOF  ),
XX (OTHER,OTHER,OTHER,OTHER,BLANK,OTHER,OTHER,ALPHA,OTHER,OTHER,OTHER,OTHER,LPAR ,RPAR),
XX (STAR, PLSMN,COMMA,PLSMN,DOT  ,SLASH,NUMER,NUMER,NUMER,NUMER,NUMER,NUMER,NUMER,NUMER),
XX (NUMER,NUMER,COLON,OTHER,OTHER,EQUAL,OTHER,QMARK,OTHER,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA),
XX (ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA),
XX (ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,LBRAK,OTHER,RBRAK,OTHER,OTHER,OTHER,ALPHA),
XX (ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA),
XX (ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,ALPHA,OTHER,OTHER,OTHER));

BIND BPTAB=PLIT(		!BYTE POINTERS INTO CLASSCHAR
CLASSCHAR<31,5,IDX>,
CLASSCHAR<26,5,IDX>,
CLASSCHAR<21,5,IDX>,
CLASSCHAR<16,5,IDX>,
CLASSCHAR<11,5,IDX>,
CLASSCHAR<6,5,IDX>,
CLASSCHAR<1,5,IDX>);


DO C[ASCII]_NEXTCHAR() UNTIL .C[ASCII] NEQ #15;
IDX _ .C[ASCII] / 7;
C[CLASS]_SCANN(BPTAB[.C[ASCII] MOD 7]);
IF .C[ASCII] GEQ #140
    THEN IF .C[ASCII] LEQ #172
	THEN C[ASCII]_.C[ASCII] XOR #40;
IF .C[ASCII] EQL "#" THEN C[ASCII]_#40;
.C
END;
!THIS IS THE LOWLEVEL ROUTINE; IT RETURNS THE ASCII VALUE OF THE NEXT
!CHARACTER FROM THE INPUT STREAM (EITHER THE TTY OR AN INDIRECT FILE)
!IT UNDERSTANDS "@" AS INDIRECT FILESPEC IF INDIRECTOK IS "1"
!(CURRENTLY ONLY HAPPENS IN TELL).
!VERTICAL TABS AND FORMFEEDS GO TO LINE FEEDS, NULLS ARE DELETED.

GLOBAL ROUTINE NEXTCHAR=
BEGIN
REGISTER C; EXTERNAL LOGGEDIN;
IF @REREAD NEQ 0 THEN (C_@REREAD; REREAD_0; RETURN .C);
DO
	BEGIN LABEL L;
	IF NOT .DSKOPEN
	    THEN
	        BEGIN
		IF .SEENEOL THEN STOP(); 	!IF NOT LOGGEDIN DON'T READ PAST EOL
	        INCHWL(C);
		IF .LOGGEDIN THEN
		    IF .C EQL "?C" %^C% THEN (CALLI (1,#17); C_0) ELSE
		  ELSE SELECT .C OF NSET
		    "?C": %^C% STOP();
		    "?M": %CR% C_"?Z"; !IF NOT LOGIN CHANGE TO ^Z
		    "@": C_ " "; !@ ALLOWED ONLY IF LOGEDIN
		    "?J": %lf% SEENEOL_1;
		    "?Z": %^Z% SEENEOL_1;
		    "?[": %ESC% SEENEOL_1;
		    "?G": %^G (BEL)% SEENEOL_1;
		TESN;
		!IF .C EQL 3 %^C% THEN (CALLI(1,#17); C_0);
	        IF .C EQL "@" AND .INDIRECTOK
	            THEN
	                BEGIN
	                INDIRECTOK_0;
			READSPEC(); CLREOL();	!GET A FILE SPEC
			FILESPEC[FILESTATUS]_0; FILESPEC[FILEBUFS]_DSKBUFH<ADDR>;
			IF NOT OPENSPEC(0)
	                    THEN STOP();		!INDIRECT FILE ERROR
			IF -EXTENDLH(FILESPEC[SIZEWORD]) GTR (128*ATFILESIZE)
			   THEN IF NOT .IAMGOD		!ALLOW INDIRECT FILES ANY SIZE FOR [1,2]
			   THEN ERROR(HARD,'FTB Indirect file too big');  !DISALLOW BIG FILES >5 BLOCKS
			IF NOT CHKACC(5,DSK)
			    THEN ERROR(HARD,'MNR You may not read that indirect file');
			REREAD_C_0;
			DSKOPEN_1;
	                END;
	        END
	    ELSE
	      L:REPEAT
	        BEGIN
		UNTIL (DSKCNT_.DSKCNT-1) GEQ 0
	            DO
	                IFSKIP IN(DSK)
	                    THEN
	                        BEGIN REGISTER S;
	                        GETSTS(DSK,S);
	                        RELEASE(DSK);
	                        DSKOPEN_0;
	                        IF .S AND #740000
	                            THEN (ERRORC(HARD,'IES Input error status ');
	                                  PRINTOCTAL(.S); TYPE (' reading indirect file'); ERRFIN())
	                             ELSE RETURN "?Z";
	                        END;
		INCP(DSKPTR);
		IF .(@DSKPTR)<0,1> EQL 0
		    THEN
			BEGIN
			C_SCANN(DSKPTR);
			LEAVE L
			END
		    ELSE
			BEGIN
			DSKPTR_.DSKPTR+1;
			DSKCNT_.DSKCNT-5
			END;
	        END;
	END
UNTIL
	.C NEQ 0;
IF .C EQL #13 OR .C EQL #14			!CHECK FOR FORM FEED/VERTICAL TAB
	THEN #12				!IF SO TURN TO LINE FEED
	ELSE .C					!OTHERWISE, CHAR IS OK
END;
	            %
GARDEN VARIETY PPN TYPER
	            %
GLOBAL ROUTINE PPNPRINT(THISPPN)=
BEGIN
PRINTCHR("["); PRINTOCTAL(.THISPPN<18,18>); PRINTCHR(",");
PRINTOCTAL(.THISPPN<0,18>); PRINTCHR("]");
END;

	            %
THIS ROUTINE PRINTS NAMES IN A FANCY MANNER.  THE ARGUMENT IS A TWO-WORD
BLOCK OF THE NAME IN SIXBIT; P2 SHOULD POINT TO THE BLOCK.  THE NAME
WILL BE PRINTED IN UPPER/LOWER CASE, WITH CAPITALIZATION FOLLOWING NON-
ALPHABETIC CHARACTERS.  MULTIPLE AND TRAILING BLANKS GET DELETED.
	            % 
GLOBAL ROUTINE PRTNM=
BEGIN REGISTER T;
	MACRO   LOWER=T<35,1>$,      !PRINT A-Z IN LOWER CASE
	        SPACE=T<34,1>$;      !A SPACE IS NEEDED IF ANYTHING ELSE SEEN
T_0; P2<LH>_(0<36,6>)^(-18);
DECR CNT FROM 12 TO 1 
    DO
	BEGIN
	IF (P1_SCANI(P2)) EQL 0      !PICK UP A CHARACTER
	    THEN (SPACE_1; LOWER_0)  !IF SPACE, IGNORE IT, BUT SET FLAG
	    ELSE                     !NOT A SPACE, PRINT SOMETHING
	        BEGIN
	        IF .SPACE THEN (P1_" "; (.P3)(); P1_SCANN(P2); SPACE_0);
	        P1_.P1+" ";              !CONVERT TO ASCII
	        IF .P1 GEQ "A"          !CHECK FOR ALPHABETIC
	            THEN IF .P1 LEQ "Z"
	                THEN (IF .LOWER THEN P1_.P1+#40; LOWER_1)
	                ELSE LOWER_0
	            ELSE LOWER_0;
	        (.P3)();
	        END;
	END;
END;
	                %
THESE ROUTINES GO EITHER TO THE TTY OR SOME OTHER PLACE DEPENDING ON THE
CONTENTS OF GLOBAL REGISTER P3.  THE CALLER MUST SET UP P3 BEFORE COMING HERE.
	                %




OWN	RAD;                    !STORAGE FOR NUMBER PRINT OUT
FORWARD PRTRAD;
GLOBAL  ROUTINE PRTOCT=(RAD_#10; PRTRAD());
GLOBAL  ROUTINE PRTDEC=(RAD_10; PRTRAD());
ROUTINE PRTRAD=
BEGIN REGISTER N;

ROUTINE RECURSE=
	BEGIN LOCAL REM;
	REM_.N MOD .RAD;
	N_.N/.RAD;  IF .N NEQ 0 THEN RECURSE();
	PRINTCHR(.REM+"0");
	END;

IF .P2 LSS 0 THEN PRINTCHR("-"); N_ABS(.P2);
RECURSE()
END;


GLOBAL ROUTINE PRTSXB=
BEGIN
REGISTER T[2];
T[1]_.P2;
DO (T[0]_0; LSHC(T,6); PRINTCHR(" "+.T[0])) UNTIL .T[1] EQL 0
END;



	            %
THIS ROUTINE OUTPUTS A STRING. THE BYTE POINTER IS ASSUME TO BE IN P2,
THE OUTPUT ROUTINE IN P3.
	            %

GLOBAL ROUTINE PRTSTR=
(P2<LH>_0<36,7>^(-18); UNTIL (P1_SCANI(P2)) EQL 0 DO (.P3)(); .VREG);


GLOBAL ROUTINE TTYTYPE=TTCALL(1,P1);
	                %
ERROR ROUTINES:
THERE ARE THREE ENTRY POINTS:
ERR	ARGUMENTS ARE ERROR CODE AND STRING.  PRINTS THE ERROR AND THEN
	DEPENDING ON THE SEVERITY, RETURNS.
ERRC	ARGUMENTS ARE ERROR CODE AND STRING.  PRINTS THE STRING AND RETURNS
	IMMEDIATELY (SO THAT THE CALLING ROUTINE CAN PRINT MORE INFO).
ERRFIN	CALLED AFTER ERRC AND MORE INFO HAS BEEN PRINTED; DOES A GENERAL
	CLEANUP.
	                %
OWN	    SAVECODE;
GLOBAL	ROUTINE ERR(CODE,STR)=
	BEGIN
	SAVECODE_.CODE; TYPEHEAD(); TYPEADR(@STR); ERRFIN();
	END;

GLOBAL	ROUTINE ERRC(CODE,STR)=
	BEGIN
	SAVECODE_.CODE; TYPEHEAD(); TYPEADR(@STR);
	END;

GLOBAL	ROUTINE ERRFIN=
	BEGIN
	TYPE ('?M?J');
	IF .SWITCHSCAN THEN TYPE ('Error occurred during SWITCH.INI scan?M?J');
	IF .SAVECODE EQL SOFT THEN RETURN;
	IF .SAVECODE EQL SYSTEM 
	    THEN TYPE ('This is a system error: please give this typeout to a systems programmer');
	STOP();
	END;


ROUTINE TYPEHEAD=
BEGIN
P3_TTYTYPE;                   !POINT OUTPUT TO TTY FOR ERROR ROUTINES
IF .SAVECODE EQL SOFT
	AND NOT .IAMBATCH THEN TYPE('%TEL')
	ELSE TYPE('??TEL')		!!always if /batch
END;
			%
ROUTINE TO FIND A POTENTIALLY ABBREVIATED COMMAND WITHIN A TABLE. CALL:
MATCHNAME(WORD,TABLE) -- WHERE
WORD	IS THE (SIXBIT) COMMAND TO BE FOUND
TABLE	IS THE ADDRESS OF THE COMMAND TABLE.  SIZE IS ASSUMED TO BE AT
	TABLE-1 (AS IN A PLIT).
THE ROUTINE RETURNS
-2	IF THE COMMAND IS AMBIGOUS
-1	IF THE COMMAND DOESN'T MATCH ANYTHING
0-...	IS THE INDEX OF THE COMMAND WITHIN THE TABLE

ACTUALLY MATCHNAME IS A MACRO: IT PUTS THE COMMAND INTO P1, THE TABLE
ADDRESS INTO P2, AND CALLS MTCHNM.  THIS SAVES A TINY BIT OF LINKAGE OVERHEAD.
			%

GLOBAL ROUTINE MTCHNM=
BEGIN
REGISTER	P,		!P IS INDEX OF POTENTIAL MATCH
		M;		!M IS MASK

IF .P1 EQL 0 THEN RETURN -1;	!0 IS ALWAYS AN INVALID COMMAND
P_#77; M_-1;                    !INITIALIZE MASK AND TEST CODE
UNTIL 
    (.P1 AND .P) NEQ 0
DO
    (M_.M AND NOT .P; P_.P^6);
P_-1;				!ASSUME NO MATCH
DECR INDEX FROM .(.P2)[-1]-1 TO 0
    DO
	IF (.P1 XOR .(.P2)[.INDEX]) EQL 0
	    THEN RETURN .INDEX		    !EXACT MATCH -- RETURN INDEX
	    ELSE
		IF ((.P1 XOR .(.P2)[.INDEX]) AND .M) EQL 0
		    THEN
			P _ IF (P_.P+1) EQL 0	!FOUND APPROXIMATE MATCH
			    THEN .INDEX		!FIRST TIME
			    ELSE -2;		!NOT FIRST TIME
.P
END;
