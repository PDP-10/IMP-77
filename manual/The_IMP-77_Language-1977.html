<HTML><HEAD></HEAD><BODY><PRE>

<HR>

















                             THE IMP-77 LANGUAGE




                              As implemented by

                              PETER S. ROBERTSON
                        DEPARTMENT OF COMPUTER SCIENCE
                           UNIVERSITY OF EDINBURGH




                              A REFERENCE MANUAL

                         first edition: DECEMBER 1977


























<HR>

                                 INTRODUCTION

         IMP-77 is an "ALGOL-like" high-level  language.    Relative  to
      ALGOL 60, the language adds program structuring, data structuring,
      event  signalling, and string handling facilities, but removes (or
      retains in a modified  form)  intrinsically  inefficient  features
      such as the ALGOL 60 <B>name</B> (substitution) parameter.

         The  language, based on Atlas Autocode, was originally designed
      as the implementation  language  for  the  Edinburgh  Multi-Access
      System - hence its name - but has since been used successfully for
      implementing    systems,    teaching    programming   and   as   a
      general-purpose programming language on many different machines.

      Two of the major design aims were:

          1.   The language should compile to efficient machine code.

          2.   The syntax of the language should be verbose rather than
               obscure.

         The main disadvantage of IMP is that it  is  not  currently  in
      widespread use.

         Most   IMP   systems  provide  comprehensive  compile-time  and
      run-time  diagnostics,  together  with  an  option   to   suppress
      generation of run-time checks when compiling tested programs.

         Input/output  facilities  are  provided  through  the  external
      procedure mechanism  and  are  therefore  open-ended  and  can  be
      defined  as  required,  though  a  standard  set  of procedures is
      supported.



























<HR>

                          PROGRAM LAYOUT CONVENTIONS

         An IMP program is a sequence of  <B>statements</B>  constructed  using
      the  ASCII  character  set  extended  with an underlined alphabet.
      Underlined letters, which are used to form <B>keywords</B>, are generated
      using the  shift  character  percent  (%),  which  is  defined  as
      underlining   all   subsequent   letters,  the  underlining  being
      terminated by any non-alphabetic character.
      Hence the following statements are equivalent:

                          %STRING (7)%ARRAY %NAME P
                          %STRING (7)%ARRAYNAME P

      and both represent:
                          <B>string</B>(7)<B>array</B> <B>name</B> P

         In this manual, keywords are in lower case and underlined.


      <B>Newline</B>

         The NEWLINE (or LINE BREAK) character  is  ASCII  character  10
      (LF).


      <B>Spaces</B>

         Except  when  used to terminate keywords or when between quotes
      (see Quotes) spaces are ignored by the compiler and may be used to
      improve the legibility of the program.


      <B>Lower</B> <B>Case</B> <B>Letters</B>

         Except when enclosed in quotes (see Quotes) lower case  letters
      are equivalent to upper case letters.

      <B>Quotes</B>

         Several  language constructions call for one or more characters
      to be enclosed  in  quotes:  between  quotes  <B>all</B>  characters  are
      significant and stand for themselves.
      N.B.    Space,  newline, and percent characters may appear between
      quotes and stand for space, newline, and percent.

         Two quote characters are used:

               '    -    symbol quote e.g. 'A'
               "    -    string quote e.g. "FRED"

      If it is required to include the delimiting quote within the  text
      it must be represented by two consecutive quotes; e.g.

               ''''            -        the symbol quote
               "a ""big"" dog" -        a string of 11 characters

      However, note: '"' and "it's mine"



                                 1-1
<HR>

      <B>Identifiers</B>

         An identifier is a sequence of any number of letters and digits
      starting with a letter, e.g.  MAX, X, CASE 1, CASE 2, CASE 2B

      All letters and digits are significant.

      Except  in  the  case  of  simple  labels  (see  Control  Transfer
      Instructions) all identifiers must be <B>declared</B> before they may  be
      used (see Declarations).


      <B>Statements</B>

         A  STATEMENT  is  a  sequence  of  atomic  elements  (keywords,
      constants, identifiers etc.) arranged according to  the  syntactic
      rules of IMP.


      <B>Termination</B>

         Every  statement must be terminated by a newline or a semicolon
      (however, see Comments).


      <B>Null</B>_<B>Statements</B>

         There are two types  of  null  statement,  both  of  which  are
      ignored  by  the  compiler.    They  may  be  used  to improve the
      legibility of the program.

          1.   Redundant terminators, E.g. blank lines

          2.   Comments

                    A  comment  is  any  sequence  of  characters   (the
                    "comment  text")  preceded  by  a  comment  mark and
                    ending with a newline character (note:  a  semicolon
                    does not terminate a comment; it is included as part
                    of the comment text).
                    The  comment marks are either the keyword <B>comment</B> or
                    an exclamation mark (!); e.g.

                         <B>comment</B> main loop starts here
                         ! return here on error

                    As a semicolon does not terminate a comment it is  a
                    simple matter to 'comment out' sections of code.

                            COMPUTE CASES
                         !  <B>if</B> CASES &lt; 0 <B>start</B>
                         !     DISPLAY DATA;  NEWLINE;  TIDY UP
                         !     <B>stop</B>
                         !  <B>finish</B>
                            HANDLE CASES

                    (Also see note on Continuation)



                                 1-2
<HR>

      <B>Instructions</B>
         An  instruction  is  any imperative statement which may be made
      conditional and is either an  assignment,  a  Routine  call  or  a
      control transfer.


      <B>Continuation</B>
         A  statement  may  extend  over several physical lines provided
      that each line break occurs after a comma, or is preceeded by  the
      keyword <B>c</B>.  E.g.

                   <B>if</B> X = Y <B>then</B> P = 1 <B>c</B>
                            <B>else</B> P = 0

      which is exactly equivalent to:

                   <B>if</B> X = Y <B>then</B> P = 1 <B>else</B> P = 0

          Notes
               1.   A statement may have an unlimited number of
                    continuations.

               2.   The line break following <B>c</B> causes underlining to be
                    terminated.

               3.   <B>c</B> is only permitted between complete atoms of the
                    language;  that  is,  it  may  not  split  keywords,
                    constants, etc.

               4.   %C between quotes  stands  for  the  two  characters
                    percent and C.

               5.   The  effect  of  a  comment  mark  is limited to one
                    physical line (see Null statements).


      <B>Listing</B>_<B>Control</B>

             During the compilation of a program a line-numbered listing
          is produced.   The statements <B>list</B> and <B>endoflist</B> may  be  used
          respectively  to  enable  or  disable the listing for selected
          parts of a program.  The default is for listing to be enabled.


      <B>Include</B>

             A file of statements (terminated by "<B>end</B> <B>of</B> <B>file</B>")  may  be
          compiled into a program by giving the statement
                         "<B>include</B>" {file specification}

          where {file specification} is a string constant representing a
          (system dependent) file name.  E.g.

                         <B>include</B> "ECSC17.LISTVARS"

          Refer to the relevant appendix for details of system-dependent
          limitations on the use of <B>include</B>.



                                 1-3
<HR>

                                  CONSTANTS

      <B>Integer</B>_<B>Constants</B> (<B>Fixed</B>_<B>Point</B>)

          a)   DECIMAL constants
               A decimal constant is a sequence of decimal digits.   For
               example:
                7, 43, 2195, 0, 8, 100 000 000

          b)   NON-DECIMAL constants
               The prefix {decimal constant}"_" may be used  to  specify
               the  base  of the following constant.   The letters A, B,
               .., Z are used to represent the 'digits' 10, 11, .., 35
               E.g.
               2_1010         - binary ten
               8_12           - octal ten
               16_a           - hexadecimal ten

          c)   CHARACTER constants
               The ASCII code value of any character may be obtained  by
               enclosing  the  character  in  single  quotes.   When the
               required  character  is  a  single  quote  it   must   be
               represented by two consecutive single quotes.
               Examples: 'A', 'a', '+', '0', '"', '''', ' ', '
               '
               Note   the   last   three   examples,   which   represent
               respectively the code values for single quote, space, and
               newline.

               The predefined named constant NL may be used in place  of
               the   rather  cumbersome  form  of  a  newline  character
               enclosed in quotes.

          d)   MULTI-CHARACTER constants
               The previous form may be extended to  pack  together  the
               codes  for  several  characters  to form a single integer
               constant.

               'OVER', 'Max', '1+2', '*@@#'

               The exact nature of the packing and the maximum number of
               characters  which  may  be  packed   are   both   machine
               dependent.

          An integer expression with operands which are constants may be
          used   wherever   an   integer   constant   is  required  (see
          Expressions).













                                 1-4
<HR>



      <B>Real</B>_<B>Constants</B> (<B>Floating</B>_<B>Point</B>)

         A real constant is a  sequence  of  decimal  digits  optionally
      including one decimal point.
      The  constant may also be followed by a scaling factor of the form
      "@"{signed integer constant}  meaning  "times  ten  to  the  power
      {signed  integer  constant}".    For  example,  the following real
      constants all have the same value:

               120.0, 120, 1.2@2, 12@1, 1200@-1

      Note that a decimal integer constant is a special case of  a  real
      constant.


      <B>String</B>_<B>Constants</B>

         A string constant is a sequence of not more than 255 characters
      enclosed  in  double  quote  characters  -  a  double  quote being
      represented inside a string constant  by  two  consecutive  double
      quotes.

      E.g. "STARTING TIME", "x = y*4+x", "a ""red"" hood"

               a)   "A" is a <B>string</B> constant of one character.
                    'A' is a character (<B>integer</B>) constant.

               b)   The <B>null</B> <B>string</B>, a string of no characters, is
                    permitted  and  is  represented  by  two consecutive
                    double quotes ("").




























                                 1-5
<HR>




                                 EXPRESSIONS

          1 Arithmetic Expressions

                  An arithmetic expression is a sequence  of  arithmetic
               operands   and  operators  obeying  the  usual  rules  of
               algebra.   An operand is either a constant, a variable, a
               function  call,  a  map  call,  or a numerical expression
               enclosed   in   parentheses   (see    Declarations    and
               Procedures).

               a) Integer Expressions
                       All  the  operands  and  operators  in an integer
                    expression must yield an integer value.
                    The operators available are:

                    +    addition
                    -    subtraction or unary minus
                    *    multiplication
                    //   integer division (the remainder of the
                         division, which is of  the  same  sign  as  the
                         dividend, is ignored).
                    \\   integer  exponentiation.   The  second  operand
                         (the exponent) must be a non-negative integer.


               b) Real Expressions
                       All  the  operands  and  operators  in   a   real
                    expression  must  yield  real  (or integer) results.
                    Where an operator will take either real  or  integer
                    operands  (E.g.  *)  and  the  types  of  the  given
                    operands  differ  the  integer   operand   will   be
                    converted  to  a real value, otherwise the result of
                    the operation will  be  of  the  same  type  as  the
                    original  operands.    The pre-defined real function
                    FLOAT may be used to  force  the  conversion  of  an
                    integer expression into a real expression.
                    The operators available are:

                    +    addition
                    -    subtraction or unary minus
                    *    multiplication
                    /    division
                    \    real exponentiation

                  The modulus (absolute value) of an expression (integer
               or  real)  may  be  obtained by enclosing that expression
               between vertical bars.
               E.g.      |X-Y|








                                 2-1
<HR>

               Notes     1.   Unary minus is treated as "0-..."

                         2.   Unary plus (+) is not accepted.

                         3.   An expression may not contain two adjacent
                              operators -  they  must  be  separated  by
                              parentheses E.g.  23*(-14)

                         4.   Integer  values  will be converted to real
                              where  necessary,  but  real  values  will
                              never  be converted to integer unless this
                              is   explicitly   specified   using    the
                              pre-defined functions INT or INTPT.

          2 Bit-Vector Expressions
                  All  operands  must yield bit-vector (integer) values.
               The operations are performed on a bit-by-bit basis  using
               the operators:

                    &amp;    AND
                    !    INCLUSIVE OR
                    !!   EXCLUSIVE OR
                    &lt;&lt;   LEFT SHIFT (logical)
                    &gt;&gt;   RIGHT SHIFT (logical)
                    \    COMPLEMENT (unary not)

               It  is possible to mix integer and bit-vector expressions
               but  the  full  implications  of  this  may  be   machine
               dependent.


          3 String Expressions
                  All  operands of a string expression must yield values
               of type <B>string</B>.   The only operator available is "."  for
               concatenation (joining together).   No sub-expressions in
               parentheses are permitted.

                  E.g.  "MR ".SURNAME


      <B>Precedence</B>_<B>of</B>_<B>Operators</B>


               Highest:  1.   \  (unary not)
                         2.   \, \\, &lt;&lt;, &gt;&gt;
                         3.   *, /, //, &amp;
               Lowest:   4.   +, - (unary and binary), !, !!

                  In general, sub-expressions with  operators  of  equal
               precedence are evaluated from left to right.
               The  precedence  rules  may  be  over-ridden  by means of
               parentheses.

               Note:     -1\\2 = -1

                         (-1)\\2 = 1

                         2\\2\\3 = 4\\3 = 64


                                 2-2
<HR>


                                 DECLARATIONS

             All identifiers (except simple labels) must be declared  at
          the  start  of a block before they are used.   The <B>scope</B> of an
          identifier is the rest of the block in which it  is  declared,
          including  any  blocks subsequently defined therein (see Block
          Structure and note 3 on Labels and Jumps).
          In  the  following  discussion  the  phrase  {type}  has  four
          variants:
                    1.   "<B>integer</B>"
                    2.   "<B>real</B>"
                    3.   "<B>string</B>" "(" {max} ")"
                    4.   "<B>record</B>" "(" {format} ")"

               and  {max} is an <B>integer</B> constant in the range
                         1&lt;=max&lt;=255  defining  the  maximum  number  of
                         characters which may be held in the string.
                    {format} defines the structure of  the  record  (see
                         Records).

          1.  Variables

               a)   Simple Variables

                    {type}{idlist}

                         <B>integer</B> J,K,COUNT
                         <B>real</B> PRESSURE
                         <B>string</B> (30) COUNTRY, TOWN
                         <B>record</B> (CARFM) MINI, ROVER

                         Each   variable  is  allocated  an  appropriate
                         (machine dependent) amount of storage to hold a
                         value of the appropriate type.

               b)   Pointer Variables

                    {type} "<B>name</B>" {idlist}

                         <B>integer</B> <B>name</B> P
                         <B>real</B> <B>name</B> DATUM
                         <B>string</B> (15) <B>name</B> WHO,WHERE
                         <B>record</B> (CARFM) <B>name</B> CAR

                         Each variable is allocated  enough  storage  to
                         hold  a  pointer  to  (i.e.  the  address of) a
                         simple variable of the specified type.












                                 3-1
<HR>

               c)   Array Pointer Variables

                    {type} "<B>array</B>" "<B>name</B>" {idlist}
                or  {type} "<B>name</B>" "<B>array</B>" "<B>name</B>" {idlist}

                         <B>integer</B> <B>array</B> <B>name</B> AN
                         <B>real</B> <B>array</B> <B>name</B> VALUES
                         <B>string</B> (20) <B>array</B> <B>name</B> NAMES, ADDRESSES
                         <B>record</B> (CARFM) <B>array</B> <B>name</B> MAKE
                         <B>real</B> <B>name</B> <B>array</B> <B>name</B> ANSWERS

                         Each variable is allocated  enough  storage  to
                         hold  a pointer to (i.e. the address of) an one
                         dimensional <B>array</B> of the specified type.

                    ........... "<B>array</B>" "(" {dim} ")" "<B>name</B>" {idlist}

                         is   provided   for   declaring   pointers   to
                         multi-dimensional arrays.  E.g.

                         <B>real</B> <B>array</B> (4) <B>name</B> SPACE TIME
                         <B>integer</B> <B>name</B> <B>array</B> (2) <B>name</B> LISTS

          2.  Arrays

                    {type} <B>array</B> {adefn}("," {adefn})*
                or  {type} "<B>name</B>" "<B>array</B>" {adefn}(","{adefn})*

                    {adefn}     ::= {idlist} "(" {pair}(","{pair})* ")"
                    {pair}      ::= {integer exprn} ":" {integer exprn}

                    <B>integer</B> <B>array</B> A(1:10),B,C(-4:LIMIT)
                    <B>real</B> <B>array</B> Q(1:J+K, 1:J-K)
                    <B>string</B> (12) <B>array</B> CLASS(-7:16)
                    <B>record</B> (CARFM) <B>array</B> TABLE(LOWER:UPPER)
                    <B>integer</B> <B>name</B> <B>array</B> pointers(1:12)

                    The  bound  pairs,  {pair},  are  evaluated  and the
                    required amount of  storage  is  allocated  to  each
                    identifier.

               note 1.   In  each  bound  pair  the  value  of the first
                         expression (lower bound) must be less  than  or
                         equal  to  the  value  of the second expression
                         (upper bound).

                    2.   The number of bound pairs (the dimension of the
                         array) usually may not exceed six, but this  is
                         implementation dependent.


          3.   Records

                  A  <B>record</B>  is  a named collection of variables, arrays
               and records.   The components (elements) of a record  may
               be  any of the forms discussed in (1) and (2) above, with
               the following limitations:



                                 3-2
<HR>

               a.   Arrays must be one dimensional and have constant
                    bounds.
               b.   A record may not contain a simple record (or a
                    record array) of its own format.    However  it  may
                    contain record pointer variables of its own format.

               There are three ways to specify formats:

               1.   Explicit Definition

               <B>record</B> "(" {declaration list} ")" ...

                         <B>record</B> (<B>integer</B> X,Y,Z) R
                         <B>record</B> (<B>real</B> P, <B>real</B> <B>name</B> Q) <B>name</B> S,T
                         <B>record</B> (<B>real</B> <B>array</B> A(1:5), <B>real</B> V) <B>array</B> X(1:4)

               2.   Using a <B>format</B> identifier

               <B>record</B> <B>format</B> {id} "(" {declaration list} ")"
               <B>record</B> "(" {id} ")" ....

                         <B>record</B> <B>format</B> F(<B>integer</B> X, <B>record</B>(F)<B>name</B> LINK)

                         <B>record</B> (F) HEAD
                         <B>record</B> (F) <B>array</B> CELL(1:15)

               3.   Using a previously declared record as a format
                    definition.

                         <B>record</B> (<B>integer</B> ONE, TWO, THREE) R
                         <B>record</B> (<B>like</B> R) S,T

               Note 1.   Within  a format each identifier must be unique
                    but will not clash with any identifiers outwith that
                    format (see Block  Structure  for  a  discussion  of
                    local and global identifiers).

                    2.   When  space  is  allocated to a record variable
                    the elements are laid out in the order in which they
                    were declared.   However see the  relevant  appendix
                    for machine dependent alignment considerations.



















                                 3-3
<HR>

                           RECORD ELEMENT SELECTION

                  Selection  of  a  specific  element  from  a record is
               achieved by following the record identifier by:
                         "_"{element id}

               E.g. given the declarations:

                         <B>record</B> <B>format</B> F(<B>integer</B> X, <B>record</B>(F) <B>name</B> LINK)
                         <B>record</B> (F) R


               some valid references to variables are:

               R              - a record of format F
               R_X            - an integer
               R_LINK         - a pointer to a record of format F
               R_LINK_X       - an integer
               R_LINK_LINK    - a pointer to a record of format F
               R_LINK_LINK_X  - an integer





          ----------------------------------
       R |      R_X      |      R_LINK      |
          ----------------------------------
                               |
                               |
                       ----------------------------------
                      |   R_LINK_X    |   R_LINK_LINK    |
                       ----------------------------------
                                              |
                                              |
                                     ----------------------------------
                                    | R_LINK_LINK_X | R_LINK_LINK_LINK |
                                     ----------------------------------






















                                 3-4
<HR>




                                OWN VARIABLES

                  Each variable declared in a block is allocated storage
               when that block is entered, the  storage  being  returned
               (released)  when  the  block  is  left.   This means that
               variables (and the  values  in  them)  are  lost  between
               traverses of the block.

                  If,   however,   the   prefix  <B>own</B>  is  applied  to  a
               declaration the variables are allocated statically and so
               retain their values when the block is not being  executed
               (see  Procedures).    The  scope  of  the  identifier  is
               unchanged.

                  <B>Own</B> arrays must be one-dimensional and  have  constant
               bounds.



                                INITIALISATION

                  <B>Own</B> variables may be given initial values (effectively
               before the program starts execution); if no initial value
               is specified the content of an <B>own</B> variable is undefined.

                         <B>own</B> <B>integer</B> A,B=4, C=-1
                         ! the initial value in A is undefined
                         <B>own</B> <B>real</B> R=1.234@-5
                         <B>own</B> <B>string</B> (7) WHO="ANON"

               In  the case of <B>own</B> <B>name</B> and <B>own</B> <B>array</B> <B>name</B> variables the
               initial  value  (if  present)  represents  the   absolute
               address  of  respectively  the  initial  variable  to  be
               pointed  at  or  the  (possibly   hypothetical)   'zeroth
               element' of an array.
                         <B>own</B> <B>integer</B> <B>name</B> CLOCK==72
                         <B>own</B> <B>integer</B> <B>array</B> <B>name</B> SAVE AREA == 16

               This is <B>highly</B> <B>machine</B> <B>dependent</B>.

                  If an own array is to be initialised, every element in
               the  array  must be given a value.   In order to simplify
               this  each initial value may be followed by a  repetition
               count  in  parentheses,  and  a  star  (*) may be used to
               represent the number of remaining elements in the  array.
               For  convenience  a repetition count of zero is permitted
               and  means  that  the  initialising  constant  is  to  be
               ignored.   For example the following declarations are all
               equivalent:

                         <B>own</B> <B>integer</B> <B>array</B> A(2:5) = 7,7,7,7

                         <B>own</B> <B>integer</B> <B>array</B> A(2:5) = 7(4)

                         <B>own</B> <B>integer</B> <B>array</B> A(2:5) = 7(*)


                                 4-1
<HR>

                  The list of constants may extend over several physical

               lines without the need for a continuation mark if each

               line ends with a comma; a line break is also allowed

               after the equals sign.



                         <B>own</B> <B>string</B> (3) <B>array</B> MONTH(1:12) =
                         "JAN", "FEB", "MAR",
                         "APR", "MAY", "JUN",
                         "JUL", "AUG", "SEP",
                         "OCT", "NOV", "DEC"

               Any number of null statements may be placed  between  the
               lines of constants.

                     <B>own</B> <B>integer</B> <B>array</B> VALUE(1:50) =;     ! TAG VALUES
                         1,   2,  3,  0(7),
                    !    ------type 1------
                        11,  22, 33,  4(3), 55(4),
                    !    ----------type 2----------
                       111, 222,  3, -1(5),
                    !  ------types 3&amp;4------
                       -2(*);                             ! ALL THE REST



                             CONSTANT IDENTIFIERS

                  The  prefix  <B>constant</B> may replace <B>own</B> to indicate that
               the initial value can never change.   A <B>constant</B>  <B>integer</B>
               may be used wherever an integer constant is required.

                         <B>constant</B> <B>integer</B> MAX = 17
                         <B>constant</B> <B>real</B> PI = 3.14159
                         <B>constant</B> <B>string</B> (7) VERSION = "vsn:1.6"
                         <B>constant</B> <B>integer</B> <B>array</B> VAL(1:MAX) = 1,6,9,-1(*)

               <B>Constant</B> pointer variables may be declared but are highly
               machine and system dependent.

                         <B>constant</B> <B>integer</B> <B>name</B> STATUS REG == 160

                         <B>constant</B> <B>integer</B> <B>array</B> <B>name</B> WORD == 0

               Note:  <B>constant</B> pointers are effectively simple variables
               of  the  appropriate  type  located  at   the   specified
               (absolute) address.



               The keyword <B>constant</B> may be abbreviated to <B>const</B>.





                                 4-2
<HR>

                                  ASSIGNMENT

                  There are three forms of assignment:

          1.   {variable} "=" {expression}

                    X = Y
                    A(P) = A(P)+1
                    Y = BIT&lt;&lt;12
                    PERSON = INITIALS.SURNAME

               The  expression  is  evaluated and the resulting value is
               stored in the given variable.   The expression may be  of
               type  <B>integer</B>,  <B>real</B>, or <B>string</B>, and the variable must be
               of the corresponding type; in the case of a real variable
               an integer expression will have its result  converted  to
               <B>real</B> before being assigned.

               Valid types of assignment are:
               {integer variable} "=" {integer expression}
               {real variable}    "=" {real expression}
               {real variable}    "=" {integer expression}
               {string variable}  "=" {string expression}

          2.   {pointer variable} "==" {variable}

               The  pointer  variable  is dynamically made equivalent to
               the given variable;  the  types  of  both  sides  of  the
               assignment  must be identical - this includes the formats
               of records.
               The assignment may be thought of as the assignment of the
               <B>address</B> of the variable to the pointer.
               Once equivalenced the pointer variable may be used as  an
               alternative to the variable.

                    <B>integer</B> <B>name</B> N
                    <B>integer</B> J
                    <B>integer</B> <B>array</B> A(1:6)
                    <B>integer</B> <B>name</B> <B>array</B> PT(2:12)
                    J = 1
                    N == A(J);            ! N IS NOW EQUIVALENT TO A(1)
                    J = 2;                ! N HAS NOT CHANGED
                    N = 0;                ! SAME AS A(1) = 0
                    PT(J) == A(4)

               N.B.  Extreme  care should be taken if variables declared
                    in different blocks are to be equivalenced as it  is
                    possible  to  leave a pointer referencing a variable
                    which no longer exists (see Block Structure).











                                 4-3
<HR>

          3.   {variable} "&lt;-" {expression}

                    This is similar to 1. above except that the value of
                    the expression will be truncated if  necessary  (see
                    Data Prescision Specification).

               E.g. <B>string</B>(4) S

                    S = "12345"; ! fails CAPACITY EXCEEDED at run-time.

                    S &lt;- "12345"; ! will assign "1234" to S.


                              RECORD ASSIGNMENT

                  Two extra assignments exist for records.

               1.   {record variable} "=" {record variable}

                    The  right-hand record is copied bit by bit into the
                    left-hand record.   The formats of the  two  records
                    must be the same.

               2.   {record variable} "=0"

                    Each bit of the record is set to zero.



                              STRING RESOLUTION

             The  contents  of  a  string variable may be searched for a
          sub-string and decomposed accordingly.
          The format of a resolution is:

          {string var}"-&gt;"{string var}".("{string exp}")."{string var}

          where either the second string variable, the  third,  or  both
          may be omitted (any dangling full stops also being omitted).

               S        -&gt; T.(",").U
               TITLE(J) -&gt; ("SIR").REST
               WHO      -&gt; WHO.(LETTERS."B.SC.")
               S        -&gt; ("HELLO".T)

             The  string  expression is evaluated and the first variable
          is searched  from  left  to  right  to  find  that  string  of
          characters.  The string to the left of the sub-string so found
          is assigned to the second variable and the string to the right
          is assigned to the third.
          The  resolution  is  deemed  to  have  failed  if the required
          sub-string is not found or  either  of  the  second  or  third
          string variables has been omitted and would have been assigned
          a non-null string.






                                 4-4
<HR>

          For  example, the following resolutions all fail if the string
          variable S contains the string "ABCDEFG"

                    S -&gt; T.("H").U
                    S -&gt; ("CD").U
                    S -&gt; T.("EF")
                    S -&gt; ("ABCDEF")

          and the following all succeed:

                    S -&gt; T.("CDE").U
                    S -&gt; ("ABC").U
                    S -&gt; T.("G")
                    S -&gt; ("ABCDEFG")

             A resolution may occur in two contexts:

               1.   as an instruction, in which case failure of the
                    resolution causes an  event  to  be  signalled  (see
                    Events)

                    S -&gt; A.(WANTED).B;  S = A.B

               2.   as  a  simple  condition  (see Conditions), in which
                    case failure of  the  resolution  deems  the  simple
                    condition  false  and  success deems it true; in the
                    latter case the  resolution  is  performed  and  the
                    necessary assignments are made.

                    <B>if</B> WHO -&gt; ("SIR ").WHO <B>then</B> KNIGHT = 1






























                                 4-5
<HR>

                                  CONDITIONS

          Conditional   statements   are   specified  using  the  phrase
          {condition}, which is defined as:

          {condition} ::= {simple cond} ("<B>and</B>" {simple cond})*,
                          {simple cond} ("<B>or</B>" {simple cond})*

          where {simple cond} has seven forms:-

          1.   {expression}{comp}{expression}

               {comp} ::= "="         - IS EQUAL TO
                          "#", "\="   - IS NOT EQUAL TO
                          "&lt;"         - IS LESS THAN
                          "&lt;="        - IS LESS THAN OR EQUAL TO
                          "&gt;"         - IS GREATER THAN
                          "&gt;="        - IS GREATER THAN OR EQUAL TO
               The given expressions are evaluated and  compared.    The
               simple  condition  is  true  or  false  depending  on the
               validity of the relation  specified  by  the  comparator.
               Both expressions must yield values of the same type.

          2.   {expression} {comp} {expression} {comp} {expression}

               This  form  of  simple  condition  may be thought of as a
               contraction of the form:
                    ({x1}{comp1}{x2} "<B>and</B>" {x2}{comp2}{x3})
               except that the middle expression (x2) is only  evaluated
               once.    Note  that the third expression is not evaluated
               unless  the  condition  specified  by   the   first   two
               expressions is true.
               Such a simple condition is frequently used to check for a
               range of values, E.g.

                              0 &lt;= VALUE &lt;= 100

          3.   {reference to variable} "==" {reference to variable}

               The  two  variables,  which must be of the same type, are
               compared for equivalence, that  is  their  <B>addresses</B>  are
               compared.
               Note  that  the  address  of  a  pointer  variable is the
               address of the variable to which it is equivalent.

          4.   {predicate call}         - see Procedures

               The given predicate is called and the simple condition is
               true or false depending on  whether  the  exit  from  the
               predicate was performed using <B>true</B> or <B>false</B> respectively.

          5.   {resolution}             - see String Resolution

               The  resolution  is  attempted.    If it fails the simple
               condition is deemed false, otherwise  the  resolution  is
               performed and the condition is deemed true.
               Note that this form of simple condition has a side-effect
               if the simple condition is true!


                                 5-1
<HR>

          6.   "(" {condition} ")"

               This  form  of simple condition is provided to enable the
               use of both <B>and</B> and <B>or</B> in a condition.   The  connectives
               <B>and</B>  and  <B>or</B>  may not appear in the same condition unless
               separated by levels of parentheses.  E.g.

                         A=0 <B>or</B> (B=1 <B>and</B> C=2) <B>or</B> D=3

          7.   "<B>not</B>" {simple condition}

               The given simple condition is evaluated and its truth  is
               negated.    E.g.  the  following  simple  conditions  are
               exactly equivalent:

                                    A # 0
                                  <B>not</B> A = 0



                           <B>Evaluation of conditions</B>


             The evaluation of a condition proceeds from left to  right,
          simple  condition  by simple condition, terminating as soon as
          the inevitable result of the condition is known.

          For example, considering the condition:

                              A # 0 <B>and</B> B//A # C

          If the variable A has the value zero  the  condition  will  be
          deemed false without attempting the evaluation of "B//A # C".



























                                 5-2
<HR>

                            CONDITIONAL STATEMENTS

             The general form of conditional statements is:

               <B>if</B> {condition} <B>start</B>
                  ! STATEMENTS TO BE EXECUTED IF
                  ! {condition} IS TRUE
               <B>finish</B> <B>else</B> <B>start</B>
                  ! STATEMENTS TO BE EXECUTED IF
                  ! {condition} IS FALSE
               <B>finish</B>

             If <B>start</B>-<B>finish</B> brackets enclose one instruction only, that
          part may be reduced to:

               <B>if</B> {condition} <B>then</B> {instruction} <B>else</B> <B>start</B>

          or   <B>finish</B> <B>else</B> {instruction}

          e.g. <B>if</B> {condition} <B>then</B> {instruction} <B>else</B> <B>start</B>
                  ! STATEMENTS TO BE EXECUTED IF
                  ! {condition} IS FALSE
               <B>finish</B>

          or   <B>if</B> {condition} <B>start</B>                (*)
                  ! STATEMENTS TO BE EXECUTED IF
                  ! {condition} IS TRUE
               <B>finish</B> <B>else</B> {instruction}

          or in the simplest case:

               <B>if</B> {condition} <B>then</B> {instruction} <B>else</B> {instruction}

             If nothing is to be done specifically when the condition is
          false the <B>else</B> part may be omitted.

               <B>if</B> {condition} <B>start</B>
                  ! STATEMENTS TO BE EXECUTED IF
                  ! {condition} IS TRUE
               <B>finish</B>

          or

               <B>if</B> {condition} <B>then</B> {instruction}



          <B>start</B>-<B>finish</B> groups may be nested to any depth.












                                 5-3
<HR>

                              ALTERNATIVE FORMS

          1.   A conditional statement of the form:

                    <B>if</B> {condition} <B>then</B> {instruction}

               has  the  same  effect  if  rewritten in the more natural
               form:

                    {instruction} <B>if</B> {condition}

                    X = ERROR <B>if</B> X > LIMIT

          2.   The keyword <B>if</B> may always be replaced by <B>unless</B> with the
               effect of negating the  whole  of  the  condition.    For
               example, the following two statements are equivalent:

                        <B>if</B> X = 0 <B>then</B> Y =  1 <B>else</B> Y = -1
                    <B>unless</B> X = 0 <B>then</B> Y = -1 <B>else</B> Y =  1


          3.   The  statement  "<B>finish</B> <B>else</B> <B>start</B>" may be abbreviated to
               "<B>else</B>".

                    <B>if</B> X = 0 <B>start</B>
                       FLAG = 1;  COUNT = 0
                    <B>else</B>
                       FLAG = 2;  COUNT = -1
                    <B>finish</B>


          4.   The <B>else</B> part of any conditional group may be replaced by
               another complete conditional group, treated as though  it
               were a single instruction (see * above).
               For example:-

                    <B>if</B> A = 0 <B>start</B>
                       P = 1;  Q = 2
                    <B>finish</B> <B>else</B> <B>start</B>
                       <B>if</B> A &lt; 0 <B>start</B>
                          P = -1;  Q = 2
                       <B>finish</B> <B>else</B> <B>start</B>
                          P = 1;  Q = -2
                       <B>finish</B>
                    <B>finish</B>

               may be rewritten:-

                    <B>if</B> A = 0 <B>start</B>
                       P = 1;  Q = 2
                    <B>finish</B> <B>else</B> <B>if</B> A &lt; 0 <B>start</B>
                       P = -1; Q = 2
                    <B>finish</B> <B>else</B> <B>start</B>
                       P = 1;  Q = -2
                    <B>finish</B>





                                 5-4
<HR>




                         REPETITION (LOOPS OR CYCLES)


          a.   Indefinite Repetition

                  A  group of statements may be repeated indefinitely by
               enclosing  them  between  the  statements   "<B>cycle</B>"   and
               "<B>repeat</B>".

                    <B>cycle</B>
                       GET DATA
                       PROCESS DATA
                    <B>repeat</B>

               Subsequently  the  group  of statements between <B>cycle</B> and
               <B>repeat</B> will be referred to as the <B>cycle</B> <B>body</B>.


          b.   Conditional Repetition

               1.   <B>while</B> {condition} <B>cycle</B>

                    Before  each  execution  of  the  cycle   body   the
                    specified condition is tested.   If the condition is
                    true the cycle body is executed;  otherwise  control
                    is  passed  to  the statement following the matching
                    <B>repeat</B>.

               2.   <B>for</B> {control} "=" {init} "," {inc} "," {final} <B>cycle</B>

                    where
                    {control}::= {integer variable}  - CONTROL VARIABLE
                    {init}   ::= {integer expression} - INITIAL VALUE
                    {inc}    ::= {integer expression} - INCREMENT
                    {final}  ::= {integer expression} - FINAL VALUE

                       On each entry to the cycle  the  address  of  the
                    control   variable  and  the  values  of  the  three
                    expressions are evaluated and saved; thus the  cycle
                    body  cannot  change them.   The control variable is
                    assigned the value "{init}-{inc}".
                    The value in the control variable is  compared  with
                    the value of {final}.   If they are equal control is
                    passed  to  the  statement  following  the  matching
                    <B>repeat</B>,  otherwise  the  value {inc} is added to the
                    control variable and the cycle body is executed.

                    On normal exit from the cycle the  control  variable
                    will contain the value {final}, however see <B>exit</B>.

                    Note:  The  effects of altering the control variable
                    within the cycle body are undefined.





                                 6-1
<HR>



               3.   The final form of conditional cycle is:

                    <B>cycle</B>
                       ! CYCLE BODY
                    <B>repeat</B> <B>until</B> {condition}

                    In  this  construction  the  cycle  body  is  always
               executed  at least once.   The loop may also be qualified
               by a <B>while</B> or <B>for</B> as defined above.

               E.g. <B>while</B> {condition} <B>cycle</B>
                       ! CYCLE BODY
                    <B>repeat</B> <B>until</B> {condition}


          <B>cycle</B>-<B>repeat</B> groups may be nested to any depth.



                             SIMPLE FORMS OF LOOP

             If the cycle body comprises only one instruction  the  loop
          may be rewritten in the form:-

               {instruction} {loop clause}

          i.e. {instruction} "<B>while</B>" {condition}
               {instruction}  "<B>for</B>" {control}"="{init}","{inc}","{final}
               {instruction} "<B>until</B>" {condition}


          For example

               A(J) = 0 <B>for</B> J = 1, 1, 20
               READSYMBOL(S) <B>until</B> S = NL
               SKIPSYMBOL <B>while</B> NEXTSYMBOL = ' '






















                                 6-2
<HR>

                          CYCLE CONTROL INSTRUCTIONS

             Two instructions are provided to control the execution of a
          cycle from within the cycle body.

               1.   <B>exit</B>      - causes the cycle to be terminated and
                              control to  be  passed  to  the  statement
                              following  the  matching  repeat.   In the
                              case of a <B>for</B> loop  the  control  variable
                              will   retain   the   value  it  contained
                              immediately prior to the <B>exit</B>.

               2.   <B>continue</B>  - causes  control  to  be  passed  to  the
                              <B>repeat</B>    (and    any   associated   <B>until</B>
                              condition) of the current loop.




                       JOINING INSTRUCTIONS USING 'AND'

             Several simple instructions may be  joined  together  using
          <B>and</B> to form a more complex instruction.  The execution of such
          an  instruction is achieved by executing each of the component
          simple instructions in the order given.   This construction is
          used to simplify small <B>start</B>-<B>finish</B> or <B>cycle</B>-<B>repeat</B> groups.

                    E.g. <B>if</B> X = 0 <B>start</B>
                            P = 1; Q = 1
                         <B>finish</B>

          may be rewritten:

                       P = 1 <B>and</B> Q = 1 <B>if</B> X = 0

                    or <B>if</B> X = 0 <B>then</B> P = 1 <B>and</B> Q = 1
























                                 6-3
<HR>


                               BLOCK STRUCTURE

             An  IMP  program  is  constructed using one or more <B>blocks</B>.
          Blocks may be nested one within another.   The depth to  which
          this nesting may be performed is implementation dependent.

                                 BEGIN BLOCKS
             The   simplest  type  of  block  is  enclosed  between  the
          statements "<B>begin</B>" and "<B>end</B>" and is referred  to  as  a  <B>begin</B>
          <B>block</B>.    If  the  block  is the outermost block of a complete
          program it must be terminated by the statement
          "<B>end</B> <B>of</B> <B>program</B>".

          For example, a complete program might take the form:

          <B>begin</B>
             <B>integer</B> COUNT, LIMIT
             .
             <B>begin</B>
                <B>real</B> SUM
                .
             <B>end</B>
             .
          <B>end</B> <B>of</B> <B>program</B>

          A <B>begin</B> block is entered by executing the <B>begin</B> and is left by
          passing through the <B>end</B> to the following statement.   The main
          uses  of  begin  blocks  are  to  declare  arrays  with bounds
          calculated at run-time, and to  enable  the  re-use  of  space
          taken up by large arrays which are only needed for part of the
          program.

               <B>begin</B>
                  <B>integer</B> UPPER
                  UPPER = ...;   !  CALCULATE VALUE FOR UPPER BOUND
                  <B>begin</B>
                     <B>integer</B> <B>array</B> CASES(1:UPPER)
                     .
                  <B>end</B>
               <B>end</B> <B>of</B> <B>program</B>

               <B>begin</B>
                  .
                  <B>begin</B>
                     <B>integer</B> <B>array</B> TEMP(1:10000)
                     .
                  <B>end</B>
                  <B>begin</B>
                     <B>real</B> <B>array</B> WORK AREA(1:11000)
                     .
                  <B>end</B>
               <B>end</B> <B>of</B> <B>program</B>







                                 7-1
<HR>

                          LOCAL AND GLOBAL VARIABLES

             An  identifier is described as being <B>local</B> to a block if it
          was declared at the head of that block.  Any identifiers which
          are in scope but which were  not  declared  in  the  block  in
          question are referred to as being <B>global</B> to the block.
          Clearly  identifiers may be local to only one block but may be
          global to many.

               <B>begin</B>;             ! START OF OUTER BLOCK
                  <B>integer</B> X;      ! X IS <B>LOCAL</B> TO THIS BLOCK
                  <B>begin</B>;          ! START OF INNER BLOCK
                     <B>integer</B> Y;   ! Y IS LOCAL TO THIS BLOCK
                     X = 0;       ! X IS <B>GLOBAL</B> TO THIS BLOCK
                  <B>end</B>;            ! END OF INNER BLOCK
               <B>end</B>;               ! END OF OUTER BLOCK

          Identifiers may always be redeclared in  any  block  to  which
          they are <B>global</B> - the local incarnation taking precedence over
          the global one.

               <B>begin</B>
                  <B>integer</B> X
                  <B>begin</B>
                     <B>integer</B> X
                     X = 0;       ! USES THE X OF THE PREVIOUS LINE
                  <B>end</B>
               <B>end</B>

          An  attempt  to  redeclare a local variable will be faulted by
          the compiler.

             On entry to a block, space from the stack is  allocated  to
          any  local  variables, and when the block is left the space is
          returned to the stack (but see Own Variables).

























                                 7-2
<HR>




                                  PROCEDURES

             A procedure is a block which has an associated  identifier;
          a   complete   procedure   block  may  be  considered  as  the
          declaration of the procedure identifier.
          Unlike begin blocks, procedures  are  not  entered  simply  by
          reaching  their first statement (this results in control being
          transferred to the  statement  following  the  matching  <B>end</B>).
          Instead  procedures  are  activated  when  they  are <B>called</B> by
          giving the procedure identifier in a context determined by the
          type of procedure.
          The effect of a call is to suspend the current flow of control
          and to pass control to the  procedure.    When  the  procedure
          terminates, the previous flow of control is resumed.

          There  are  four  forms  of procedure, the exact form required
          being specified by the first statement of the block.

          The phrase {param def}?  stands  for  the  optional  parameter
          definition and will be described later (see Parameters).

          1.   <B>routine</B> {id}{param def}?

               When  a  routine  is  called  its statements are executed
               until either the <B>end</B> is reached or the instruction <B>return</B>
               is executed.   This causes the routine to  terminate  and
               the previous flow of control to be resumed.

                     <B>integer</B> X, Y
                     <B>routine</B> CONVERT
                        <B>if</B> X &lt; Y <B>start</B>
                           X = X+Y
                        <B>finish</B> <B>else</B> <B>start</B>
                           X = X-Y
                        <B>finish</B>
                     <B>end</B>
                     ..
                     ..
                     CONVERT
                     ..
                     CONVERT <B>unless</B> X = 0
















                                 7-3
<HR>

          2.   {type} <B>function</B> {id}{param def}?

               A <B>function</B> is a procedure which calculates a <B>value</B> of the
               specified type (<B>integer</B>, <B>real</B>, <B>string</B>, or <B>record</B>) and may
               be  used  wherever  an  <B>operand</B>  of the specified type is
               required.
               When a function is called  its  statements  are  executed
               until an instruction of the form:

                    <B>result</B> "=" {expression}

               is  executed.    This  causes  the function to terminate,
               returning the value of the expression.

                    <B>integer</B> X,Y,Z
                    <B>integer</B> <B>function</B> SUM
                       <B>result</B> = X+Y
                    <B>end</B>
                    Z = SUM;         !  SAME EFFECT AS "Z=X+Y"


                    The keyword <B>function</B> may be abbreviated to <B>fn</B>.


          3.   {type} <B>map</B> {id}{param def}?

               A <B>map</B> is a procedure which calculates a  <B>reference</B>  to  a
               variable of the specified type (<B>integer</B>, <B>real</B>, <B>string</B>, or
               <B>record</B>),  and  may  be  used  wherever  a <B>variable</B> of the
               specified type is required.
               When a map is called its statements are executed until an
               instruction of the form:

                    <B>result</B> "==" {variable reference}

               is executed.  This causes the map to terminate, returning
               a reference to (i.e. the address of) the given variable.

               E.g. <B>integer</B> X,Y
                    <B>integer</B> <B>map</B> MIN
                       <B>if</B> X &lt; Y <B>then</B> <B>result</B> == X <B>else</B> <B>result</B> == Y
                    <B>end</B>

                    MIN = 0
                    ! THE ABOVE STATEMENT IS EXACTLY EQUIVALENT TO:
                    ! <B>if</B> X &lt; Y <B>then</B> X = 0 <B>else</B> Y = 0














                                 7-4
<HR>

          4.   <B>predicate</B> {id}{param def}?

               A <B>predicate</B> is a procedure which tests the validity of an
               hypothesis and then returns, being either <B>true</B> or  <B>false</B>.
               Predicates  may  be  used  wherever a simple condition is
               required.
               When a predicate is called its  statements  are  executed
               until  either  of  the  instructions "<B>true</B>" or "<B>false</B>" is
               executed.    This  causes  the  predicate  to   terminate
               accordingly.

               Note that a predicate does not return any value.

               E.g. <B>integer</B> N
                    <B>predicate</B> SINGLE DIGIT
                       <B>true</B> <B>if</B> 0 <= N <= 9
                       <B>false</B>
                    <B>end</B>

                    N = N//10 <B>unless</B> SINGLE DIGIT

          <B>Notes</B>

          a.   A <B>routine</B> may terminate by reaching <B>end</B>; all
               other  types of procedure must not be able to reach their
               <B>end</B>, otherwise the compiler will report a fault.

          b.   Procedures may be nested within any form of block.

          c.   Procedures may be <B>recursive</B>, that is, they may call
               themselves.





























                                 7-5
<HR>




                                  PARAMETERS

             In the previous  discussion  about  procedures  the  phrase
          {param def}? was used.   This stands for an optional parameter
          list definition.

          {param def} ::= "(" {dec list} ")"

          where {dec list} is a list of declarations defining the FORMAL
          PARAMETERS.   The declarations may be of any data type  except
          <B>array</B> - arrays may only be passed to a procedure as <B>array</B> <B>name</B>
          parameters.

          E.g. <B>routine</B> SWOP(<B>integer</B> <B>name</B> P, Q)
               <B>integer</B> <B>function</B> MAX(<B>integer</B> <B>array</B> <B>name</B> A, <B>integer</B> F, T)
               <B>predicate</B> EQUIV(<B>record</B>(FM)<B>name</B> LEFT, RIGHT)

             Parameters  are  identical  to any local variables declared
          inside  the  procedure,  except  that   the   parameters   are
          initialised each time the procedure is called.
          When a procedure is called a list of ACTUAL PARAMETERS must be
          supplied  which  must  match  the formal parameters exactly in
          number, order, and type.   Parameters are effectively assigned
          using  "=="  for those passed by <B>name</B> (E.g. <B>integer</B> <B>name</B>, <B>real</B>
          <B>array</B> <B>name</B>) and using "=" for  those  passed  by  value  (E.g.
          <B>string</B>(10), <B>integer</B>).

          For example assuming the declarations:

             <B>integer</B> L, M, N
             <B>real</B> R
             <B>integer</B> <B>array</B> V(-7:7)
             <B>record</B> (FM) ONE, TWO

          valid  calls  on  the  procedures  mentioned  in  the previous
          example are:

             SWOP(L, M)
             SWOP(V(L), V(M))
             N = MAX(V, -1, 0)
             M = MAX(V, L, 7)
             N = M <B>if</B> EQUIV(ONE, TWO)

          N.B.  IMP <B>name</B> type parameters are called by <B>reference</B> and not
          by <B>substitution</B> (c.f.  ALGOL 60).












                                 7-6
<HR>

                             PROCEDURE PARAMETERS

             In addition to being able to pass variables  to  procedures
          it  is  possible  to  pass procedures as parameters.   This is
          achieved by using the procedure heading as  the  'declaration'
          of the formal parameter.

          E.g. <B>routine</B> TRY(<B>routine</B> R(<B>integer</B> X))
                  <B>integer</B> J
                  R(J) <B>for</B> J = 1, 1, 10
               <B>end</B>

          The  routine  TRY  may  now  be called with a single parameter
          which must be the name of a  routine  which  has  one  integer
          parameter.  In this context the formal parameter names used to
          specify  the parameters of a procedure parameter are otherwise
          ignored.

          Note: If the routine TRY is itself to be passed as a parameter
          the heading of the receiving routine would be something like:

               <B>routine</B> CHECK(<B>routine</B> P(<B>routine</B> Q(<B>integer</B> R)))

          and the call would be:

               CHECK(TRY)



                            GENERAL TYPE PARAMETER

             In several situations it is useful to be able to pass to  a
          procedure  a reference to <B>any</B> type of variable.   This is done
          by specifying an untyped <B>name</B> parameter.

          E.g. <B>routine</B> WORK(<B>name</B> REF)

          Such a parameter is intended  for  system-dependent  interface
          procedures  and  has severely limited uses.   In particular it
          may only be  passed  on  to  another  procedure  requiring  an
          untyped <B>name</B> parameter.

             An  example  of  the  use  of  such  a  parameter is in the
          pre-declared READ routine which will accept an <B>integer</B>,  <B>real</B>,
          or <B>string</B> parameter.

          E.g. <B>integer</B> X
               <B>real</B> Y
               <B>string</B> (15) Z
               READ(X);  READ(Y);  READ(Z)










                                 7-7
<HR>




          The   following   is  a  complete  list  of  formal  parameter
          declarators:



          <B>integer</B>             <B>real</B>             <B>string</B>({max})

          <B>integer</B> <B>name</B>        <B>real</B> <B>name</B>        <B>string</B>({max})<B>name</B>

          <B>integer</B> <B>array</B> <B>name</B>  <B>real</B> <B>array</B> <B>name</B>  <B>string</B>({max})<B>array</B> <B>name</B>

          <B>integer</B> <B>fn</B>          <B>real</B> <B>fn</B>          <B>string</B>({max})<B>fn</B>

          <B>integer</B> <B>function</B>    <B>real</B> <B>function</B>    <B>string</B>({max})<B>function</B>

          <B>integer</B> <B>map</B>         <B>real</B> <B>map</B>         <B>string</B>({max})<B>map</B>

          <B>integer</B> <B>name</B> <B>array</B> <B>name</B>

          <B>real</B> <B>name</B> <B>array</B> <B>name</B>

          <B>string</B>({max}) <B>name</B> <B>array</B> <B>name</B>



          <B>record</B>({fm})

          <B>record</B>({fm})<B>name</B>

          <B>record</B>({fm})<B>array</B> <B>name</B>

          <B>record</B>({fm}) <B>name</B> <B>array</B> <B>name</B>

          <B>record</B>({fm})<B>fn</B>

          <B>record</B>({fm})<B>function</B>

          <B>record</B>({fm})<B>map</B>



          <B>routine</B>

          <B>predicate</B>

          <B>name</B>











                                 8-1
<HR>




                           PROCEDURE SPECIFICATION

             In several situations it is necessary to  use  a  procedure
          before  it  is  possible  (or  desirable)  to define it.   For
          example, where two or more procedures call each other  (mutual
          recursion)  or  where  a procedure is to be defined externally
          (see External Linkage).
          As all procedure identifiers must  be  declared  before  being
          used a procedure specification statement is introduced.
          This  takes  the form of the normal procedure heading with the
          keyword <B>spec</B> inserted before the procedure identifier.

          E.g. <B>routine</B> <B>spec</B> MAX(<B>real</B> SIZE)

             This has no effect other than declaring the  identifier  to
          be  a  procedure  of  the specified type which takes the given
          parameters.    Except  in  the  case  of  <B>external</B>   procedure
          specifications  the  procedure must be defined later on in the
          same block (but not any blocks defined therein).

          For example:

                    <B>routine</B> <B>spec</B> B(<B>integer</B> X)

                    <B>routine</B> A(<B>integer</B> Y)
                       .
                       B(Y-1)
                       .
                    <B>end</B>

                    <B>routine</B> B(<B>integer</B> X)
                       .
                       A(X+3)
                       .
                    <B>end</B>

          Note that the <B>spec</B> statement and the procedure heading
          must correspond, that is, the type and form of the  statements
          must  match,  as  must the type, form, order and number of any
          parameters.

















                                 8-2
<HR>




                        CONTROL TRANSFER INSTRUCTIONS


                               <B>LABELS</B>_<B>and</B>_<B>JUMPS</B>

          1.   <B>Simple</B> <B>Labels</B>

                  Any statement, excluding declarations,  may  be  given
               one or more simple labels, where a simple label is of the
               form: {id} ":"

               Each label is written to the left of the statement.

               NEXT:         P = P+1 <B>if</B> P < 0
               ERROR1:ERROR2:FAULTS = FAULTS+1

               Control   may  be  passed  to  a  labelled  statement  by
               executing a jump instruction: "-&gt;" {id}


                    -&gt; NEXT

                    -&gt; ERROR1 <B>if</B> DIVISOR = 0

          2.   <B>Switch</B> <B>Vectors</B>

                  A vector of labels may be declared in a similar manner
               to an array, using the declarator <B>switch</B>.

               <B>switch</B> SW(4:9)
               <B>switch</B> S1, S2(1:10), S3(11:20)

          Note a.   The vector must be one dimensional.

               b.   The bounds must be constants.

               Once declared, switch labels may be used in the same  way
               as simple labels.

               SW(4):       CHECK VALUE(1)
               SW(6):SW(6): ERROR FLAG = 1
               LAST: SW(9): ! ALL FINISHED

               A  star  (*)  may  be  used in the definition of a switch
               label to locate any elements of the  vector  which  would
               otherwise be undefined.











                                 9-1
<HR>


               <B>switch</B> LET('A':'Z')
               .
               .
               LET('A'):LET('E'):LET('I'):LET('O'):LET('U'):

               ! DEAL WITH VOWELS
               .
               .

               LET(*):! ALL THE REST I.E. CONSONANTS

               The  specific  label  to  which  a  jump  will be made is
               dependent on the value of an integer expression.

                    -&gt;SW(N) <B>if</B> N > 0
                    -&gt;SW(100+N)
                    -&gt;SW(6)

          Note 1.   Not all  of  the  declared  switch  labels  need  be
                    defined  (in the previous examples SW(5): and SW(8):
                    are undefined) but an error will occur at  run  time
                    if  an  attempt  is  made  to jump to a non-existent
                    switch label.

               2.   Simple labels are the only identifiers which may  be
                    used before they are declared/defined.

                         -&gt; MISSING <B>if</B> HERE = 0
                         .
                         .
                    MISSING:

               3.   The scope of both types of label is limited to the
                    block  in  which they are defined, not including any
                    blocks defined therein.   That is labels  cannot  be
                    global  to  a block and therefore it is not possible
                    to jump into or out of a block.

               4.   The identifiers used for labels  must  not  conflict
                    with other local identifiers.

               5.   The  results  of entering a <B>for</B> loop with a jump and
                    not through the <B>for</B> statement are undefined.
















                                 9-2
<HR>

                     OTHER CONTROL TRANSFER INSTRUCTIONS


          <B>stop</B>

                  Execution of the instruction <B>stop</B> causes control to be
               returned to the program which initiated the execution  of
               the current program.  This is also the effect of reaching
               the statement <B>end</B> <B>of</B> <B>program</B>.
               Control  is  transferred  by  signalling  event zero (see
               Events).


          <B>monitor</B>

                  This  instruction  causes  the   run-time   diagnostic
               package to be invoked to produce diagnostic information.
               If  no  diagnostic  package is available this instruction
               will be ignored  (in  some  limited  implementations  the
               production of diagnostics causes execution of the program
               to be terminated).

          For  convenience  all  other control transfer instructions are
          gathered here.

          <B>return</B>              return from a routine.

          <B>result</B>={exp}        return the result of a function

          <B>result</B>=={reference} return the result of a map.

          <B>true</B>                return from a predicate.

          <B>false</B>               return from a predicate.

          <B>exit</B>                jump out of the current <B>cycle</B> to the
                              statement following the matching <B>repeat</B>.

          <B>continue</B>            jump to the top of the current <B>cycle</B>.

          <B>signal</B> <B>event</B>        see Events.



















                                 9-3
<HR>


                               EXTERNAL LINKAGE

             A complete program may be divided into  several  separately
          compiled modules which are linked together before (or possibly
          while)  the program is executed.   This linkage is achieved by
          giving the <B>external</B> attribute to relevant indentifiers.

          1.   <B>external</B> DATA OBJECTS

                  An external variable is declared in the same way as an
               <B>own</B> variable with the keyword <B>own</B> replaced by <B>external</B>.

                    <B>external</B> <B>integer</B> CHOICE=4, WAIT = -5

                    <B>external</B> <B>real</B> <B>array</B> MEAN(-6:6)

               The identifiers are then available for use by any program
               that references them.   A separately compiled module that
               requires to use any of these variables must first declare
               them using an external specification.

                    <B>external</B> <B>integer</B> <B>spec</B> WAIT, CHOICE

                    <B>external</B> <B>real</B> <B>array</B> <B>spec</B> MEAN(-6:6)

               note 1.   No initialization may be specified in an
                         external specification.

                    2.   External arrays must be one-dimensional and
                         have constant bounds.

                    3.   Even though all of the characters in the
                         identifier    of   an   external   entity   are
                         significant to the compiler, the system  loader
                         software might impose constraints on the number
                         of   significant  characters.    Refer  to  the
                         relevant   appendix   for   system    dependent
                         restrictions.

          2.   <B>external</B> <B>PROCEDURES</B>

                  A  procedure may be made available to other modules by
               prefixing  the  procedure  heading   with   the   keyword
               <B>external</B>.

                  <B>external</B> <B>routine</B> TRIAL(<B>string</B>(63) S)

               Such  procedures  must  be  compiled in a file comprising
               only external procedures (and possibly some  non-external
               procedures and <B>own</B> or <B>external</B> declarations).   The whole
               module is terminated by the statement <B>end</B> <B>of</B> <B>file</B>.








                                 10-1
<HR>


               For example the following is a complete file of  external
               procedures:

                    <B>integer</B> <B>function</B> SHIFT(<B>integer</B> SYM)
                       <B>result</B> = S-32;          !  LOWER - UPPER CASE
                    <B>end</B>

                    <B>external</B> <B>predicate</B> LETTER(<B>integer</B> SYM)
                       <B>true</B> <B>if</B> 'A' <= SYM <= 'Z'
                       <B>true</B> <B>if</B> 'A' <= SHIFT(SYM) <= 'Z'
                       <B>false</B>
                    <B>end</B>

                    <B>external</B> <B>predicate</B> DIGIT(<B>integer</B> SYM)
                       <B>true</B> <B>if</B> '0' <= SYM <= '9'
                       <B>false</B>
                    <B>end</B>

                    <B>external</B> <B>predicate</B> ALPHANUM(<B>INTEGER</B> SYM)
                       <B>true</B> <B>if</B> LETTER(SYM) <B>or</B> DIGIT(SYM)
                       <B>false</B>
                    <B>end</B>

                    <B>end</B> <B>of</B> <B>file</B>

               Note a.   The function SHIFT is local to the file - it
                         cannot be called from a different module.

                    b.   The normal scope rules apply within the file,
                         so that ALPHANUM may call both LETTER and
                         DIGIT.

                    c.   External procedures may <B>not</B> be nested within
                         any blocks.


                  If  a  module  requires  to  use an externally defined
               procedure it must  first  supply  an  <B>external</B>  <B>PROCEDURE</B>
               <B>specification</B>.  For example:

                    <B>external</B> <B>predicate</B> <B>spec</B> LETTER(<B>integer</B> S)

               This  is  similar  to  a procedure specification but only
               requires the specified procedure to have been defined  by
               the time the module is executed.

               The prefix <B>external</B> may be replaced by <B>system</B> or <B>dynamic</B>,
               the  exact significance of which may vary from machine to
               machine.










                                 10-2
<HR>




                            PREDEFINED PROCEDURES

             Every separately compiled module, whether  a  <B>begin</B>-<B>end</B>  <B>of</B>
          <B>program</B>  block  or  a  file of external procedures is compiled
          within a conceptual "outermost block" in which are declared  a
          number  of  standard procedures such as READ and WRITE.   This
          means that these procedures are  global  to  all  parts  of  a
          program  and  so  may  be  used without having to be declared.
          Note that as these procedures are global they may be redefined
          within the program.
          Further, <B>own</B>, <B>constant</B> or <B>external</B> identifiers may be declared
          in this outermost block and will be global to the whole of the
          file.

               <B>own</B> <B>integer</B> CALLS = 0

               <B>external</B> <B>routine</B> DO SOMETHING
                  CALLS = CALLS+1;        ! RECORD TIMES ENTERED
                  .
                  .
               <B>end</B>

               <B>external</B> <B>integer</B> <B>function</B> ENTRIES
                  <B>result</B> = CALLS
               <B>end</B>

               <B>end</B> <B>of</B> <B>file</B>


          Note that the function ENTRIES is used to make  the  value  in
          CALLS  available  to other modules without their being able to
          change that value, even by mistake.

























                                 10-3
<HR>

             While the actual procedures which are predeclared may  vary
          from machine to machine, the following are standard and may be
          assumed present:

          <B>INPUT/OUTPUT</B>


               <B>routine</B> READSYMBOL(<B>integer</B> <B>name</B> S)
               <B>routine</B> SKIPSYMBOL
               <B>integer</B> <B>function</B> NEXTSYMBOL
               <B>routine</B> READ(<B>name</B> N)

               <B>routine</B> PRINTSYMBOL(<B>integer</B> N)
               <B>routine</B> PRINTSTRING(<B>string</B>(255) S)
               <B>routine</B> WRITE(<B>integer</B> N, PLACES)
               <B>routine</B> NEWLINE
               <B>routine</B> NEWLINES(<B>integer</B> N)
               <B>routine</B> SPACE
               <B>routine</B> SPACES(<B>integer</B> N)

               <B>routine</B> SELECTINPUT(<B>integer</B> STREAM)
               <B>routine</B> SELECTOUTPUT(<B>integer</B> STREAM)


          <B>STRING</B> <B>HANDLING</B>


               <B>string</B>(1) <B>function</B> TOSTRING(<B>integer</B> SYMBOL)
               <B>string</B>(255)  <B>fn</B> SUBSTRING(<B>string</B>(255)<B>name</B> S, <B>integer</B> F,T)
               <B>integer</B> <B>function</B> CHARNO(<B>string</B>(255) S, <B>integer</B> N)
               <B>integer</B> <B>function</B> LENGTH(<B>string</B>(255) S)


          <B>EVENT</B> <B>HANDLING</B> (see Events)


               <B>integer</B> <B>function</B> EVENT
               <B>integer</B> <B>function</B> SUB EVENT
               <B>integer</B> <B>function</B> EVENT INFO


          <B>STORE</B> <B>MAPPING</B>


               <B>integer</B> <B>function</B> ADDR(<B>name</B> V)
               <B>integer</B> <B>map</B> INTEGER(<B>integer</B> ADDRESS)
               <B>real</B> <B>map</B> REAL(<B>integer</B> ADDRESS)
               <B>string</B>(255)<B>map</B> STRING(<B>integer</B> ADDRESS)

             Refer to the relevant system library  manual  for  detailed
          specifications of these and other standard procedures.









                                 10-4
<HR>

                                    EVENTS

             During  the  execution  of  a program several (synchronous)
          events may occur, such as resolution fails, array bound  fault
          etc.  (see  Faults).    Normally  such  events  will cause the
          program to be terminated with an  error  report  and  possibly
          diagnostic  information.    However  events may be trapped and
          used to control the further execution of the program.

             The first non-declarative statements of any block may be of
          the form:

                    <B>on</B> <B>event</B> {event list} <B>start</B>
                         ! ON-BODY STATEMENTS
                    <B>finish</B>

          where {event list} is a list of integer constants representing
          the events to be trapped.

          On entry to the block the on body  is  skipped  and  execution
          continues  from  the  statements following the <B>finish</B>.   If an
          event specified in the {event list} is  signalled  during  the
          execution of the statements between the <B>finish</B> of the <B>on</B> <B>event</B>
          group  and the <B>end</B> of the block, control will be passed to the
          on-body (  and  may  well  pass  through  the  <B>finish</B>  to  the
          following  statements).    If  the event is not trapped in the
          current block a 'return' is forced and the event is  signalled
          in  the  new  block  at the point from which the old block was
          entered.   The process is repeated until either the  event  is
          trapped  or  the outermost block of the program is reached, in
          which case the event is reported as a fault  and  the  program
          terminates.

          Three functions are available which give information about the
          last event to have been signalled.

          1.   <B>integer</B> <B>function</B> EVENT
                         returns the class of the last event.

          2.   <B>integer</B> <B>function</B> SUB EVENT
                         returns the sub-class of the last event.

          3.   <B>integer</B> <B>function</B> EVENT INFO
                         returns  any  extra information passed with the
                         event.

          If no event has occurred each of these functions  will  return
          the value zero.












                                 11-1
<HR>


          The classes of event and their sub-classes of them are:

          <B>EVENT</B>   <B>SUB-CLASS</B>   <B>MEANING</B> <B>(+EXTRA</B> <B>INFORMATION</B>)

             0                  <B>TERMINATION</B>
                      -1        ABANDON PROGRAM WITHOUT DIAGNOSTICS
                       0        NORMAL TERMINATION (<B>stop</B>)
                      &gt;0        USER GENERATED ERROR

             1                  <B>ARITHMETIC</B> <B>OVERFLOW</B>
                       1        INTEGER OVERFLOW
                       2        REAL OVERFLOW

             2                  <B>EXCESS</B> <B>RESOURCE</B>
                       1        NOT ENOUGH STORE

             3                  <B>DATA</B> <B>ERROR</B>
                       1        SYMBOL IN DATA (+SYMBOL)

             4                  <B>CORRUPT</B> <B>DATA</B>
                       1        DATA TRANSMISSION ERROR

             5                  <B>INVALID</B> <B>ARGUMENTS</B>
                       1        ILLEGAL CYCLE
                       2        ILLEGAL EXPONENT (+EXPONENT)
                       3        ARRAY INSIDE-OUT

             6                  <B>OUT</B> <B>OF</B> <B>RANGE</B>
                       1        CAPACITY EXCEEDED
                       2        ARRAY BOUND FAULT (+INDEX)
                       3        NO SWITCH LABEL (+INDEX)

             7                  <B>RESOLUTION</B> <B>FAILS</B>
             8                  <B>UNASSIGNED</B> <B>VARIABLE</B>
             9                  <B>INPUT</B> <B>ENDED</B>
            10                  <B>LIBRARY</B> <B>PROCEDURE</B> <B>ERROR</B>
            11 - 15             <B>GENERAL</B> <B>PURPOSE</B>






















                                 11-2
<HR>

             At  any time during the execution of a program an event may
          be signalled by executing an instruction of the form:

          <B>signal</B> <B>event</B> {n}{qual}?

          where:

             {n}     ::= an integer constant in the range 0 &lt;= N &lt;= 15
             {qual}  ::= "," {sub event}{extra}?
             {extra} ::= "," {extra info}

          and {sub event} and {extra info} are integer expressions.

          The  instruction  causes  event  {n}  to  be  signalled   with
          sub-event (default zero) and extra information (default zero).

               <B>signal</B> <B>event</B> 15;            !  event 15,0,0
               <B>signal</B> <B>event</B> 14,7 <B>if</B> X < 0; !  event 14,7,0
               <B>signal</B> <B>event</B> 13,1,Y <B>if</B> Y#0; !  event 13,1,Y

          Note 1.   In both the <B>on</B> and <B>signal</B> statements the keyword
                    <B>event</B> is optional and may be omitted.

               2.   An  event  signalled  inside  an  incarnation  of an
                    on-body will never be trapped into that incarnation.
                    Instead the search for a trap will  start  from  the
                    previous block.

































                                 11-3
<HR>

                                  APPENDIX 1

                           COMPILER ERROR MESSAGES

             Any  errors detected by the compiler will generate messages
          of the form:

                    * {message}

          In most cases a marker (|) will  be  output  to  indicate  the
          position in the statement at which the error was detected.

          ACCESS         -    the statement cannot be reached.  This is
                              not  treated  as an error but may indicate
                              another fault.
          ATOM           -    unknown atomic element.
          BOUNDS         -    invalid bounds for an array or
                              <B>switch</B> declaration,  or  wrong  number  of
                              constants for an array initialization.
          CONTEXT        -    formally  correct  statement  given in the
                              wrong context.
          COPY           -    attempt to redefine a local identifier.
          FORM           -    incorrectly formed statement.
          INDEX          -    switch label index out of bounds.
          MATCH          -    procedure definition does not match a
                              previous <B>spec</B>.
          NAME           -    undeclared identifier
          ORDER          -    formally correct statement in wrong
                              sequence.
          SIZE           -    constant out of range.
          TOO COMPLEX    -    statement too long or complex to analyse.
          TYPE           -    variable of wrong type.
          TYPE FOR {op}  -    operator {op} out of context.
          %BEGIN MISSING -    too many <B>end</B> statements
          %CYCLE MISSING -    a <B>repeat</B> has been given with no matching
                              <B>cycle</B>.
          %END MISSING   -    unterminated blocks remain at
                              <B>end</B> <B>of</B> <B>program</B> or <B>end</B> <B>of</B> <B>file</B>.
          %FINISH MISSING-    outstanding <B>start</B> at <B>end</B> or <B>repeat</B>.
          %REPEAT MISSING-    outstanding <B>cycle</B> at <B>end</B> or <B>finish</B>.
          RESULT MISSING -    a function, map, or predicate can reach
                              its <B>end</B>.
          %START MISSING -    a <B>finish</B> has been given with no matching
                              <B>start</B>.

          "{id}" MISSING -    undefined procedure or label.













<HR>

                                  APPENDIX 2


                        <B>SAMPLE</B> <B>PROGRAM</B> <B>LISTING</B>

             1 %begin
             2    %begin
             3    %realname Q
             4    %integer VALUE, X, X
          *                          ! COPY
             5    %string(256) S
          *                    ! SIZE
             6    %switch SA(1:4), SB(5:4)
          *BOUNDS
             7    %routinespec CHECK
             8    %integerfunctionspec KEY(%integer X)
             9    %if X = 4 %STARY
          *                      ! ATOM
            10       VALUE = KEY
          *                  ! FORM
            11       VALUR = 0
          *          ! NAME
            12 SA(5):
          *         ! INDEX
            13       %exit
          *%CYCLE MISSING
            14       %stop
            15       X = 0
          *ACCESS
            16    %finish
          *%START MISSING
            17    %on %event 4 %start
          *ORDER
            18       %integerfunction KEY(%real X)
          *MATCH
            19       %end
          *RESULT MISSING
            20    Q == VALUE
          *            ! TYPE
            21    X = Q&amp;7
          *TYPE for "&amp;"
            22 %endofprogram
          *%END MISSING
          *%FINISH MISSING
          *"CHECK" MISSING














<HR>

                                  APPENDIX 3

                         DATA PRECISION SPECIFICATION

             On some machines  it  is  possible  to  offer  a  range  of
          precisions  for  variables  of  type  <B>integer</B>  or  <B>real</B>.   The
          precision is specified by the use  of  one  of  the  following
          prefixes:

                    <B>short</B>- smaller range than by default

                    <B>long</B> - larger range than by default

                    <B>byte</B> - large enough to hold a character (unsigned)

          E.g.           <B>byte</B> <B>integer</B>

                         <B>short</B> <B>integer</B>

                         <B>long</B> <B>integer</B>

                         <B>long</B> <B>real</B>


          If  the  machine  on  which  the  program  is to be run cannot
          support the required precision the prefix will be ignored.


               E.g.  On the IBM 360 (or ICL 4/75)




                              <B>byte</B> <B>integer</B>     8-bits unsigned
                              <B>short</B> <B>integer</B>    16-bits signed
                              <B>integer</B>          32-bits signed

                              <B>real</B>             32-bits
                              <B>long</B> <B>real</B>        64-bits

             Note that checks may be applied to ensure that any quantity
          assigned to a variable is within the correct range of values.

          E.g.      <B>byteinteger</B> B
                    <B>integer</B> X
                    X=16_FFFF
                    B = X

          will fail at run-time, as  "16<B> </B>FFFF"  is  a  POSITIVE  <B>integer</B>
          value but a NEGATIVE <B>short</B> <B>integer</B> value.

          The  assignment  operator "&lt;-" may be used to force truncation
          if required (see Assignment).






<HR>




                                  APPENDIX 4

                                 IMP KEYWORDS

      <B>and</B>       <B>array</B>
      <B>begin</B>     <B>byte</B>
      <B>c</B>         <B>comment</B>    <B>const</B>      <B>constant</B>   <B>continue</B>   <B>cycle</B>
      <B>dynamic</B>
      <B>else</B>      <B>end</B>        <B>event</B>      <B>exit</B>       <B>external</B>
      <B>false</B>     <B>file</B>       <B>finish</B>     <B>fn</B>         <B>for</B>        <B>format</B> <B>fn</B>
      <B>if</B>        <B>include</B>    <B>integer</B>
      <B>like</B>      <B>list</B>       <B>long</B>
      <B>map</B>       <B>monitor</B>
      <B>name</B>      <B>not</B>
      <B>on</B>        <B>of</B>         <B>or</B>         <B>own</B>
      <B>predicate</B> <B>program</B>
      <B>real</B>      <B>record</B>     <B>repeat</B>     <B>result</B>     <B>return</B>     <B>routine</B>
      <B>short</B>     <B>signal</B>     <B>spec</B>       <B>start</B>      <B>stop</B>       <B>string</B>
      <B>switch</B>    <B>system</B>
      <B>then</B>      <B>true</B>
      <B>unless</B>    <B>until</B>
      <B>while</B>


































<HR>

                                  APPENDIX 5

                           COMPARISON WITH EMAS IMP

                1.         New Features

                           <B>for</B>

                           <B>repeat</B> <B>until</B>

                           <B>continue</B>

                           <B>predicate</B>

                           <B>include</B>

                           "==" in conditions

                           <B>integer</B> <B>array</B> (4) <B>name</B>

                           <B>finish</B> <B>else</B> <B>if</B> ...

                           <B>else</B>

                           lower case input

                           <B>like</B>

                           (*) in owns and switches

                           <B>constant</B>

                           <B>function</B>

                           <B>not</B>

                           <B>record</B> <B>function</B>

                           <B>record</B> <B>map</B>

                           constant expressions


















<HR>

                2.         Features not implemented

                           <B>print</B> <B>text</B>

                           <B>until</B> .... <B>cycle</B>

                           <B>array</B> <B>format</B>

                           <B>reals</B> <B>long</B>

                           <B>reals</B> <B>normal</B>

                           implied multiplication



                3.         Changed Features

                           'AA' instead of M'AA'

                           16_1A2 instead of X'1A2'

                           procedure parameter specification

                           <B>record</B>(F) R instead of <B>record</B> R(F)

                           SUBSTRING instead of FROMSTRING

                           termination of comments

                           "\" or "\\" instead of "**"

                           <B>own</B> initialisation

                           type checking for record operations

                           <B>external</B> .. <B>spec</B> instead of <B>extrinsic</B> ..

                           events instead of fault trapping

                           / gives a <B>real</B> result

                           string resolution















</PRE></BODY></HTML>
